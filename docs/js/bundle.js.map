{"version":3,"file":"bundle.js","sources":["webpack:///webpack/bootstrap","webpack:///../ff/out/base/array.js","webpack:///../ff/out/base/date.js","webpack:///../ff/out/base/duration.js","webpack:///../ff/out/base/emitter.js","webpack:///../ff/out/base/es-polyfill.js","webpack:///../ff/out/base/function.js","webpack:///../ff/out/base/index.js","webpack:///../ff/out/base/number.js","webpack:///../ff/out/base/object.js","webpack:///../ff/out/base/queue.js","webpack:///../ff/out/base/string.js","webpack:///../ff/out/base/time.js","webpack:///../ff/out/dom/align.js","webpack:///../ff/out/dom/animate.js","webpack:///../ff/out/dom/element.js","webpack:///../ff/out/dom/file.js","webpack:///../ff/out/dom/html.js","webpack:///../ff/out/dom/index.js","webpack:///../ff/out/dom/mouse-leave.js","webpack:///../ff/out/dom/net.js","webpack:///../ff/out/dom/query.js","webpack:///../ff/out/dom/scroll.js","webpack:///../ff/out/dom/storage.js","webpack:///../ff/out/dom/style.js","webpack:///../ff/out/dom/timing.js","webpack:///../ff/out/dom/utils.js","webpack:///../ff/out/dom/watch-layout.js","webpack:///../ff/out/index.js","webpack:///../flit/out/bindings/class.js","webpack:///../flit/out/bindings/define.js","webpack:///../flit/out/bindings/enable-disable.js","webpack:///../flit/out/bindings/html.js","webpack:///../flit/out/bindings/index.js","webpack:///../flit/out/bindings/model.js","webpack:///../flit/out/bindings/ref-component.js","webpack:///../flit/out/bindings/ref.js","webpack:///../flit/out/bindings/show-hide.js","webpack:///../flit/out/bindings/slot.js","webpack:///../flit/out/bindings/src.js","webpack:///../flit/out/bindings/style.js","webpack:///../flit/out/component/component.js","webpack:///../flit/out/component/custom-element.js","webpack:///../flit/out/component/define.js","webpack:///../flit/out/component/from-element.js","webpack:///../flit/out/component/index.js","webpack:///../flit/out/component/life-cycle.js","webpack:///../flit/out/component/style.js","webpack:///../flit/out/directives/cache.js","webpack:///../flit/out/directives/define.js","webpack:///../flit/out/directives/helpers/offset-children.js","webpack:///../flit/out/directives/helpers/page-data-getter.js","webpack:///../flit/out/directives/helpers/partial-rendering-processor.js","webpack:///../flit/out/directives/helpers/repetitive-template.js","webpack:///../flit/out/directives/index.js","webpack:///../flit/out/directives/live-async-repeat.js","webpack:///../flit/out/directives/live-repeat.js","webpack:///../flit/out/directives/repeat.js","webpack:///../flit/out/directives/toggle.js","webpack:///../flit/out/globals/render.js","webpack:///../flit/out/globals/update.js","webpack:///../flit/out/helpers/edit.js","webpack:///../flit/out/helpers/mini-heap.js","webpack:///../flit/out/helpers/references.js","webpack:///../flit/out/helpers/two-way-map.js","webpack:///../flit/out/helpers/utils.js","webpack:///../flit/out/helpers/weak-2way-map.js","webpack:///../flit/out/helpers/weak-2way-prop-map.js","webpack:///../flit/out/index.js","webpack:///../flit/out/internals/contextual-transition.js","webpack:///../flit/out/internals/dom-event.js","webpack:///../flit/out/internals/html-attributes-parser.js","webpack:///../flit/out/internals/html-token-parser.js","webpack:///../flit/out/internals/internal-event-emitter.js","webpack:///../flit/out/internals/node-anchor.js","webpack:///../flit/out/internals/node-range.js","webpack:///../flit/out/internals/style-parser.js","webpack:///../flit/out/internals/transition.js","webpack:///../flit/out/internals/updatable-options.js","webpack:///../flit/out/observer/dependency.js","webpack:///../flit/out/observer/index.js","webpack:///../flit/out/observer/observe-array.js","webpack:///../flit/out/observer/observe-com.js","webpack:///../flit/out/observer/observe-getter.js","webpack:///../flit/out/observer/observe-object.js","webpack:///../flit/out/observer/observe-set-or-map.js","webpack:///../flit/out/observer/observe.js","webpack:///../flit/out/observer/target-proxy.js","webpack:///../flit/out/queue/helpers/updatable-queue.js","webpack:///../flit/out/queue/helpers/updatable-validator.js","webpack:///../flit/out/queue/index.js","webpack:///../flit/out/queue/queue.js","webpack:///../flit/out/template/index.js","webpack:///../flit/out/template/parts/attr-part.js","webpack:///../flit/out/template/parts/binding-part.js","webpack:///../flit/out/template/parts/event-part.js","webpack:///../flit/out/template/parts/may-attr-part.js","webpack:///../flit/out/template/parts/node-part.js","webpack:///../flit/out/template/parts/property-part.js","webpack:///../flit/out/template/parts/slot-part.js","webpack:///../flit/out/template/template-extends.js","webpack:///../flit/out/template/template-parser.js","webpack:///../flit/out/template/template-result.js","webpack:///../flit/out/template/template.js","webpack:///../flit/out/template/utils.js","webpack:///../flit/out/watchers/globals.js","webpack:///../flit/out/watchers/index.js","webpack:///../flit/out/watchers/watcher-group.js","webpack:///../flit/out/watchers/watcher.js","webpack:///./docs/index.ts","webpack:///./src/bindings/contextmenu.ts","webpack:///./src/bindings/drag-drop.ts","webpack:///./src/bindings/goto.ts","webpack:///./src/bindings/loading.ts","webpack:///./src/bindings/popup.ts","webpack:///./src/bindings/tooltip.ts","webpack:///./src/components/buttongroup.ts","webpack:///./src/components/checkbox.ts","webpack:///./src/components/contextmenu.ts","webpack:///./src/components/dialog.ts","webpack:///./src/components/dropdown.ts","webpack:///./src/components/form.ts","webpack:///./src/components/grid-layout.ts","webpack:///./src/components/helpers/column-width-resizer.ts","webpack:///./src/components/helpers/table-state.ts","webpack:///./src/components/helpers/tree-data-navigator.ts","webpack:///./src/components/icon.ts","webpack:///./src/components/input.ts","webpack:///./src/components/list.ts","webpack:///./src/components/loader.ts","webpack:///./src/components/menu.ts","webpack:///./src/components/modal.ts","webpack:///./src/components/navigation.ts","webpack:///./src/components/notification.ts","webpack:///./src/components/popover.ts","webpack:///./src/components/popup.ts","webpack:///./src/components/progress.ts","webpack:///./src/components/radio.ts","webpack:///./src/components/resizer.ts","webpack:///./src/components/router.ts","webpack:///./src/components/search.ts","webpack:///./src/components/select.ts","webpack:///./src/components/slider.ts","webpack:///./src/components/switch.ts","webpack:///./src/components/table.ts","webpack:///./src/components/tag.ts","webpack:///./src/components/tooltip.ts","webpack:///./src/icons/icons.ts","webpack:///./src/icons/icons/checkbox-checked.svg","webpack:///./src/icons/icons/checkbox-indeterminate.svg","webpack:///./src/icons/icons/checkbox-unchecked.svg","webpack:///./src/icons/icons/checked.svg","webpack:///./src/icons/icons/close.svg","webpack:///./src/icons/icons/confirm.svg","webpack:///./src/icons/icons/down.svg","webpack:///./src/icons/icons/error.svg","webpack:///./src/icons/icons/info.svg","webpack:///./src/icons/icons/love.svg","webpack:///./src/icons/icons/order-asc.svg","webpack:///./src/icons/icons/order-default.svg","webpack:///./src/icons/icons/order-desc.svg","webpack:///./src/icons/icons/radio-checked.svg","webpack:///./src/icons/icons/radio-unchecked.svg","webpack:///./src/icons/icons/refresh.svg","webpack:///./src/icons/icons/right.svg","webpack:///./src/icons/icons/search.svg","webpack:///./src/icons/icons/success.svg","webpack:///./src/icons/icons/tips.svg","webpack:///./src/icons/icons/triangle-down.svg","webpack:///./src/icons/icons/triangle-right.svg","webpack:///./src/icons/icons/warning.svg","webpack:///./src/index.ts","webpack:///./src/store/helpers/key-map.ts","webpack:///./src/store/helpers/page-data-cacher.ts","webpack:///./src/store/remote-store.ts","webpack:///./src/store/store.ts","webpack:///./src/style/color.ts","webpack:///./src/style/global-style.ts","webpack:///./src/style/theme.ts","webpack:///./src/translations/translations.ts","webpack:///./src/utils/element.ts"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./docs/index.ts\");\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.maxIndex = exports.minIndex = exports.max = exports.min = exports.avg = exports.sum = exports.count = exports.aggregate = exports.groupBy = exports.indexBy = exports.orderBy = exports.Order = exports.binaryFindIndexToInsert = exports.binaryFindIndex = exports.binaryFind = exports.difference = exports.intersect = exports.union = exports.unique = exports.removeWhere = exports.removeFirst = exports.remove = exports.add = exports.repeatForTimes = void 0;\r\n/**\r\n * Returns the array filled with `value` and repeated for `count` times.\r\n * It's just like `string.repeat(count).`\r\n * @param item The value to repeat.\r\n * @param count Count of times to repeat.\r\n */\r\nfunction repeatForTimes(item, count) {\r\n    let items = [];\r\n    for (let i = 0; i < count; i++) {\r\n        items.push(item);\r\n    }\r\n    return items;\r\n}\r\nexports.repeatForTimes = repeatForTimes;\r\n/**\r\n * Add `items` to an `array`, but duplicate items will not be added.\r\n * This method uses `includes` to test if an item in array, so it doesn't fit for adding many items to a big array.\r\n * @param array The array to add items.\r\n * @param items The items to add to array.\r\n */\r\nfunction add(array, ...items) {\r\n    for (let item of items) {\r\n        if (!array.includes(item)) {\r\n            array.push(item);\r\n        }\r\n    }\r\n    return array;\r\n}\r\nexports.add = add;\r\n/**\r\n * Remove all the `items` from `array`, and returns the removed items.\r\n * Note that this method uses `splice` to remove items, and only removes each item for once.\r\n * So using `array.filter` to filter out multiple items would be better.\r\n * @param array The array to remove items.\r\n * @param items The items removed from array.\r\n */\r\nfunction remove(array, ...items) {\r\n    let removed = [];\r\n    for (let item of items) {\r\n        let index = array.indexOf(item);\r\n        if (index > -1) {\r\n            removed.push(...array.splice(index, 1));\r\n        }\r\n    }\r\n    return removed;\r\n}\r\nexports.remove = remove;\r\n/**\r\n * Removes the first item which match `fn` from `array`. Returns the removed items.\r\n * @param array The array to remove items.\r\n * @param fn The test function to determinae whether to remove item.\r\n */\r\nfunction removeFirst(array, fn) {\r\n    for (let i = array.length - 1; i >= 0; i--) {\r\n        if (fn(array[i], i)) {\r\n            return array.splice(i, 1)[0];\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\nexports.removeFirst = removeFirst;\r\n/**\r\n * Remove all the items in `array` that match test function `fn`.\r\n * Returns the removed items.\r\n * Note that this method uses `splice` to remove items, so using `array.filter` to filter out multiple items would be better.\r\n * @param array The array to remove items.\r\n * @param fn The test function to determinae whether to remove item.\r\n */\r\nfunction removeWhere(array, fn) {\r\n    let removed = [];\r\n    for (let i = 0; i < array.length; i++) {\r\n        if (fn(array[i], i)) {\r\n            removed.push(array.splice(i--, 1)[0]);\r\n        }\r\n    }\r\n    return removed;\r\n}\r\nexports.removeWhere = removeWhere;\r\n/**\r\n * Returns a new array from picking unique items from `array` and removing duplicate items.\r\n * @param array The array to remove duplicate items.\r\n */\r\nfunction unique(array) {\r\n    let set = new Set(array);\r\n    return [...set];\r\n}\r\nexports.unique = unique;\r\n/**\r\n * Creates an array composed of all the unique values from given `arrays`.\r\n * @param arrays The arrays to get union from.\r\n */\r\nfunction union(...arrays) {\r\n    let set = new Set();\r\n    for (let array of arrays) {\r\n        for (let item of array) {\r\n            set.add(item);\r\n        }\r\n    }\r\n    return [...set];\r\n}\r\nexports.union = union;\r\n/**\r\n * Creates an array from picking intersect values that are included in all given `arrays`.\r\n * @param arrays The arrays to get intersection from.\r\n */\r\nfunction intersect(...arrays) {\r\n    let interset = [];\r\n    if (!arrays.length) {\r\n        return interset;\r\n    }\r\n    let map = new Map();\r\n    for (let item of arrays[0]) {\r\n        map.set(item, 1);\r\n    }\r\n    for (let array of arrays.slice(1)) {\r\n        for (let item of array) {\r\n            if (map.has(item)) {\r\n                map.set(item, map.get(item) + 1);\r\n            }\r\n        }\r\n    }\r\n    for (let [item, count] of map.entries()) {\r\n        if (count === arrays.length) {\r\n            interset.push(item);\r\n        }\r\n    }\r\n    return interset;\r\n}\r\nexports.intersect = intersect;\r\n/**\r\n * Creates a new array from picking items from `array` and excluding items in `excludeArrays`.\r\n * @param array The array to pick items.\r\n * @param excludeArrays The arrays to exclude items from.\r\n */\r\nfunction difference(array, ...excludeArrays) {\r\n    let set = new Set(array);\r\n    for (let difArray of excludeArrays) {\r\n        for (let item of difArray) {\r\n            set.delete(item);\r\n        }\r\n    }\r\n    return [...set];\r\n}\r\nexports.difference = difference;\r\n/**\r\n * Using binary algorithm to find one item from a sorted array that matches test function `fn`.\r\n * @param array The sorted array to find items from.\r\n * @param fn The function to accept 2 items in array as parameters and returns negative value to move left, positive value to move right.\r\n */\r\nfunction binaryFind(array, fn) {\r\n    let index = binaryFindIndex(array, fn);\r\n    return index === -1 ? undefined : array[index];\r\n}\r\nexports.binaryFind = binaryFind;\r\n/**\r\n * Using binary algorithm to find index from a sorted array at where the item match `fn`.\r\n * @param array The sorted array.\r\n * @param fn The function to accept item in array as parameter and returns negative value to move left, positive value to move right.\r\n */\r\nfunction binaryFindIndex(array, fn) {\r\n    if (array.length === 0) {\r\n        return -1;\r\n    }\r\n    let result = fn(array[0]);\r\n    if (result === 0) {\r\n        return 0;\r\n    }\r\n    if (result < 0) {\r\n        return -1;\r\n    }\r\n    if (array.length === 1) {\r\n        return -1;\r\n    }\r\n    result = fn(array[array.length - 1]);\r\n    if (result === 0) {\r\n        return array.length - 1;\r\n    }\r\n    if (result > 0) {\r\n        return -1;\r\n    }\r\n    let start = 0;\r\n    let end = array.length - 1;\r\n    while (end - start > 1) {\r\n        let center = Math.floor((end + start) / 2);\r\n        let result = fn(array[center]);\r\n        if (result === 0) {\r\n            return center;\r\n        }\r\n        else if (result < 0) {\r\n            end = center;\r\n        }\r\n        else {\r\n            start = center;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\nexports.binaryFindIndex = binaryFindIndex;\r\n/**\r\n * Using binary algorithm to find the closest index from a sorted array at where to insert new item and keep order.\r\n * Returned index betweens `0 ~ array.length`, and if `array[index]` exist, `fn(array[index]) >= 0`.\r\n * @param array The sorted array.\r\n * @param fn The function to accept item in array as parameter and returns nagative value to move left, positive value to move right.\r\n */\r\nfunction binaryFindIndexToInsert(array, fn) {\r\n    if (array.length === 0) {\r\n        return 0;\r\n    }\r\n    let result = fn(array[0]);\r\n    if (result === 0 || result < 0) {\r\n        return 0;\r\n    }\r\n    if (array.length === 1) {\r\n        return 1;\r\n    }\r\n    result = fn(array[array.length - 1]);\r\n    if (result === 0) {\r\n        return array.length - 1;\r\n    }\r\n    if (result > 0) {\r\n        return array.length;\r\n    }\r\n    let start = 0;\r\n    let end = array.length - 1;\r\n    while (end - start > 1) {\r\n        let center = Math.floor((end + start) / 2);\r\n        let result = fn(array[center]);\r\n        if (result === 0) {\r\n            return center;\r\n        }\r\n        else if (result < 0) {\r\n            end = center;\r\n        }\r\n        else {\r\n            start = center;\r\n        }\r\n    }\r\n    return end;\r\n}\r\nexports.binaryFindIndexToInsert = binaryFindIndexToInsert;\r\n/** Class to do multiple columns object array ordering. */\r\nclass Order {\r\n    /**\r\n     * Create an order rule, used in `orderBy`, and can also be used to binary search from or binary insert into array with object type items\r\n     * @param orders Rest parameters of type `key` or `OrderFunction` which will return a `key`, or [`key` / `OrderFunction`, `OrderDirection`].\r\n     */\r\n    constructor(...orders) {\r\n        /** Order tuple for ordering one by one. */\r\n        this.orders = [];\r\n        for (let order of orders) {\r\n            if (['string', 'number', 'function'].includes(typeof order)) {\r\n                this.orders.push([order, 1]);\r\n            }\r\n            else if (Array.isArray(order) && ['string', 'number', 'function'].includes(typeof order[0])) {\r\n                this.orders.push([order[0], order[1] === 'asc' ? 1 : order[1] === 'desc' ? -1 : order[1]]);\r\n            }\r\n            else {\r\n                throw new TypeError(JSON.stringify(orders) + ' doesn\\'t specify any valid key or order.');\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Sort `array` inside by current order.\r\n     * @param array The array to sort.\r\n     */\r\n    sortArray(array, direction = 1) {\r\n        let normalizedDirection = direction === 'asc' ? 1 : direction === 'desc' ? -1 : direction;\r\n        array.sort((a, b) => {\r\n            return this.compare(a, b) * normalizedDirection;\r\n        });\r\n    }\r\n    /**\r\n     * Compare two items.\r\n     * When `order` is `1` or `asc`: returns `0` if they are same; returns `-1` if the first one less that the second one; else returns `1`.\r\n     * When `order` is `-1` or `desc`: returns `0` if they are same; returns `1` if the first one less that the second one; else returns `-1`.\r\n     * @param a First item.\r\n     * @param b Second item.\r\n     */\r\n    compare(a, b) {\r\n        for (let [keyOrFn, order] of this.orders) {\r\n            let ai;\r\n            let bi;\r\n            if (typeof keyOrFn === 'function') {\r\n                ai = keyOrFn(a);\r\n                bi = keyOrFn(b);\r\n            }\r\n            else {\r\n                ai = a[keyOrFn];\r\n                bi = b[keyOrFn];\r\n            }\r\n            if (ai < bi) {\r\n                return -order;\r\n            }\r\n            if (ai > bi) {\r\n                return order;\r\n            }\r\n            if (ai !== bi) {\r\n                return ai === null || ai === undefined ? -order : order;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n    /**\r\n     * Binary find the index from `array` the value at where equals to `item`.\r\n     * Returns `-1` if not found.\r\n     * @param array The array to lookup.\r\n     * @param item The item to search.\r\n     */\r\n    binaryFind(array, item) {\r\n        return binaryFind(array, i => this.compare(item, i));\r\n    }\r\n    /**\r\n     * Binary find an index from `array` to insert `item` and keep current order.\r\n     * Returned value betweens `0 ~ array.length`.\r\n     * @param array The array to lookup.\r\n     * @param item The item to compare.\r\n     */\r\n    binaryFindIndex(array, item) {\r\n        return binaryFindIndex(array, i => this.compare(item, i));\r\n    }\r\n    /**\r\n     * Binary insert an `item` into `array` and keeps current order.\r\n     * Note it uses `splice` to insert item, it's very slower since it reallocates memory frequently.\r\n     * @param array The array to lookup.\r\n     * @param item The item to insert.\r\n     */\r\n    binaryInsert(array, item) {\r\n        let index = binaryFindIndexToInsert(array, i => this.compare(item, i));\r\n        array.splice(index, 0, item);\r\n        return array;\r\n    }\r\n}\r\nexports.Order = Order;\r\nfunction orderBy(array, order, ...orders) {\r\n    order = order instanceof Order ? order : new Order(order, ...orders);\r\n    order.sortArray(array);\r\n    return array;\r\n}\r\nexports.orderBy = orderBy;\r\n// Compare with `new Map(...)`, object has same performance, and is more convinent to use, but will lose number key type.\r\nfunction indexBy(array, keyOrFn) {\r\n    let map = new Map();\r\n    if (typeof keyOrFn === 'function') {\r\n        for (let item of array) {\r\n            let [key, value] = keyOrFn(item);\r\n            map.set(key, value);\r\n        }\r\n    }\r\n    else {\r\n        for (let item of array) {\r\n            let key = item[keyOrFn];\r\n            map.set(key, item);\r\n        }\r\n    }\r\n    return map;\r\n}\r\nexports.indexBy = indexBy;\r\nfunction groupBy(array, keyOrFn) {\r\n    let map = new Map();\r\n    for (let item of array) {\r\n        let key;\r\n        let value = item;\r\n        if (typeof keyOrFn === 'function') {\r\n            [key, value] = keyOrFn(item);\r\n        }\r\n        else {\r\n            key = item[keyOrFn];\r\n        }\r\n        let group = map.get(key);\r\n        if (!group) {\r\n            group = [];\r\n            map.set(key, group);\r\n        }\r\n        group.push(value);\r\n    }\r\n    return map;\r\n}\r\nexports.groupBy = groupBy;\r\nfunction aggregate(array, keyOrFn, aggregateFn) {\r\n    let groupMap;\r\n    let aggregateMap = new Map();\r\n    if (typeof keyOrFn === 'function') {\r\n        groupMap = groupBy(array, item => [keyOrFn(item), item]);\r\n    }\r\n    else {\r\n        groupMap = groupBy(array, keyOrFn);\r\n    }\r\n    for (let [key, values] of groupMap.entries()) {\r\n        aggregateMap.set(key, aggregateFn(values, key));\r\n    }\r\n    return aggregateMap;\r\n}\r\nexports.aggregate = aggregate;\r\n/**\r\n * Returns the length of the array. Just a util function for `ff.aggregate`.\r\n * @param array The array to count length.\r\n */\r\nfunction count(array) {\r\n    return array.length;\r\n}\r\nexports.count = count;\r\n/**\r\n * Returns the sum of all the numberic values in `array`.\r\n * @param array The array of numberic values.\r\n */\r\nfunction sum(array) {\r\n    return array.reduce((v1, v2) => v1 + v2, 0);\r\n}\r\nexports.sum = sum;\r\n/**\r\n * Returns the average value of the numberic values in `array`.\r\n * Returns `0` if no items in `array`.\r\n * @param array The array of numberic values.\r\n */\r\nfunction avg(array) {\r\n    if (array.length === 0) {\r\n        return 0;\r\n    }\r\n    return sum(array) / array.length;\r\n}\r\nexports.avg = avg;\r\n/**\r\n * Returns the minimal value of the numberic values in `array`.\r\n * Returns `Infinity` if no items in `array`.\r\n * @param array The array of numberic values.\r\n */\r\nfunction min(array) {\r\n    return Math.min(...array);\r\n}\r\nexports.min = min;\r\n/**\r\n * Returns the maximun value of numberic values in `array`.\r\n * Returns `-Infinity` if no items in `array`.\r\n * @param array The array of numberic values.\r\n */\r\nfunction max(array) {\r\n    return Math.max(...array);\r\n}\r\nexports.max = max;\r\n/**\r\n * Returns the index of the minimal value of the array items.\r\n * Returns `-1` if no items or all values are `Infinity`.\r\n * @param array The array of data items.\r\n * @param map The map function to map each item to a number.\r\n */\r\nfunction minIndex(array, map) {\r\n    let values;\r\n    if (map) {\r\n        values = array.map(map);\r\n    }\r\n    else {\r\n        values = array;\r\n    }\r\n    let minIndex = -1;\r\n    let minValue = Infinity;\r\n    for (let i = 0; i < values.length; i++) {\r\n        if (values[i] < minValue) {\r\n            minIndex = i;\r\n            minValue = values[i];\r\n        }\r\n    }\r\n    return minIndex;\r\n}\r\nexports.minIndex = minIndex;\r\n/**\r\n * Returns the index of the maximun value of the array items.R\r\n * Returns `-1` if no items or all values are `-Infinity`.\r\n * @param array The array of data items.\r\n * @param map The map function to map each item to a number.\r\n */\r\nfunction maxIndex(array, map) {\r\n    let values;\r\n    if (map) {\r\n        values = array.map(map);\r\n    }\r\n    else {\r\n        values = array;\r\n    }\r\n    let maxIndex = -1;\r\n    let maxValue = -Infinity;\r\n    for (let i = 0; i < values.length; i++) {\r\n        if (values[i] > maxValue) {\r\n            maxIndex = i;\r\n            maxValue = values[i];\r\n        }\r\n    }\r\n    return maxIndex;\r\n}\r\nexports.maxIndex = maxIndex;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.formatToShortDate = exports.formatDate = exports.addDurationToDate = exports.cloneDate = exports.getDaysOfMonth = exports.getDaysOfYear = exports.isLeapYear = exports.isValidDate = exports.setDateByUnit = exports.getDateByUnit = void 0;\r\nconst duration_1 = require(\"./duration\");\r\n/** All data units from year to seconds. */\r\nconst DateUnits = 'yMdhms';\r\n/**\r\n * Get one of the date values from `date` according to specified `unit`.\r\n * @param date The date object to get value from.\r\n * @param unit The unit type, must be one of `'y', 'M', 'd', 'h', 'm', 's'`.\r\n */\r\nfunction getDateByUnit(date, unit) {\r\n    switch (unit) {\r\n        case 'y':\r\n            return date.getFullYear();\r\n        case 'M':\r\n            return date.getMonth();\r\n        case 'd':\r\n            return date.getDate();\r\n        case 'h':\r\n            return date.getHours();\r\n        case 'm':\r\n            return date.getMinutes();\r\n        case 's':\r\n            return date.getSeconds();\r\n        default:\r\n            throw new Error(`\"${unit}\" is not a valid date unit`);\r\n    }\r\n}\r\nexports.getDateByUnit = getDateByUnit;\r\n/**\r\n * Set one of the date values for `date` according to specified `unit`.\r\n * @param date The date object to set value.\r\n * @param value The date value to set.\r\n * @param unit The unit type, must be one of `'y', 'M', 'd', 'h', 'm', 's'`.\r\n */\r\nfunction setDateByUnit(date, value, unit) {\r\n    switch (unit) {\r\n        case 'y':\r\n            return date.setFullYear(value);\r\n        case 'M':\r\n            return date.setMonth(value);\r\n        case 'd':\r\n            return date.setDate(value);\r\n        case 'h':\r\n            return date.setHours(value);\r\n        case 'm':\r\n            return date.setMinutes(value);\r\n        case 's':\r\n            return date.setSeconds(value);\r\n        default:\r\n            throw new Error(`\"${unit}\" is not a valid date unit`);\r\n    }\r\n}\r\nexports.setDateByUnit = setDateByUnit;\r\n/**\r\n * Returns whether date values from year to second are associated with a real date.\r\n * @param y Year count.\r\n * @param M Month count.\r\n * @param d Date count.\r\n * @param h Hour count.\r\n * @param m Minute count.\r\n * @param s Second count.\r\n */\r\nfunction isValidDate(y, M, d = 1, h = 0, m = 0, s = 0) {\r\n    let date = new Date(y, M, d, h, m, s);\r\n    return y === date.getFullYear() &&\r\n        M === date.getMonth() &&\r\n        d === date.getDate() &&\r\n        h === date.getHours() &&\r\n        m === date.getMinutes() &&\r\n        s === date.getSeconds();\r\n}\r\nexports.isValidDate = isValidDate;\r\n/**\r\n * Returns whether the year of `date` is a leap year, which contains 366 days.\r\n * @param date The date to test.\r\n */\r\nfunction isLeapYear(date) {\r\n    let year = date.getFullYear();\r\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\r\n}\r\nexports.isLeapYear = isLeapYear;\r\n/**\r\n * Returns the days in the year from `date`, which is `366` for leap year, and is `365` otherwise.\r\n * @param date The date to get days from.\r\n */\r\nfunction getDaysOfYear(date) {\r\n    return isLeapYear(date) ? 366 : 365;\r\n}\r\nexports.getDaysOfYear = getDaysOfYear;\r\n/**\r\n * Returns the days in the month from a `date`, which betweens `28-31`.\r\n * @param date The date to get days from.\r\n */\r\nfunction getDaysOfMonth(date) {\r\n    let d = new Date(date.getTime());\r\n    d.setDate(32);\r\n    return 32 - d.getDate();\r\n}\r\nexports.getDaysOfMonth = getDaysOfMonth;\r\n/**\r\n * Clones a date object.\r\n * Can specify `units` to partly clone, `units` not includeded parts will be set to minimal value.\r\n * @param date The date to clone, default value is current date.\r\n * @param units The units to partly clone, default value is `yMdhms`.\r\n */\r\nfunction cloneDate(date = new Date(), units = DateUnits) {\r\n    let dateValues = [...DateUnits].map(unit => {\r\n        if (units.includes(unit)) {\r\n            return getDateByUnit(date, unit);\r\n        }\r\n        else {\r\n            return unit === 'd' ? 1 : 0;\r\n        }\r\n    });\r\n    return new Date(dateValues[0], dateValues[1], dateValues[2], dateValues[3], dateValues[4], dateValues[5]);\r\n}\r\nexports.cloneDate = cloneDate;\r\n/**\r\n * Add `duration` string as a time offset to a `date` and returns a new date.\r\n * @param date The date to add duration.\r\n * @param duration The duration string to add to date. like `1d1h`.\r\n */\r\nfunction addDurationToDate(date, duration) {\r\n    let isMinus = duration[0] === '-';\r\n    if (isMinus) {\r\n        duration = duration.slice(1);\r\n    }\r\n    let flag = isMinus ? -1 : 1;\r\n    let o = duration_1.parseDurationToObject(duration);\r\n    let newDate = new Date(date);\r\n    for (let unit of Object.keys(o)) {\r\n        let value = getDateByUnit(newDate, unit) + o[unit] * flag;\r\n        setDateByUnit(newDate, value, unit);\r\n    }\r\n    return newDate;\r\n}\r\nexports.addDurationToDate = addDurationToDate;\r\n/**\r\n * Returns a formatted date string from `date` and `format` type.\r\n * @param date The date to format.\r\n * @param format The date format type, default value is `'yyyy-MM-dd hh:mm:ss'`.\r\n */\r\nfunction formatDate(date, format = 'yyyy-MM-dd hh:mm:ss') {\r\n    return format.replace(/y+|M+|d+|h+|m+|s+/g, m0 => {\r\n        let unit = m0[0];\r\n        let value = getDateByUnit(date, unit[0]);\r\n        if (unit === 'M') {\r\n            value += 1;\r\n        }\r\n        return String(value).padStart(m0.length, '0');\r\n    });\r\n}\r\nexports.formatDate = formatDate;\r\n/**\r\n * Returns a short date string relative to current time.\r\n * @param date The date to format.\r\n * @param format The format object to use, default value is `{y: 'yyyy-MM-dd', M: 'MM-dd', h: 'hh:mm'}`.\r\n */\r\nfunction formatToShortDate(date, format = { y: 'yyyy-MM-dd', M: 'MM-dd', h: 'hh:mm' }) {\r\n    let now = new Date();\r\n    let hasDifferentUnit = false;\r\n    let matchFormat = Object.values(format)[0];\r\n    for (let unit of DateUnits) {\r\n        hasDifferentUnit = hasDifferentUnit || getDateByUnit(date, unit) !== getDateByUnit(now, unit);\r\n        matchFormat = format[unit] || matchFormat;\r\n        if (hasDifferentUnit) {\r\n            break;\r\n        }\r\n    }\r\n    return formatDate(date, matchFormat);\r\n}\r\nexports.formatToShortDate = formatToShortDate;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.formatSecondsToTime = exports.formatSecondsToDuration = exports.parseSecondsToDateObject = exports.parseDurationToSeconds = exports.parseDurationToObject = void 0;\r\nconst string_1 = require(\"./string\");\r\n/** All data units from year to seconds. */\r\nconst DateUnits = 'yMdhms';\r\n/** Date units and their mapped seconds. */\r\nconst DATE_UNIT_SECONDS = {\r\n    y: 365 * 24 * 60 * 60,\r\n    M: 30 * 24 * 60 * 60,\r\n    w: 7 * 24 * 60 * 60,\r\n    d: 24 * 60 * 60,\r\n    h: 60 * 60,\r\n    m: 60,\r\n    s: 1,\r\n};\r\n/**\r\n * Parse `duration` string like `1h1m` or `01:01:00` to date object `{y, M, d, h, m, s}`.\r\n * @param duration string like `1h1m` or `01:01:00`.\r\n */\r\nfunction parseDurationToObject(duration) {\r\n    let o = {\r\n        y: 0,\r\n        M: 0,\r\n        d: 0,\r\n        h: 0,\r\n        m: 0,\r\n        s: 0,\r\n    };\r\n    if (duration.includes(':')) {\r\n        let [h, m, s] = string_1.subMatches(duration, /(?:(\\d\\d):)?(\\d\\d):(\\d\\d(?:\\.\\d+)?)/)[0].map(v => Number(v) || 0);\r\n        o.h = h;\r\n        o.m = m;\r\n        o.s = s;\r\n    }\r\n    else {\r\n        let matches = string_1.subMatches(duration, /(\\d+(?:\\.\\d+)?) ?([yMwdhms])/g);\r\n        for (let [count, unit] of matches) {\r\n            o[unit] = Number(count);\r\n        }\r\n    }\r\n    return o;\r\n}\r\nexports.parseDurationToObject = parseDurationToObject;\r\n/**\r\n * Parse duration string like `1h1m` or `01:01:00` to second count.\r\n * @param duration string like `1h1m` or `01:01:00`.\r\n */\r\nfunction parseDurationToSeconds(duration) {\r\n    let o = parseDurationToObject(duration);\r\n    let seconds = 0;\r\n    for (let unit of Object.keys(o)) {\r\n        let count = o[unit];\r\n        seconds += count * DATE_UNIT_SECONDS[unit];\r\n    }\r\n    return seconds;\r\n}\r\nexports.parseDurationToSeconds = parseDurationToSeconds;\r\n/**\r\n * Parse second count to date object `{y, M, d, h, m, s}`.\r\n * @param seconds The second count.\r\n * @param units The unit to use when parsing, default value is `yMdhms`.\r\n */\r\nfunction parseSecondsToDateObject(seconds, units = DateUnits) {\r\n    let o = {\r\n        y: 0,\r\n        M: 0,\r\n        d: 0,\r\n        h: 0,\r\n        m: 0,\r\n        s: 0,\r\n    };\r\n    for (let unit of units) {\r\n        let unitValue = DATE_UNIT_SECONDS[unit];\r\n        let count = Math.floor(seconds / unitValue);\r\n        if (count > 0) {\r\n            o[unit] = count;\r\n            seconds = seconds % unitValue;\r\n        }\r\n    }\r\n    return o;\r\n}\r\nexports.parseSecondsToDateObject = parseSecondsToDateObject;\r\n/**\r\n * Format second count to duration string like `1h1m`.\r\n * @param units Date unit types like `yMdhms`. Can only specify partial date units like `Md`.\r\n * @param maxOutputUnitCount Maximun unit count of the duration string. E.g., sepcify to `2` to output like `1y1M`, `1M1d`, `1d1h`, `1s`.\r\n */\r\nfunction formatSecondsToDuration(seconds, units = DateUnits, maxOutputUnitCount = units.length) {\r\n    let o = parseSecondsToDateObject(seconds, units);\r\n    let duration = '';\r\n    let outputUnitCount = 0;\r\n    for (let unit of Object.keys(o)) {\r\n        let count = o[unit];\r\n        if (count > 0) {\r\n            duration += count + unit;\r\n            outputUnitCount++;\r\n        }\r\n        if (outputUnitCount >= maxOutputUnitCount) {\r\n            break;\r\n        }\r\n    }\r\n    return duration;\r\n}\r\nexports.formatSecondsToDuration = formatSecondsToDuration;\r\n/**\r\n * Format second count to time string like `01:01:01`.\r\n * @param seconds The second count.\r\n */\r\nfunction formatSecondsToTime(seconds) {\r\n    let h = Math.floor(seconds / 3600);\r\n    let m = Math.floor(seconds % 3600 / 60) || 0;\r\n    let s = Math.floor(seconds % 60) || 0;\r\n    return (h ? String(h).padStart(2, '0') + ':' : '')\r\n        + String(m).padStart(2, '0') + ':'\r\n        + String(s).padStart(2, '0');\r\n}\r\nexports.formatSecondsToTime = formatSecondsToTime;\r\n","\"use strict\";\r\n// At beginning, I implemented a good Emitter by inferring listener parameters and emitting parameters.\r\n// But then I meet a big problem when extending the class, described by:\r\n// https://stackoverflow.com/questions/55813041/problems-on-typescript-event-interface-extends\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Emitter = void 0;\r\n/**\r\n * Event emitter as super class to listen and emit custom events.\r\n * It's name is Emitter to avoid conflicts with node API.\r\n * @typeparam E Event interface in `{eventName: (...args) => void}` format.\r\n */\r\nclass Emitter {\r\n    constructor() {\r\n        /** Registered events. */\r\n        this.__events = new Map();\r\n    }\r\n    /** Ensure event cache items to cache item. */\r\n    __ensureEvents(name) {\r\n        let events = this.__events.get(name);\r\n        if (!events) {\r\n            this.__events.set(name, events = []);\r\n        }\r\n        return events;\r\n    }\r\n    /**\r\n     * Registers an event `listener` to listen event with specified `name`.\r\n     * @param name The event name.\r\n     * @param listener The event listener.\r\n     * @param scope The scope will be binded to listener.\r\n     */\r\n    on(name, listener, scope) {\r\n        let events = this.__ensureEvents(name);\r\n        events.push({\r\n            listener,\r\n            scope,\r\n            once: false,\r\n        });\r\n    }\r\n    /**\r\n     * Registers an event `listener` to listen event with specified `name`, triggers for only once.\r\n     * @param name The event name.\r\n     * @param listener The event listener.\r\n     * @param scope The scope will be binded to listener.\r\n     */\r\n    once(name, listener, scope) {\r\n        let events = this.__ensureEvents(name);\r\n        events.push({\r\n            listener,\r\n            scope,\r\n            once: true\r\n        });\r\n    }\r\n    /**\r\n     * Removes the `listener` that is listening specified event `name`.\r\n     * @param name The event name.\r\n     * @param listener The event listener, only matched listener will be removed.\r\n     * @param scope The scope binded to listener. If provided, remove listener only when scope match.\r\n     */\r\n    off(name, listener, scope) {\r\n        let events = this.__events.get(name);\r\n        if (events) {\r\n            for (let i = events.length - 1; i >= 0; i--) {\r\n                let event = events[i];\r\n                if (event.listener === listener && (!scope || event.scope === scope)) {\r\n                    events.splice(i, 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Check whether `listener` is in the list for listening specified event `name`.\r\n     * @param name The event name.\r\n     * @param listener The event listener to check.\r\n     * @param scope The scope binded to listener. If provided, will additionally check whether the scope match.\r\n     */\r\n    hasListener(name, listener, scope) {\r\n        let events = this.__events.get(name);\r\n        if (events) {\r\n            for (let i = 0, len = events.length; i < len; i++) {\r\n                let event = events[i];\r\n                if (event.listener === listener && (!scope || event.scope === scope)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Check whether any `listener` is listening specified event `name`.\r\n     * @param name The event name.\r\n     */\r\n    hasListeners(name) {\r\n        let events = this.__events.get(name);\r\n        return !!events && events.length > 0;\r\n    }\r\n    /**\r\n     * Emit specified event with event `name` and parameters.\r\n     * @param name The event name.\r\n     * @param args The parameters that will be passed to event listeners.\r\n     */\r\n    emit(name, ...args) {\r\n        let events = this.__events.get(name);\r\n        if (events) {\r\n            for (let i = 0; i < events.length; i++) {\r\n                let event = events[i];\r\n                // The listener may call off, so must remove it before handling\r\n                if (event.once === true) {\r\n                    events.splice(i--, 1);\r\n                }\r\n                event.listener.apply(event.scope, args);\r\n            }\r\n        }\r\n    }\r\n    /** Removes all the event listeners. */\r\n    removeAllListeners() {\r\n        this.__events = new Map();\r\n    }\r\n}\r\nexports.Emitter = Emitter;\r\n","\"use strict\";\r\n/* Polyfill for parts of ECMAScript 2017+, which is not widely supported by modern browsers. */\r\nif (!String.prototype.padStart) {\r\n    Object.defineProperty(String.prototype, 'padStart', {\r\n        value: function (length, fillString) {\r\n            let len = this.length;\r\n            let lenPad = fillString.length;\r\n            if (length < len || !lenPad) {\r\n                return String(this);\r\n            }\r\n            else {\r\n                let repeatCount = Math.floor((length - len) / lenPad);\r\n                let additionStr = fillString.slice(0, length - len - repeatCount * lenPad);\r\n                return fillString.repeat(repeatCount) + additionStr + this;\r\n            }\r\n        }\r\n    });\r\n}\r\nif (!String.prototype.padEnd) {\r\n    Object.defineProperty(String.prototype, 'padEnd', {\r\n        value: function (length, fillString) {\r\n            let len = this.length;\r\n            let lenPad = fillString.length;\r\n            if (length < len || !lenPad) {\r\n                return String(this);\r\n            }\r\n            else {\r\n                let repeatCount = Math.floor((length - len) / lenPad);\r\n                let additionStr = fillString.slice(0, length - len - repeatCount * lenPad);\r\n                return this + fillString.repeat(repeatCount) + additionStr;\r\n            }\r\n        }\r\n    });\r\n}\r\n// Still a proposal, but I love it.\r\nif (!RegExp.escape) {\r\n    Object.defineProperty(RegExp, 'escape', {\r\n        value: function (source) {\r\n            return source.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\r\n        }\r\n    });\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.debounce = exports.Debounce = exports.smoothThrottle = exports.SmoothThrottle = exports.throttle = exports.Throttle = exports.interval = exports.Interval = exports.timeout = exports.Timeout = void 0;\r\nclass TimingFunction {\r\n    constructor(fn, ms) {\r\n        this.id = null;\r\n        /** Whether current timing function has been canceled. */\r\n        this.canceled = false;\r\n        this.fn = fn;\r\n        this.ms = ms;\r\n    }\r\n}\r\nclass WrappedTimingFunction extends TimingFunction {\r\n    constructor(fn, ms) {\r\n        super(fn, ms);\r\n        this.wrapped = this.wrap();\r\n        // To track original handler so that we can unregister the wrapped function in event listener.\r\n        this.wrapped.__original = fn;\r\n    }\r\n}\r\nclass Timeout extends TimingFunction {\r\n    constructor(fn, ms) {\r\n        super(fn, ms);\r\n        this.reset();\r\n    }\r\n    /** Restart timeout, although it was called. */\r\n    reset() {\r\n        if (this.id) {\r\n            clearTimeout(this.id);\r\n        }\r\n        this.id = setTimeout(this.onTimeout.bind(this), this.ms);\r\n        return true;\r\n    }\r\n    onTimeout() {\r\n        this.id = null;\r\n        this.fn();\r\n    }\r\n    /**\r\n     * Call deferred function immediately if it wasn't been called.\r\n     * Returns `true` if not called yet.\r\n     */\r\n    flush() {\r\n        if (!this.id) {\r\n            return false;\r\n        }\r\n        clearTimeout(this.id);\r\n        this.id = null;\r\n        this.fn();\r\n        return true;\r\n    }\r\n    /**\r\n     * Cancel deferred function.\r\n     * Returns `true` if it was not been canceled.\r\n     */\r\n    cancel() {\r\n        if (!this.id) {\r\n            return false;\r\n        }\r\n        clearTimeout(this.id);\r\n        this.id = null;\r\n        return true;\r\n    }\r\n}\r\nexports.Timeout = Timeout;\r\n/**\r\n * Just like `setTimeout`, call `fn` after `ms` millisecons.\r\n * @param fn The function to call later.\r\n * @param ms The timeout time in millisecons.\r\n * @returns A cancel function.\r\n */\r\nfunction timeout(fn, ms = 0) {\r\n    let t = new Timeout(fn, ms);\r\n    return t.cancel.bind(t);\r\n}\r\nexports.timeout = timeout;\r\nclass Interval extends TimingFunction {\r\n    constructor(fn, ms) {\r\n        super(fn, ms);\r\n        this.reset();\r\n    }\r\n    /** Restart interval, although it was canceled. */\r\n    reset() {\r\n        if (this.id) {\r\n            clearInterval(this.id);\r\n        }\r\n        this.id = setInterval(this.onInterval.bind(this), this.ms);\r\n        return true;\r\n    }\r\n    onInterval() {\r\n        this.fn();\r\n    }\r\n    /** Call interval function immediately if it wasn't canceled. returns whether it was not benn canceled. */\r\n    flush() {\r\n        if (!this.id) {\r\n            return false;\r\n        }\r\n        this.fn();\r\n        this.reset();\r\n        return true;\r\n    }\r\n    /**\r\n     * Cancel interval function.\r\n     * Returns `true` if it was not been canceled.\r\n     */\r\n    cancel() {\r\n        if (!this.id) {\r\n            return false;\r\n        }\r\n        clearInterval(this.id);\r\n        this.id = null;\r\n        return true;\r\n    }\r\n}\r\nexports.Interval = Interval;\r\n/**\r\n * Just like `setInterval`, call `fn` every `ms` millisecons.\r\n * @param fn The function to call.\r\n * @param ms The interval time in millisecons.\r\n * @returns A cancel function.\r\n */\r\nfunction interval(fn, ms) {\r\n    let i = new Interval(fn, ms);\r\n    return i.cancel.bind(i);\r\n}\r\nexports.interval = interval;\r\nclass Throttle extends WrappedTimingFunction {\r\n    wrap() {\r\n        let me = this;\r\n        return function (...args) {\r\n            if (me.canceled) {\r\n                me.fn.apply(this, args);\r\n                return;\r\n            }\r\n            if (!me.id) {\r\n                me.setThrottle();\r\n                me.fn.apply(this, args);\r\n            }\r\n        };\r\n    }\r\n    setThrottle() {\r\n        this.id = setTimeout(this.onTimeout.bind(this), this.ms);\r\n    }\r\n    onTimeout() {\r\n        this.id = null;\r\n    }\r\n    /** Reset throttle timeout, Will restart throttle timeout when next time calling `fn` and calls `fn` immediately. */\r\n    reset() {\r\n        if (this.id) {\r\n            this.clearThrottle();\r\n        }\r\n        this.canceled = false;\r\n        return true;\r\n    }\r\n    clearThrottle() {\r\n        clearTimeout(this.id);\r\n        this.id = null;\r\n    }\r\n    /** Call `fn` immediately and reset throttle timeout. */\r\n    flush() {\r\n        this.reset();\r\n        this.fn();\r\n        return true;\r\n    }\r\n    /**\r\n     * Cancel throttle, function will be called without limit.\r\n     * Returns `true` if is not canceled before.\r\n     */\r\n    cancel() {\r\n        if (this.canceled) {\r\n            return false;\r\n        }\r\n        this.canceled = true;\r\n        return true;\r\n    }\r\n}\r\nexports.Throttle = Throttle;\r\n/**\r\n * Throttle function calls, `fn` will not be called for twice in each `ms` millisecons\r\n * Note that it doesn't ensure the last calling.\r\n * @param fn The function to throttle.\r\n * @param ms The time period in which allows at most one calling.\r\n * @returns A wrapped function.\r\n */\r\nfunction throttle(fn, ms = 0) {\r\n    return new Throttle(fn, ms).wrapped;\r\n}\r\nexports.throttle = throttle;\r\nclass SmoothThrottle extends WrappedTimingFunction {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.lastArgs = null;\r\n        this.lastThis = null;\r\n    }\r\n    wrap() {\r\n        let me = this;\r\n        return function (...args) {\r\n            if (me.canceled) {\r\n                me.fn.apply(this, args);\r\n                return;\r\n            }\r\n            me.lastArgs = args;\r\n            me.lastThis = this;\r\n            if (!me.id) {\r\n                me.setThrottle();\r\n            }\r\n        };\r\n    }\r\n    setThrottle() {\r\n        this.id = setTimeout(this.onTimeout.bind(this), this.ms);\r\n    }\r\n    onTimeout() {\r\n        if (this.lastArgs) {\r\n            this.fn.apply(this.lastThis, this.lastArgs);\r\n            this.lastArgs = null;\r\n            this.lastThis = null;\r\n            this.setThrottle();\r\n        }\r\n        else {\r\n            this.id = null;\r\n        }\r\n    }\r\n    /** Reset throttle timeout and discard deferred calling, will restart throttle if been canceled. */\r\n    reset() {\r\n        if (this.id) {\r\n            this.clearThrottle();\r\n        }\r\n        this.lastArgs = null;\r\n        this.lastThis = null;\r\n        this.canceled = false;\r\n        return true;\r\n    }\r\n    /** Call function immediately if there is a deferred calling, and restart throttle timeout. */\r\n    flush() {\r\n        if (this.lastArgs) {\r\n            this.setThrottle();\r\n            this.fn.apply(this.lastThis, this.lastArgs);\r\n            this.lastArgs = null;\r\n            this.lastThis = null;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    clearThrottle() {\r\n        clearTimeout(this.id);\r\n        this.id = null;\r\n    }\r\n    /**\r\n     * Cancel throttle, function will be called without limit.\r\n     * Returns `true` if is not canceled before.\r\n     */\r\n    cancel() {\r\n        if (this.canceled) {\r\n            return false;\r\n        }\r\n        this.canceled = true;\r\n        return true;\r\n    }\r\n}\r\nexports.SmoothThrottle = SmoothThrottle;\r\n/**\r\n * Throttle function calls, `fn` will not be called for twice in each `ms` millisecons.\r\n * Different from `ff.throttle`, `fn` will be called lazily and smooth, and it ensures the last calling.\r\n * @param fn The function to throttle.\r\n * @param ms The time period which allows at most one calling.\r\n * @returns A wrapped function.\r\n */\r\nfunction smoothThrottle(fn, ms) {\r\n    return new SmoothThrottle(fn, ms).wrapped;\r\n}\r\nexports.smoothThrottle = smoothThrottle;\r\nclass Debounce extends WrappedTimingFunction {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.lastArgs = null;\r\n        this.lastThis = null;\r\n    }\r\n    wrap() {\r\n        let me = this;\r\n        return function (...args) {\r\n            if (me.canceled) {\r\n                me.fn.apply(this, args);\r\n                return;\r\n            }\r\n            if (me.id) {\r\n                clearTimeout(me.id);\r\n            }\r\n            me.id = setTimeout(me.onTimeout.bind(me), me.ms);\r\n            me.lastArgs = args;\r\n            me.lastThis = this;\r\n        };\r\n    }\r\n    onTimeout() {\r\n        this.id = null;\r\n        if (this.lastArgs) {\r\n            this.fn.apply(this.lastThis, this.lastArgs);\r\n            this.lastArgs = null;\r\n            this.lastThis = null;\r\n        }\r\n    }\r\n    /** Reset debounce timeout and discard deferred calling, will restart debounce if been canceled. */\r\n    reset() {\r\n        if (this.id) {\r\n            clearTimeout(this.id);\r\n            this.id = null;\r\n        }\r\n        this.lastArgs = null;\r\n        this.lastThis = null;\r\n        return true;\r\n    }\r\n    /** Call function immediately if there is a deferred calling, and restart debounce timeout. */\r\n    flush() {\r\n        if (this.id) {\r\n            clearTimeout(this.id);\r\n            this.id = 0;\r\n        }\r\n        if (this.lastArgs) {\r\n            this.fn.apply(this.lastThis, this.lastArgs);\r\n            this.lastArgs = null;\r\n            this.lastThis = null;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Cancel debounce, function will be called without limit.\r\n     * Returns `true` if is not canceled before.\r\n     */\r\n    cancel() {\r\n        if (this.canceled) {\r\n            return false;\r\n        }\r\n        this.canceled = true;\r\n        return true;\r\n    }\r\n}\r\nexports.Debounce = Debounce;\r\n/**\r\n * Debounce function calls, calls returned function continuously in a short time will pause calling `fn`.\r\n * It can be used to only send search request after user stops inputting.\r\n * @param fn The function to debounce.\r\n * @param ms The timeout in milliseconds.\r\n */\r\nfunction debounce(fn, ms) {\r\n    return new Debounce(fn, ms).wrapped;\r\n}\r\nexports.debounce = debounce;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nrequire(\"./es-polyfill\");\r\n__exportStar(require(\"./object\"), exports);\r\n__exportStar(require(\"./array\"), exports);\r\n__exportStar(require(\"./string\"), exports);\r\n__exportStar(require(\"./number\"), exports);\r\n__exportStar(require(\"./function\"), exports);\r\n__exportStar(require(\"./duration\"), exports);\r\n__exportStar(require(\"./date\"), exports);\r\n__exportStar(require(\"./time\"), exports);\r\n__exportStar(require(\"./emitter\"), exports);\r\n__exportStar(require(\"./queue\"), exports);\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.constrain = exports.mod = exports.toPrecision = exports.toPower = exports.toDecimal = void 0;\r\n/**\r\n * Like `number.toFixed`, but alway return a number. e.g., `toPower(12.345, 2) = 12.34`.\r\n * @param number The number to fix.\r\n * @param decimalCount The decimal count that `number` will correct to, default value is `0`.\r\n */\r\nfunction toDecimal(number, decimalCount = 0) {\r\n    return toPower(number, -decimalCount);\r\n}\r\nexports.toDecimal = toDecimal;\r\n/**\r\n * Like `number.toFixed`, but always returns a number. e.g., `toPower(1234, 2) = 1200`.\r\n * @param number The number to fix.\r\n * @param power The power that `number` will correct to, default value is `0`.\r\n */\r\nfunction toPower(number, power = 0) {\r\n    if (number < 0) {\r\n        return -toPower(-number, power);\r\n    }\r\n    if (number === 0) {\r\n        return 0;\r\n    }\r\n    if (power > 0) {\r\n        let n = Math.pow(10, power);\r\n        return Math.round(number / n) * n;\r\n    }\r\n    // This can avoid `0.1 + 0.2 !== 0.3`\r\n    else {\r\n        let n = Math.pow(10, -power);\r\n        return Math.round(number * n) / n;\r\n    }\r\n}\r\nexports.toPower = toPower;\r\n/**\r\n * Nearly same with `number.toPrecision`, except it always return a number.\r\n * @param number The number to transfer to specified precision.\r\n * @param precision The precision value betweens `1-21`, default value is `1`.\r\n */\r\nfunction toPrecision(number, precision = 1) {\r\n    return Number(number.toPrecision(precision));\r\n}\r\nexports.toPrecision = toPrecision;\r\n/**\r\n * Like `a % b`, but always returns positive number. e.g., `mod(-1, 2) = 1`.\r\n * @param number The number to calculate modulo.\r\n * @param modulo The modulo of number.\r\n */\r\nfunction mod(number, modulo) {\r\n    return (number % modulo + Math.abs(modulo)) % modulo;\r\n}\r\nexports.mod = mod;\r\n/**\r\n * Returns a new number which is constrained in a minimal and maximum range.\r\n * @param number The number to constrain.\r\n * @param min The minimum number.\r\n * @param max The maximum number.\r\n */\r\nfunction constrain(number, min, max) {\r\n    if (min > max) {\r\n        [min, max] = [max, min];\r\n    }\r\n    if (number < min) {\r\n        number = min;\r\n    }\r\n    else if (number > max) {\r\n        number = max;\r\n    }\r\n    return number;\r\n}\r\nexports.constrain = constrain;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.deepEqual = exports.deepClone = exports.assignIf = exports.assign = void 0;\r\n/**\r\n * Assign object keys and values from `source` to `target`, will cover values of `target` with same keys.\r\n * will ignore `undefined` values and their keys in `source`.\r\n * @param target The target that the sources assigned to.\r\n * @param sources The sources that will assigned to target by order.\r\n * @param keys If specified, only values whose keys are included will be assigned.\r\n */\r\nfunction assign(target, source, keys = Object.keys(source)) {\r\n    for (let key of keys) {\r\n        let value = source[key];\r\n        if (value !== undefined) {\r\n            target[key] = value;\r\n        }\r\n    }\r\n    return target;\r\n}\r\nexports.assign = assign;\r\n/**\r\n * Assign object keys and values from `source` to `target`, will not cover values of `target` with existing keys.\r\n * will ignore `undefined` values and their keys in `source`,  and `undefined` values in `target` will be treated as not exist.\r\n * @param target The target that the sources assigned to.\r\n * @param sources The sources that will assigned to target by order.\r\n * @param keys If specified, only values whose keys are included will be assigned.\r\n */\r\nfunction assignIf(target, source, keys = Object.keys(source)) {\r\n    for (let key of keys) {\r\n        let value = source[key];\r\n        if (value !== undefined && target[key] === undefined) {\r\n            target[key] = value;\r\n        }\r\n    }\r\n    return target;\r\n}\r\nexports.assignIf = assignIf;\r\n/**\r\n * Deeply clone an object, array or any value.\r\n * 2x~3x faster than JSON stringify and parse methods\r\n * @param source The source to clone.\r\n * @param deep Max deep to clone, default value is 10.\r\n */\r\nfunction deepClone(source, deep = 10) {\r\n    if (typeof source !== 'object' || !source || deep === 0) {\r\n        return source;\r\n    }\r\n    if (Array.isArray(source)) {\r\n        return source.map(value => {\r\n            if (typeof value !== 'object' || !value) {\r\n                return value;\r\n            }\r\n            else {\r\n                return deepClone(value, deep - 1);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        let cloned = {};\r\n        for (let key of Object.keys(source)) {\r\n            let value = source[key];\r\n            cloned[key] = deepClone(value, deep - 1);\r\n        }\r\n        return cloned;\r\n    }\r\n}\r\nexports.deepClone = deepClone;\r\n/**\r\n * Deeply compare two objects, arrays or any other values.\r\n * 1x faster than JSON stringify methods.\r\n * @param a Left value.\r\n * @param b Right value.\r\n * @param deep Max deep to compare, default value is 10.\r\n */\r\nfunction deepEqual(a, b, deep = 10) {\r\n    if (a === b) {\r\n        return true;\r\n    }\r\n    if (deep === 0) {\r\n        return false;\r\n    }\r\n    if (typeof a !== 'object' || typeof b !== 'object' || !a || !b) {\r\n        return false;\r\n    }\r\n    if (a.constructor !== b.constructor) {\r\n        return false;\r\n    }\r\n    if (Array.isArray(a) && Array.isArray(b)) {\r\n        if (a.length !== b.length) {\r\n            return false;\r\n        }\r\n        return a.every((ai, index) => {\r\n            return deepEqual(ai, b[index], deep - 1);\r\n        });\r\n    }\r\n    else {\r\n        let keysA = Object.keys(a);\r\n        let keysB = Object.keys(b);\r\n        if (keysA.length !== keysB.length) {\r\n            return false;\r\n        }\r\n        for (let key of keysA) {\r\n            if (!b.hasOwnProperty(key)) {\r\n                return false;\r\n            }\r\n            let valueA = a[key];\r\n            let valueB = b[key];\r\n            if (!deepEqual(valueA, valueB, deep - 1)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\nexports.deepEqual = deepEqual;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.queueEvery = exports.queueSome = exports.queueMap = exports.queueEach = exports.Queue = exports.QueueState = void 0;\r\nconst object_1 = require(\"./object\");\r\nconst emitter_1 = require(\"./emitter\");\r\n/** Running state of queue. */\r\nvar QueueState;\r\n(function (QueueState) {\r\n    /** Not started. */\r\n    QueueState[QueueState[\"Pending\"] = 0] = \"Pending\";\r\n    /** Any task is running. */\r\n    QueueState[QueueState[\"Running\"] = 1] = \"Running\";\r\n    /** Been paused. */\r\n    QueueState[QueueState[\"Paused\"] = 2] = \"Paused\";\r\n    /** Queued tasks finshed, may still have failed tasks. */\r\n    QueueState[QueueState[\"Finish\"] = 3] = \"Finish\";\r\n    /** Aborted because of error or by user. */\r\n    QueueState[QueueState[\"Aborted\"] = 4] = \"Aborted\";\r\n})(QueueState = exports.QueueState || (exports.QueueState = {}));\r\n/**\r\n * Class to queue tasks and transfer them to handler in specified concurrency.\r\n * @typeparam T: Type of task.\r\n * @typeparam V: Type of returned values from handler. This can be inferred from `handler` option normally.\r\n */\r\nclass Queue extends emitter_1.Emitter {\r\n    constructor(options) {\r\n        super();\r\n        /** If provided, can avoid adding duplicate tasks with same keys. */\r\n        this.key = null;\r\n        /** Specifies how many tasks to run simultaneously, default value is `5`. */\r\n        this.concurrency = 5;\r\n        /** If true, will continue processing tasks after error occurred. */\r\n        this.continueOnError = false;\r\n        /**\r\n         * Specifies how many times to retry before one task success.\r\n         * If one task's retry times execeed, it will never retry automatically,\r\n         * but you can still retry all failed tasks by calling `retry()` manually.\r\n         * Setting this option to values `> 0` implies `continueOnError` is `true`.\r\n         */\r\n        this.maxRetryTimes = 0;\r\n        /** The start task array which will be passed to `handler` in order. */\r\n        this.tasks = [];\r\n        /** Returns current working state. */\r\n        this.state = QueueState.Pending;\r\n        /** All keys found from tasks. */\r\n        this.keysFound = null;\r\n        /** To generate unique numeric id. */\r\n        this.seed = 1;\r\n        /** Count of processed tasks. */\r\n        this.processedCount = 0;\r\n        /** All running items. */\r\n        this.runningItems = [];\r\n        /** All failed items. */\r\n        this.failedItems = [];\r\n        /** Promise to be resolved after resume. */\r\n        this.resumePromise = null;\r\n        /** Resolve function for `resumePromise`. */\r\n        this.resumeResolve = null;\r\n        object_1.assign(this, options, Object.keys(options).filter(key => key !== 'tasks'));\r\n        if (this.key) {\r\n            this.keysFound = new Set();\r\n        }\r\n        if (options.tasks) {\r\n            this.push(...options.tasks);\r\n        }\r\n    }\r\n    /** Returns the tount of total tasks, included processed and unprocessed and failed. */\r\n    getTotalCount() {\r\n        return this.getProcessedCount() + this.getUnprocessedCount() + this.getFailedCount();\r\n    }\r\n    /** Returns the count of processed tasks. */\r\n    getProcessedCount() {\r\n        return this.processedCount;\r\n    }\r\n    /** Returns the count of unprocessed tasks, not include failed tasks. */\r\n    getUnprocessedCount() {\r\n        return this.tasks.length + this.getRunningCount();\r\n    }\r\n    /** Returns the count of running tasks. */\r\n    getRunningCount() {\r\n        return this.runningItems.length;\r\n    }\r\n    /** Returns the count of failed tasks. */\r\n    getFailedCount() {\r\n        return this.failedItems.length;\r\n    }\r\n    /** Returns the unprocessed tasks. */\r\n    getUnprocessedTasks() {\r\n        return [...this.getRunningTasks(), ...this.tasks];\r\n    }\r\n    /** Returns the running tasks. */\r\n    getRunningTasks() {\r\n        return this.runningItems.map(v => v.task);\r\n    }\r\n    /** Returns the failed tasks. */\r\n    getFailedTasks() {\r\n        return this.failedItems.map(v => v.task);\r\n    }\r\n    /**\r\n     * Start processing tasks. Will emit `finish` event in next tick if no task to run.\r\n     * Returns `true` if queue started.\r\n     */\r\n    start() {\r\n        if (this.state === QueueState.Paused) {\r\n            this.resume();\r\n        }\r\n        else if (this.tasks.length > 0) {\r\n            this.state = QueueState.Running;\r\n            this.tryHandleNextTask();\r\n        }\r\n        else {\r\n            Promise.resolve().then(() => this.onFinish());\r\n        }\r\n        return this.state === QueueState.Running;\r\n    }\r\n    /** Returns a promise which will be resolved after all tasks finished. */\r\n    untilFinish() {\r\n        if (this.getUnprocessedCount() > 0) {\r\n            return new Promise(resolve => {\r\n                this.once('finish', () => resolve());\r\n            });\r\n        }\r\n        else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n    /** Returns a promise which will be resolved after all tasks finished, or be rejected if error happens. */\r\n    untilEnd() {\r\n        if (this.getUnprocessedCount() > 0) {\r\n            return new Promise((resolve, reject) => {\r\n                this.once('end', err => err ? reject(err) : resolve());\r\n            });\r\n        }\r\n        else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n    /**\r\n     * Stop processing tasks, running tasks will not be aborted, but will be locked until `resume()`.\r\n     * Returns `true` if paused from running state.\r\n     */\r\n    pause() {\r\n        if (this.state !== QueueState.Running) {\r\n            return false;\r\n        }\r\n        this.state = QueueState.Paused;\r\n        this.resumePromise = new Promise(resolve => {\r\n            this.resumeResolve = () => {\r\n                this.resumeResolve = null;\r\n                this.resumePromise = null;\r\n                resolve();\r\n            };\r\n        });\r\n        this.emit('pause');\r\n        return true;\r\n    }\r\n    /**\r\n     * Resume processing tasks.\r\n     * Returns `true` if resumed from paused state.\r\n     */\r\n    resume() {\r\n        if (this.state !== QueueState.Paused) {\r\n            return false;\r\n        }\r\n        this.state = QueueState.Running;\r\n        if (this.resumeResolve) {\r\n            this.resumeResolve();\r\n        }\r\n        this.emit('resume');\r\n        this.tryHandleNextTask();\r\n        return true;\r\n    }\r\n    tryHandleNextTask() {\r\n        // State may change after in event handler, so we need to test state here.\r\n        if (this.state !== QueueState.Running) {\r\n            return;\r\n        }\r\n        while (this.getRunningCount() < this.concurrency && this.tasks.length > 0) {\r\n            let task = this.tasks.shift();\r\n            this.handleEachItem({\r\n                id: this.seed++,\r\n                task,\r\n                retriedTimes: 0,\r\n                abort: null\r\n            });\r\n        }\r\n        if (this.maxRetryTimes > 0 && this.getRunningCount() < this.concurrency && this.failedItems.length) {\r\n            for (let i = 0; i < this.failedItems.length; i++) {\r\n                let item = this.failedItems[i];\r\n                if (item.retriedTimes < this.maxRetryTimes) {\r\n                    item.retriedTimes++;\r\n                    this.failedItems.splice(i--, 1);\r\n                    this.handleEachItem(item);\r\n                    if (this.getRunningCount() >= this.concurrency) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (this.getRunningCount() === 0) {\r\n            this.onFinish();\r\n        }\r\n    }\r\n    handleEachItem(item) {\r\n        let { task } = item;\r\n        let onItemFinish = this.onItemFinish.bind(this, item);\r\n        let onItemError = this.onItemError.bind(this, item);\r\n        let value = this.handler(task);\r\n        this.runningItems.push(item);\r\n        if (this.isPromiseAbortObject(value)) {\r\n            value.promise.then(onItemFinish, onItemError);\r\n            item.abort = value.abort;\r\n        }\r\n        else if (value instanceof Promise) {\r\n            value.then(onItemFinish, onItemError);\r\n        }\r\n        else {\r\n            Promise.resolve().then(() => onItemFinish(value));\r\n        }\r\n    }\r\n    isPromiseAbortObject(value) {\r\n        return value\r\n            && typeof value === 'object'\r\n            && value.promise instanceof Promise\r\n            && typeof value.abort === 'function';\r\n    }\r\n    async onItemFinish(item, value) {\r\n        await this.prepareItem(item);\r\n        if (!this.removeFromRunningItems(item)) {\r\n            return;\r\n        }\r\n        this.processedCount++;\r\n        if (this.state === QueueState.Running) {\r\n            this.emit('taskfinish', item.task, value);\r\n            this.tryHandleNextTask();\r\n        }\r\n    }\r\n    async onItemError(item, err) {\r\n        await this.prepareItem(item);\r\n        if (!this.removeFromRunningItems(item)) {\r\n            return;\r\n        }\r\n        this.failedItems.push(item);\r\n        this.emit('error', item.task, err);\r\n        if (!this.continueOnError && this.maxRetryTimes === 0) {\r\n            this.onFatalError(err);\r\n        }\r\n        else {\r\n            this.tryHandleNextTask();\r\n        }\r\n    }\r\n    /** Prepare and ensure all loading for item is completed. */\r\n    async prepareItem(item) {\r\n        item.abort = null;\r\n        if (this.resumePromise) {\r\n            await this.resumePromise;\r\n        }\r\n    }\r\n    removeFromRunningItems(item) {\r\n        let index = this.runningItems.findIndex(v => v.id === item.id);\r\n        if (index > -1) {\r\n            this.runningItems.splice(index, 1);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    onFinish() {\r\n        if (this.state === QueueState.Pending || this.state === QueueState.Running) {\r\n            this.state = QueueState.Finish;\r\n            this.emit('finish');\r\n            this.emit('end', null);\r\n        }\r\n    }\r\n    onFatalError(err) {\r\n        this.abort(err);\r\n    }\r\n    /**\r\n     * Retry all failed tasks immediately, ignore their retried times.\r\n     * Returns `true` if has failed tasks and queued them.\r\n     */\r\n    retry() {\r\n        let hasFailedTasks = this.getFailedCount() > 0;\r\n        if (hasFailedTasks) {\r\n            this.tasks.push(...this.getFailedTasks());\r\n            this.failedItems = [];\r\n        }\r\n        let started = this.start();\r\n        return started && hasFailedTasks;\r\n    }\r\n    /**\r\n     * Abort current queue and all running tasks.\r\n     * After aborted, queue can still be started manually by calling `start()`.\r\n     * Returns `true` if queue was successfully aborted.\r\n     */\r\n    abort(err = 'Manually') {\r\n        if (!(this.state === QueueState.Running || this.state === QueueState.Paused)) {\r\n            return false;\r\n        }\r\n        this.state = QueueState.Aborted;\r\n        this.failedItems.push(...this.runningItems);\r\n        this.abortRunningItems();\r\n        this.emit('abort', err);\r\n        this.emit('end', err);\r\n        return true;\r\n    }\r\n    abortRunningItems() {\r\n        this.runningItems.map(item => this.abortItem(item));\r\n        this.runningItems = [];\r\n    }\r\n    abortItem(item) {\r\n        let { task, abort } = item;\r\n        if (abort) {\r\n            abort();\r\n        }\r\n        this.emit('taskabort', task);\r\n    }\r\n    /**\r\n     * End and finish queue, abort all running tasks and clear all tasks and processing records.\r\n     * Returns `true` if queue was cleared successfully.\r\n     */\r\n    clear() {\r\n        if (this.state === QueueState.Aborted) {\r\n            return false;\r\n        }\r\n        this.state = QueueState.Finish;\r\n        this.tasks = [];\r\n        this.failedItems = [];\r\n        this.processedCount = 0;\r\n        this.abortRunningItems();\r\n        this.emit('finish');\r\n        this.emit('end', null);\r\n        if (this.resumeResolve) {\r\n            this.resumeResolve();\r\n        }\r\n        return true;\r\n    }\r\n    /** Remove all not running tasks and keeps not running tasks and processing records. */\r\n    clearNotRunning() {\r\n        this.tasks = [];\r\n        this.failedItems = [];\r\n        this.processedCount = 0;\r\n    }\r\n    /** Push tasks to queue. */\r\n    push(...tasks) {\r\n        if (this.keysFound) {\r\n            for (let task of tasks) {\r\n                this.keysFound.add(task[this.key]);\r\n            }\r\n        }\r\n        this.tasks.push(...tasks);\r\n        this.tryHandleNextTask();\r\n    }\r\n    /** Unshift tasks to queue. */\r\n    unshift(...tasks) {\r\n        if (this.keysFound) {\r\n            for (let task of tasks) {\r\n                this.keysFound.add(task[this.key]);\r\n            }\r\n        }\r\n        this.tasks.unshift(...tasks);\r\n        this.tryHandleNextTask();\r\n    }\r\n    /**\r\n     * Returns true if found same key task.\r\n     * Only available when `key` specified.\r\n     */\r\n    has(task) {\r\n        if (this.keysFound) {\r\n            return this.keysFound.has(task[this.key]);\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Push each task to queue, if not found duplicate task with same key.\r\n     * Only available when `key` specified.\r\n     */\r\n    add(...tasks) {\r\n        tasks = tasks.filter(t => !this.has(t));\r\n        if (tasks.length > 0) {\r\n            this.push(...tasks);\r\n        }\r\n    }\r\n    /**\r\n     * Unshift each task to queue, if not found duplicate task with same key.\r\n     * Only available when `key` specified.\r\n     */\r\n    addToStart(...tasks) {\r\n        tasks = tasks.filter(t => !this.has(t));\r\n        if (tasks.length > 0) {\r\n            this.unshift(...tasks);\r\n        }\r\n    }\r\n    /**\r\n     * Find first task match test function `fn`.\r\n     * Processed tasks will not be found.\r\n     */\r\n    find(fn) {\r\n        let item = this.runningItems.find(item => fn(item.task));\r\n        if (item) {\r\n            return item.task;\r\n        }\r\n        item = this.failedItems.find(item => fn(item.task));\r\n        if (item) {\r\n            return item.task;\r\n        }\r\n        let task = this.tasks.find(task => fn(task));\r\n        if (task) {\r\n            return task;\r\n        }\r\n        return undefined;\r\n    }\r\n    /**\r\n     * Removes tasks included in `tasksToRemove` list.\r\n     * Processed tasks will not be removed.\r\n     * Returns the removed tasks.\r\n     */\r\n    remove(...tasksToRemove) {\r\n        let taskSet = new Set(tasksToRemove);\r\n        return this.removeWhere(task => taskSet.has(task));\r\n    }\r\n    /**\r\n     * Removes all tasks that match test function `fn`.\r\n     * Processed tasks will not be removed.\r\n     * Returns the removed tasks.\r\n     */\r\n    removeWhere(fn) {\r\n        let toRemove = [];\r\n        this.runningItems = this.runningItems.filter(item => {\r\n            if (fn(item.task)) {\r\n                toRemove.push(item.task);\r\n                return false;\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        });\r\n        this.failedItems = this.failedItems.filter(item => {\r\n            if (fn(item.task)) {\r\n                toRemove.push(item.task);\r\n                return false;\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        });\r\n        this.tasks = this.tasks.filter(task => {\r\n            if (fn(task)) {\r\n                toRemove.push(task);\r\n                return false;\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        });\r\n        this.tryHandleNextTask();\r\n        return toRemove;\r\n    }\r\n}\r\nexports.Queue = Queue;\r\n/**\r\n * Run eash task of `tasks` in a queue.\r\n * Returns a promise which will be resolved after queue finished.\r\n * @param tasks The task array which will be passed to handler in order.\r\n * @param handler The handler to handle each task.\r\n * @param concurrency Specifies how many tasks to run simultaneously.\r\n */\r\nfunction queueEach(tasks, handler, concurrency) {\r\n    return new Promise((resolve, reject) => {\r\n        let q = new Queue({\r\n            concurrency,\r\n            tasks,\r\n            handler\r\n        });\r\n        q.on('finish', resolve);\r\n        q.on('error', reject);\r\n        q.start();\r\n    });\r\n}\r\nexports.queueEach = queueEach;\r\n/**\r\n * Run eash task of `tasks` in a queue.\r\n * Returns a promise which will be resolved with returned values from `handler` after queue finished.\r\n * @param tasks The task array which will be passed to handler in order.\r\n * @param handler The handler to handle each task. It should returns a value.\r\n * @param concurrency Specifies how many tasks to run simultaneously.\r\n */\r\nfunction queueMap(tasks, handler, concurrency) {\r\n    return new Promise((resolve, reject) => {\r\n        let values = [];\r\n        let indexedTasks = tasks.map((task, index) => ({ task, index }));\r\n        let q = new Queue({\r\n            concurrency,\r\n            tasks: indexedTasks,\r\n            handler: async ({ task, index }) => {\r\n                values[index] = await handler(task);\r\n            }\r\n        });\r\n        q.on('finish', () => resolve(values));\r\n        q.on('error', reject);\r\n        q.start();\r\n    });\r\n}\r\nexports.queueMap = queueMap;\r\n/**\r\n * Run eash task of `tasks` in a queue.\r\n * Returns a promise which will be resolved if some tasks match `handler`.\r\n * @param tasks The task array which will be passed to handler in order.\r\n * @param handler The handler to handle each task. It should returns a boolean value.\r\n * @param concurrency Specifies how many tasks to run simultaneously.\r\n */\r\nfunction queueSome(tasks, handler, concurrency) {\r\n    return new Promise((resolve, reject) => {\r\n        let q = new Queue({\r\n            concurrency,\r\n            tasks,\r\n            handler\r\n        });\r\n        q.on('taskfinish', (_task, value) => {\r\n            if (value) {\r\n                resolve(true);\r\n                q.clear();\r\n            }\r\n        });\r\n        q.on('finish', () => resolve(false));\r\n        q.on('error', reject);\r\n        q.start();\r\n    });\r\n}\r\nexports.queueSome = queueSome;\r\n/**\r\n * Run eash task of `tasks` in a queue.\r\n * Returns a promise which will be resolved if every tasks match `handler`.\r\n * @param tasks The task array which will be passed to handler in order.\r\n * @param handler The handler to handle each task. It should returns a boolean value.\r\n * @param concurrency Specifies how many tasks to run simultaneously.\r\n */\r\nfunction queueEvery(tasks, handler, concurrency) {\r\n    return queueSome(tasks, async (task) => !(await handler(task)), concurrency).then(value => !value);\r\n}\r\nexports.queueEvery = queueEvery;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.toUnderscoreCase = exports.toDashCase = exports.toCamerCase = exports.capitalize = exports.afterLast = exports.beforeLast = exports.after = exports.before = exports.format = exports.subMatches = exports.subMatchesAt = exports.firstMatches = exports.firstMatch = exports.subMatchAt = exports.selectAll = exports.select = void 0;\r\n/** Replace `$0` to `matches[0]`, `$1` to `matches[1]`... */\r\nfunction replaceMatchTags(template, match) {\r\n    return template.replace(/\\$(?:([$&\\d])|<(\\w+)>)/g, (_m0, m1, m2) => {\r\n        if (m2) {\r\n            return match.groups ? match.groups[m2] || '' : '';\r\n        }\r\n        else if (m1 === '$') {\r\n            return '$';\r\n        }\r\n        else if (m1 === '&') {\r\n            return match[0];\r\n        }\r\n        else {\r\n            return typeof match[m1] === 'string' ? match[m1] : '';\r\n        }\r\n    });\r\n}\r\n/**\r\n * Select sub matches from `string` by matching `re`, then format with a `template` string.\r\n * Returns the format result.\r\n * @param string The string to select sub matches.\r\n * @param re The RegExp to execute on string.\r\n * @param template Replace `$i` or `$<name>` to corresponding match.\r\n */\r\nfunction select(string, re, template) {\r\n    let match = re.exec(string);\r\n    return match ? replaceMatchTags(template, match) : '';\r\n}\r\nexports.select = select;\r\n/**\r\n * Select all the sub matches from `string` by matching `re`, then format with a `template` string.\r\n * @param string The string to select sub matches.\r\n * @param re The RegExp to execute on string.\r\n * @param template Replace `$i` or `$<name>` to corresponding match.\r\n */\r\nfunction selectAll(string, re, template) {\r\n    if (re.global) {\r\n        let match;\r\n        let matches = [];\r\n        while (match = re.exec(string)) {\r\n            matches.push(replaceMatchTags(template, match));\r\n        }\r\n        return matches;\r\n    }\r\n    else {\r\n        let match = string.match(re);\r\n        if (match) {\r\n            return [replaceMatchTags(template, match)];\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n    }\r\n}\r\nexports.selectAll = selectAll;\r\n/**\r\n * Returns the sub match in specified `index` from executing `re` on `string`.\r\n * @param string The string to select sub match.\r\n * @param re The RegExp to execute on string.\r\n * @param index Select the sub match in the index from match resul.\r\n */\r\nfunction subMatchAt(string, re, index) {\r\n    var _a;\r\n    return ((_a = re.exec(string)) === null || _a === void 0 ? void 0 : _a[index]) || '';\r\n}\r\nexports.subMatchAt = subMatchAt;\r\n/**\r\n * Returns the first sub match from executing `re` on `string`.\r\n * @param string The string to select sub match.\r\n * @param re The RegExp to execute on string.\r\n */\r\nfunction firstMatch(string, re) {\r\n    return subMatchAt(string, re, 1);\r\n}\r\nexports.firstMatch = firstMatch;\r\n/**\r\n * Returns the array of first sub matches from executing `re` on `string`.\r\n * @param string The string to select sub match.\r\n * @param re The RegExp to execute on string.\r\n */\r\nfunction firstMatches(string, re) {\r\n    return subMatchesAt(string, re, 1);\r\n}\r\nexports.firstMatches = firstMatches;\r\n/**\r\n * For each match result from executing `re` on `string`, picks specified `index` of sub matches.\r\n * Rreturns array of picked items.\r\n * @param string The string to select sub match.\r\n * @param re The RegExp to execute on string.\r\n * @param index Select the sub match in the index from each match result.\r\n */\r\nfunction subMatchesAt(string, re, index) {\r\n    if (re.global) {\r\n        let match;\r\n        let matches = [];\r\n        while (match = re.exec(string)) {\r\n            matches.push(match[index] || '');\r\n        }\r\n        return matches;\r\n    }\r\n    else {\r\n        let match = string.match(re);\r\n        if (match) {\r\n            return [match[index] || ''];\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n    }\r\n}\r\nexports.subMatchesAt = subMatchesAt;\r\n/**\r\n * Returns array of all the sub matches from executing `re` on `string`.\r\n * @param string The string to select sub matches.\r\n * @param re The RegExp to execute on string.\r\n * @param sliceIndex Slice each match result from, specify to `0` to include whole match, `1` to only include sub matches, default value is `1`.\r\n */\r\nfunction subMatches(string, re, sliceIndex = 1) {\r\n    if (re.global) {\r\n        let match;\r\n        let matches = [];\r\n        while (match = re.exec(string)) {\r\n            matches.push([...match].slice(sliceIndex));\r\n        }\r\n        return matches;\r\n    }\r\n    else {\r\n        let match = string.match(re);\r\n        if (match) {\r\n            return [[...match].slice(sliceIndex)];\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n    }\r\n}\r\nexports.subMatches = subMatches;\r\n/**\r\n * Format string to replace placeholders like `{key}` in `template` to `args[key]`.\r\n * Will keep the placeholder when no match found.\r\n * @param template String to format.\r\n * @param args The parameters to find and replace `{...}` with.\r\n */\r\nfunction format(template, args) {\r\n    return template.replace(/\\{(\\w+)\\}/g, (m0, m1) => {\r\n        let value = args[m1];\r\n        if (value === undefined) {\r\n            value = m0;\r\n        }\r\n        return value;\r\n    });\r\n}\r\nexports.format = format;\r\n/**\r\n * Get the left part of `string` before the first matched `substring`.\r\n * @param string The string to search substring.\r\n * @param substring The sub part to search in string.\r\n * @param greedy If `true`, when substring can't be found, returns the whole string.\r\n */\r\nfunction before(string, substring, greedy = false) {\r\n    let index = string.indexOf(substring);\r\n    if (index < 0) {\r\n        return greedy ? string : '';\r\n    }\r\n    else {\r\n        return string.slice(0, index);\r\n    }\r\n}\r\nexports.before = before;\r\n/**\r\n * Get the right part of `string` before the first matched `substring`.\r\n * @param string The string to search substring.\r\n * @param substring The sub part to search in string.\r\n * @param greedy If `true`, when substring can't be found, returns the whole string.\r\n */\r\nfunction after(string, substring, greedy = false) {\r\n    let index = string.indexOf(substring);\r\n    if (index < 0) {\r\n        return greedy ? string : '';\r\n    }\r\n    else {\r\n        return string.slice(index + substring.length);\r\n    }\r\n}\r\nexports.after = after;\r\n/**\r\n * Get the left part of `string` before the last matched `substring`.\r\n * @param string The string to search substring.\r\n * @param substring The sub part to search in string.\r\n * @param greedy If `true`, when substring can't be found, returns the whole string.\r\n */\r\nfunction beforeLast(string, substring, greedy = false) {\r\n    let index = string.lastIndexOf(substring);\r\n    if (index < 0) {\r\n        return greedy ? string : '';\r\n    }\r\n    else {\r\n        return string.slice(0, index);\r\n    }\r\n}\r\nexports.beforeLast = beforeLast;\r\n/**\r\n * Get the right part of `string` before the last matched `substring`.\r\n * @param string The string to search substring.\r\n * @param substring The sub part to search in string.\r\n * @param greedy If `true`, when substring can't be found, returns the whole string.\r\n */\r\nfunction afterLast(string, substring, greedy = false) {\r\n    let index = string.lastIndexOf(substring);\r\n    if (index < 0) {\r\n        return greedy ? string : '';\r\n    }\r\n    else {\r\n        return string.slice(index + 1);\r\n    }\r\n}\r\nexports.afterLast = afterLast;\r\n/**\r\n * Uppercase the first character of `string`.\r\n * @param string The string to be capitalized.\r\n */\r\nfunction capitalize(string) {\r\n    return string.slice(0, 1).toUpperCase() + string.slice(1).toLowerCase();\r\n}\r\nexports.capitalize = capitalize;\r\n/**\r\n * Transform `string` to camer case type.\r\n * @param string The string to transform.\r\n */\r\nfunction toCamerCase(string) {\r\n    return string.replace(/[-_ ][a-z]/gi, m0 => m0[1].toUpperCase());\r\n}\r\nexports.toCamerCase = toCamerCase;\r\n/**\r\n * Transform `string` to dash case type by joining words with `-`.\r\n * @param string The string to transform.\r\n */\r\nfunction toDashCase(string) {\r\n    return string.replace(/(^|.)([A-Z]+)/g, (m0, charBefore, upperChars) => {\r\n        if (charBefore && /[a-z ]/i.test(charBefore)) {\r\n            return charBefore + '-' + upperChars.toLowerCase();\r\n        }\r\n        else {\r\n            return m0.toLowerCase();\r\n        }\r\n    })\r\n        .replace(/_/g, '-');\r\n}\r\nexports.toDashCase = toDashCase;\r\n/**\r\n * Transform `string` to dash case by joining words with `_`.\r\n * @param string The string to transform.\r\n */\r\nfunction toUnderscoreCase(string) {\r\n    return toDashCase(string).replace(/-/g, '_');\r\n}\r\nexports.toUnderscoreCase = toUnderscoreCase;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.sleep = void 0;\r\n/**\r\n * Returns a promise which will be resolved after `ms` milliseconds.\r\n * @param ms The sleep time in milliseconds.\r\n */\r\nfunction sleep(ms = 0) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\nexports.sleep = sleep;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.alignToEvent = exports.getMainAlignDirection = exports.Aligner = exports.align = void 0;\r\nconst style_1 = require(\"./style\");\r\nconst element_1 = require(\"./element\");\r\n/**\r\n * Align `el` to `target` element by specified position.\r\n * If no enough space, will adjust align position automatically.\r\n * Note that this mathod will always cause reflow.\r\n * @param el The element to align, it's position should be fixed or absolute.\r\n * @param target The target element to align to.\r\n * @param alignPosition Align Where of `el` to where of the `target`, e.g., `tl-br` means align top-left position of `el` to bottom-right of `target`.\r\n * @param options Additional options.\r\n */\r\nfunction align(el, target, alignPosition, options = {}) {\r\n    new Aligner(el, target, alignPosition, options).align();\r\n}\r\nexports.align = align;\r\nclass Aligner {\r\n    constructor(el, target, position, options = {}) {\r\n        var _a, _b, _c, _d;\r\n        this.el = el;\r\n        this.target = target;\r\n        this.triangle = options.triangle || null;\r\n        this.stickToEdges = (_a = options.stickToEdges) !== null && _a !== void 0 ? _a : true;\r\n        this.canSwapPosition = (_b = options.canSwapPosition) !== null && _b !== void 0 ? _b : true;\r\n        this.canShrinkInY = (_c = options.canShrinkInY) !== null && _c !== void 0 ? _c : false;\r\n        this.fixTriangle = (_d = options.fixTriangle) !== null && _d !== void 0 ? _d : false;\r\n        // Restore triangle transform.\r\n        if (this.triangle) {\r\n            this.triangle.style.transform = '';\r\n        }\r\n        // Still passed parameters although it's in current project,\r\n        // So we can avoid calling order confuse us.\r\n        this.alignPosition = parseAlignPosition(position);\r\n        this.margins = this.parseMargin(options.margin || 0);\r\n        // If target not affected by document scrolling, el should be same.\r\n        // A potential problem here: once becomes fixed, can't be restored for reuseable popups.\r\n        if (getClosestFixedElement(this.target)) {\r\n            this.el.style.position = 'fixed';\r\n            this.isElInFixedPosition = true;\r\n        }\r\n        else {\r\n            this.isElInFixedPosition = getComputedStyle(this.el).position === 'fixed';\r\n        }\r\n    }\r\n    /**\r\n     * top [right] [bottom] [left] -> [t, r, b, l].\r\n     * If align to a top position of target, unique number will be parsed as 0 in left and right position.\r\n     */\r\n    parseMargin(marginOption) {\r\n        var _a, _b, _c;\r\n        let margins = { top: 0, right: 0, bottom: 0, left: 0 };\r\n        if (typeof marginOption === 'number') {\r\n            margins.top = marginOption;\r\n            margins.right = marginOption;\r\n            margins.bottom = marginOption;\r\n            margins.left = marginOption;\r\n        }\r\n        else {\r\n            margins.top = marginOption[0];\r\n            margins.right = (_a = marginOption[1]) !== null && _a !== void 0 ? _a : margins.top;\r\n            margins.bottom = (_b = marginOption[2]) !== null && _b !== void 0 ? _b : margins.top;\r\n            margins.left = (_c = marginOption[3]) !== null && _c !== void 0 ? _c : margins.right;\r\n        }\r\n        if (this.triangle) {\r\n            margins.top += this.triangle.offsetHeight;\r\n            margins.bottom += this.triangle.offsetHeight;\r\n            margins.right += this.triangle.offsetWidth;\r\n            margins.left += this.triangle.offsetWidth;\r\n        }\r\n        return margins;\r\n    }\r\n    /**\r\n     * Align `el` to beside `target` element.\r\n     * Returns whether does alignment.\r\n     */\r\n    align() {\r\n        let directions = this.parseDirections();\r\n        let targetRect = element_1.getRect(this.target);\r\n        if (!isRectVisible(targetRect)) {\r\n            return false;\r\n        }\r\n        this.clearLastAlignment();\r\n        let rect = element_1.getRect(this.el);\r\n        let triangleRect = this.triangle ? element_1.getRect(this.triangle) : null;\r\n        let targetInViewport = isRectIntersectWithViewport(targetRect);\r\n        let willAlign = targetInViewport || !this.stickToEdges;\r\n        if (!willAlign) {\r\n            return false;\r\n        }\r\n        // If can shrink in y axis, try remove the height limitation and extend to natural height.\r\n        if (this.canShrinkInY) {\r\n            rect.height = this.getNaturalHeight(rect, triangleRect);\r\n        }\r\n        // If overflow in x axis, rect may change after position adjusted.\r\n        let isOverflowHerizontalEdges = rect.left <= 0 || rect.right >= document.documentElement.clientWidth;\r\n        // Do el alignment.\r\n        let position = this.doAlignment(directions, rect, targetRect, triangleRect);\r\n        // Re-align el if element size changed.\r\n        if (isOverflowHerizontalEdges) {\r\n            let newRect = element_1.getRect(this.el);\r\n            if (newRect.width !== rect.width || newRect.height !== rect.height) {\r\n                // These two rects must be replaced both or neither.\r\n                rect = newRect;\r\n                triangleRect = this.triangle ? element_1.getRect(this.triangle) : null;\r\n                position = this.doAlignment(directions, newRect, targetRect, triangleRect);\r\n            }\r\n        }\r\n        // Handle triangle position.\r\n        if (this.triangle) {\r\n            this.alignTriangle(position, directions, rect, targetRect, triangleRect);\r\n        }\r\n        return true;\r\n    }\r\n    /** Clear last alignment properties. */\r\n    clearLastAlignment() {\r\n        // Must reset, or el may be shrink into a small corner.\r\n        this.el.style.left = '0';\r\n        this.el.style.top = '0';\r\n        // `align` may be called for multiple times, so need to clear again.\r\n        if (this.triangle) {\r\n            this.triangle.style.transform = '';\r\n        }\r\n    }\r\n    /** Parse align direction to indicate which direction will align to. */\r\n    parseDirections() {\r\n        let alignPosition = this.alignPosition;\r\n        return {\r\n            top: alignPosition[0].includes('b') && alignPosition[1].includes('t'),\r\n            right: alignPosition[0].includes('l') && alignPosition[1].includes('r'),\r\n            bottom: alignPosition[0].includes('t') && alignPosition[1].includes('b'),\r\n            left: alignPosition[0].includes('r') && alignPosition[1].includes('l'),\r\n        };\r\n    }\r\n    /**\r\n     * When el can be scrolled, if we just expend it to test its natural height, it's scrolled position will lost.\r\n     * So we get `scrollHeight - clientHeight` as a diff and add it to it's current height as it's natural height.\r\n     * Note that the `triangle` will cause `scrollHeight` plus for it's height.\r\n     * Otherwise may not el but child is scrolled.\r\n     */\r\n    getNaturalHeight(rect, triangleRect) {\r\n        let h = rect.height;\r\n        let diffHeight = this.el.scrollHeight - this.el.clientHeight;\r\n        let maxAllowdDiffWhenNotScrolled = (triangleRect === null || triangleRect === void 0 ? void 0 : triangleRect.height) || 0;\r\n        if (diffHeight <= maxAllowdDiffWhenNotScrolled) {\r\n            diffHeight = Math.max(...[...this.el.children].map(child => child.scrollHeight - child.clientHeight));\r\n        }\r\n        if (diffHeight > 0) {\r\n            h = h + diffHeight;\r\n        }\r\n        else {\r\n            this.el.style.height = '';\r\n            h = this.el.offsetHeight;\r\n        }\r\n        return h;\r\n    }\r\n    /** Do alignment from `el` to `target` for once. */\r\n    doAlignment(directions, rect, targetRect, triangleRect) {\r\n        let anchor1 = this.getElRelativeAnchor(directions, rect, triangleRect);\r\n        let anchor2 = this.getTargetAbsoluteAnchor(targetRect);\r\n        // Fixed position coordinate.\r\n        let position = {\r\n            x: anchor2[0] - anchor1[0],\r\n            y: anchor2[1] - anchor1[1],\r\n        };\r\n        // Handle vertical alignment.\r\n        let overflowYSet = this.alignVertical(position, directions, rect, targetRect, triangleRect);\r\n        // Reset el height.\r\n        if (overflowYSet) {\r\n            rect = element_1.getRect(this.el);\r\n            anchor1 = this.getElRelativeAnchor(directions, rect, triangleRect);\r\n        }\r\n        // Handle herizontal alignment.\r\n        this.alignHerizontal(position, directions, rect, targetRect, triangleRect);\r\n        // Position for fixed or absolute layout.\r\n        let mayAbsolutePosition = { ...position };\r\n        // If is not fixed, minus coordinates relative to offsetParent.\r\n        if (!this.isElInFixedPosition && this.target !== document.body && this.target !== document.documentElement) {\r\n            var offsetParent = this.el.offsetParent;\r\n            // If we use body's top postion, it will cause a bug when body has a margin top (even from margin collapse).\r\n            if (offsetParent) {\r\n                var parentRect = offsetParent.getBoundingClientRect();\r\n                mayAbsolutePosition.x -= parentRect.left;\r\n                mayAbsolutePosition.y -= parentRect.top;\r\n            }\r\n        }\r\n        this.el.style.left = mayAbsolutePosition.x + 'px';\r\n        this.el.style.top = mayAbsolutePosition.y + 'px';\r\n        return position;\r\n    }\r\n    /** Get relative anchor position of the axis of an element. */\r\n    getElRelativeAnchor(directions, rect, triangleRect) {\r\n        let anchor = this.alignPosition[0];\r\n        let x = anchor.includes('l') ? 0 : anchor.includes('r') ? rect.width : rect.width / 2;\r\n        let y = anchor.includes('t') ? 0 : anchor.includes('b') ? rect.height : rect.height / 2;\r\n        // Anchor at triangle position.\r\n        if (this.fixTriangle && triangleRect) {\r\n            if ((directions.top || directions.bottom) && this.alignPosition[1][1] === 'c') {\r\n                x = triangleRect.left + triangleRect.width / 2 - rect.left;\r\n            }\r\n            else if ((directions.left || directions.right) && this.alignPosition[1][0] === 'c') {\r\n                y = triangleRect.top + triangleRect.height / 2 - rect.top;\r\n            }\r\n        }\r\n        return [x, y];\r\n    }\r\n    /** Get absolute anchor position in scrolling page. */\r\n    getTargetAbsoluteAnchor(targetRect) {\r\n        let anchor = this.alignPosition[1];\r\n        let x = anchor.includes('l')\r\n            ? targetRect.left - this.margins.left\r\n            : anchor.includes('r')\r\n                ? targetRect.right + this.margins.right\r\n                : targetRect.left + targetRect.width / 2;\r\n        let y = anchor.includes('t')\r\n            ? targetRect.top - this.margins.top\r\n            : anchor.includes('b')\r\n                ? targetRect.bottom + this.margins.bottom\r\n                : targetRect.top + targetRect.height / 2;\r\n        return [x, y];\r\n    }\r\n    /** Do vertical alignment. */\r\n    alignVertical(position, directions, rect, targetRect, triangleRect) {\r\n        let dh = document.documentElement.clientHeight;\r\n        let spaceTop = targetRect.top - this.margins.top;\r\n        let spaceBottom = dh - (targetRect.bottom + this.margins.bottom);\r\n        let overflowYSet = false;\r\n        let h = rect.height;\r\n        let y = position.y;\r\n        if (directions.top || directions.bottom) {\r\n            // Not enough space in top position, may switch to bottom.\r\n            if (directions.top && y < 0 && spaceTop < spaceBottom && this.canSwapPosition) {\r\n                y = targetRect.bottom + this.margins.bottom;\r\n                directions.top = false;\r\n                directions.bottom = true;\r\n            }\r\n            // Not enough space in bottom position, may switch to bottom.\r\n            else if (y + h > dh && spaceTop > spaceBottom && this.canSwapPosition) {\r\n                y = targetRect.top - this.margins.top - h;\r\n                directions.top = true;\r\n                directions.bottom = false;\r\n            }\r\n        }\r\n        else {\r\n            // Can move up a little to become fully visible.\r\n            if (y + h > dh && this.stickToEdges) {\r\n                // Gives enough space for triangle.\r\n                let minY = targetRect.top + (triangleRect ? triangleRect.height : 0) - h;\r\n                y = Math.max(dh - h, minY);\r\n            }\r\n            // Can move down a little to become fully visible.\r\n            if (y < 0 && this.stickToEdges) {\r\n                // Gives enough space for triangle.\r\n                let maxY = targetRect.bottom - (triangleRect ? triangleRect.height : 0);\r\n                y = Math.min(0, maxY);\r\n            }\r\n        }\r\n        if (this.canShrinkInY) {\r\n            // Shrink element height if not enough space.\r\n            if (directions.top && y < 0 && this.stickToEdges) {\r\n                y = 0;\r\n                this.el.style.height = spaceTop + 'px';\r\n                overflowYSet = true;\r\n            }\r\n            else if (directions.bottom && y + h > dh && this.stickToEdges) {\r\n                this.el.style.height = spaceBottom + 'px';\r\n                overflowYSet = true;\r\n            }\r\n            else if (!directions.top && !directions.bottom && rect.height > dh) {\r\n                y = 0;\r\n                this.el.style.height = dh + 'px';\r\n                overflowYSet = true;\r\n            }\r\n        }\r\n        position.y = y;\r\n        return overflowYSet;\r\n    }\r\n    /** Do herizontal alignment. */\r\n    alignHerizontal(position, directions, rect, targetRect, triangleRect) {\r\n        let dw = document.documentElement.clientWidth;\r\n        let spaceLeft = targetRect.left - this.margins.left;\r\n        let spaceRight = dw - (targetRect.right + this.margins.right);\r\n        let w = rect.width;\r\n        let x = position.x;\r\n        if (directions.left || directions.right) {\r\n            // Not enough space in left position.\r\n            if (directions.left && x < 0 && spaceLeft < spaceRight && this.canSwapPosition) {\r\n                x = targetRect.right + this.margins.right;\r\n                directions.left = false;\r\n                directions.right = true;\r\n            }\r\n            // Not enough space in right position.\r\n            else if (directions.right && x > dw - w && spaceLeft > spaceRight && this.canSwapPosition) {\r\n                x = targetRect.left - this.margins.left - w;\r\n                directions.left = true;\r\n                directions.right = false;\r\n            }\r\n        }\r\n        else {\r\n            // Can move left a little to become fully visible.\r\n            if (x + w > dw && this.stickToEdges) {\r\n                // Gives enough space for triangle.\r\n                let minX = targetRect.left + (triangleRect ? triangleRect.width : 0) - w;\r\n                x = Math.max(dw - w, minX);\r\n            }\r\n            // Can move right a little to become fully visible.\r\n            if (x < 0 && this.stickToEdges) {\r\n                // Gives enough space for triangle.\r\n                let minX = targetRect.right - (triangleRect ? triangleRect.width : 0);\r\n                x = Math.min(0, minX);\r\n            }\r\n        }\r\n        position.x = x;\r\n    }\r\n    /** Align `triangle` relative to `el`. */\r\n    alignTriangle(position, directions, rect, targetRect, triangleRect) {\r\n        let triangle = this.triangle;\r\n        let transforms = [];\r\n        let w = rect.width;\r\n        let h = rect.height;\r\n        if (directions.top) {\r\n            triangle.style.top = 'auto';\r\n            triangle.style.bottom = -triangleRect.height + 'px';\r\n            transforms.push('rotateX(180deg)');\r\n        }\r\n        else if (directions.bottom) {\r\n            triangle.style.top = -triangleRect.height + 'px';\r\n            triangle.style.bottom = '';\r\n        }\r\n        else if (directions.left) {\r\n            triangle.style.left = 'auto';\r\n            triangle.style.right = -triangleRect.width + 'px';\r\n            transforms.push('rotateY(180deg)');\r\n        }\r\n        else if (directions.right) {\r\n            triangle.style.left = -triangleRect.width + 'px';\r\n            triangle.style.right = '';\r\n        }\r\n        if (directions.top || directions.bottom) {\r\n            let halfTriangleWidth = triangleRect.width / 2;\r\n            let x = 0;\r\n            // Adjust triangle to the center of the target edge.\r\n            if ((w >= targetRect.width || this.fixTriangle) && this.alignPosition[1][1] === 'c') {\r\n                x = targetRect.left + targetRect.width / 2 - position.x - halfTriangleWidth;\r\n            }\r\n            // In fixed position.\r\n            else if (this.fixTriangle) {\r\n                x = triangleRect.left - rect.left;\r\n            }\r\n            // Adjust triangle to the center of the el edge.\r\n            else {\r\n                x = w / 2 - halfTriangleWidth;\r\n            }\r\n            x = Math.max(x, halfTriangleWidth);\r\n            x = Math.min(x, rect.width - triangleRect.width - halfTriangleWidth);\r\n            if (this.fixTriangle) {\r\n                x -= triangleRect.left - rect.left;\r\n                transforms.push(`translateX(${x}px)`);\r\n            }\r\n            else {\r\n                triangle.style.left = x + 'px';\r\n            }\r\n            triangle.style.right = '';\r\n        }\r\n        if (directions.left || directions.right) {\r\n            let halfTriangleHeight = triangleRect.height / 2;\r\n            let y;\r\n            if ((h >= targetRect.height || this.fixTriangle) && this.alignPosition[1][0] === 'c') {\r\n                y = targetRect.top + targetRect.height / 2 - position.y - halfTriangleHeight;\r\n            }\r\n            else if (this.fixTriangle) {\r\n                y = triangleRect.top - rect.top;\r\n            }\r\n            else {\r\n                y = h / 2 - halfTriangleHeight;\r\n            }\r\n            y = Math.max(y, halfTriangleHeight);\r\n            y = Math.min(y, rect.height - triangleRect.height - halfTriangleHeight);\r\n            if (this.fixTriangle) {\r\n                y -= triangleRect.top - rect.top;\r\n                transforms.push(`translateY(${y}px)`);\r\n            }\r\n            else if (!this.fixTriangle) {\r\n                triangle.style.top = y + 'px';\r\n            }\r\n            triangle.style.bottom = '';\r\n        }\r\n        triangle.style.transform = transforms.join(' ');\r\n    }\r\n}\r\nexports.Aligner = Aligner;\r\n/**\r\n * Full type is `[tbc][lrc]-[tbc][lrc]`, means `[Y of el][X of el]-[Y of target][X of target]`.\r\n * Shorter type should be `[Touch][Align]` or `[Touch]`.\r\n * E.g.: `t` is short for `tc` or `b-t` or `bc-tc`, which means align el to the top-center of target.\r\n * E.g.: `tl` is short for `bl-tl`, which means align el to the top-left of target.\r\n * E.g.: `lt` is short for `tr-tl`, which means align el to the left-top of target.\r\n */\r\nfunction parseAlignPosition(position) {\r\n    const ALIGN_POS_OPPOSITE = {\r\n        t: 'b',\r\n        b: 't',\r\n        c: 'c',\r\n        l: 'r',\r\n        r: 'l',\r\n    };\r\n    if (!/^(?:[tbc][lrc]-[tbc][lrc]|[tbclr]-[tbclr]|[tbc][lrc]|[tbclr])/.test(position)) {\r\n        throw `\"${position}\" is not a valid position`;\r\n    }\r\n    if (position.length === 1) {\r\n        // t -> bc-tc\r\n        if ('tb'.includes(position)) {\r\n            position = ALIGN_POS_OPPOSITE[position] + 'c-' + position + 'c';\r\n        }\r\n        // l -> cr-cl\r\n        // c -> cc-cc\r\n        else {\r\n            position = 'c' + ALIGN_POS_OPPOSITE[position] + '-c' + position;\r\n        }\r\n    }\r\n    else if (position.length === 2) {\r\n        // tl -> bl-tl\r\n        if ('tb'.includes(position[0])) {\r\n            position = ALIGN_POS_OPPOSITE[position[0]] + position[1] + '-' + position;\r\n        }\r\n        // lt -> tr-tl\r\n        else {\r\n            position = position[1] + ALIGN_POS_OPPOSITE[position[0]] + '-' + position[1] + position[0];\r\n        }\r\n    }\r\n    let posArray = position.split('-');\r\n    return [completeAlignPosition(posArray[0]), completeAlignPosition(posArray[1])];\r\n}\r\n/** Complete align position from one char to two, e.g., `t-b` -> `tc-bc`. */\r\nfunction completeAlignPosition(pos) {\r\n    if (pos.length === 1) {\r\n        pos = 'tb'.includes(pos) ? pos + 'c' : 'c' + pos;\r\n    }\r\n    return pos;\r\n}\r\n/**\r\n * Get main align direction from align position string, can be used to set triangle styles.\r\n * @param pos Align position like `t`, `tc`, `bc-tc`.\r\n */\r\nfunction getMainAlignDirection(pos) {\r\n    let position = pos.length < 5 ? parseAlignPosition(pos) : pos;\r\n    if (position[0].includes('b') && position[1].includes('t')) {\r\n        return 't';\r\n    }\r\n    else if (position[0].includes('l') && position[1].includes('r')) {\r\n        return 'r';\r\n    }\r\n    else if (position[0].includes('t') && position[1].includes('b')) {\r\n        return 'b';\r\n    }\r\n    else if (position[0].includes('r') && position[1].includes('l')) {\r\n        return 'l';\r\n    }\r\n    else if (position[0] === 'cc' && position[1] === 'cc') {\r\n        return 'c';\r\n    }\r\n    else {\r\n        return '';\r\n    }\r\n}\r\nexports.getMainAlignDirection = getMainAlignDirection;\r\n/** Check if rect box intersect with viewport. */\r\nfunction isRectVisible(rect) {\r\n    return rect.width > 0 && rect.height > 0;\r\n}\r\n/** Check if rect box intersect with viewport. */\r\nfunction isRectIntersectWithViewport(rect) {\r\n    let w = document.documentElement.clientWidth;\r\n    let h = document.documentElement.clientHeight;\r\n    return rect.left < w && rect.right > 0 && rect.top < h && rect.bottom > 0;\r\n}\r\n/** Get a closest ancest element which has fixed position. */\r\nfunction getClosestFixedElement(el) {\r\n    while (el && el !== document.documentElement) {\r\n        if (getComputedStyle(el).position === 'fixed') {\r\n            break;\r\n        }\r\n        el = el.parentElement;\r\n    }\r\n    return el === document.documentElement ? null : el;\r\n}\r\n/**\r\n * Align element to a mouse event.\r\n * @param el A fixed position element to align.\r\n * @param event A mouse event to align to.\r\n * @param offset `[x, y]` offset relative to current mouse position.\r\n */\r\nfunction alignToEvent(el, event, offset = [0, 0]) {\r\n    if (style_1.getStyleValue(el, 'position') !== 'fixed') {\r\n        throw new Error(`Element to call \"alignToEvent\" must in fixed layout`);\r\n    }\r\n    let dw = document.documentElement.clientWidth;\r\n    let dh = document.documentElement.clientHeight;\r\n    let w = el.offsetWidth;\r\n    let h = el.offsetHeight;\r\n    let ex = event.clientX;\r\n    let ey = event.clientY;\r\n    let x = ex + offset[0];\r\n    let y = ey + offset[1];\r\n    if (x + w > dw) {\r\n        x = dw - w;\r\n    }\r\n    if (y + h > dh) {\r\n        y = dh - h;\r\n    }\r\n    el.style.left = Math.round(x) + 'px';\r\n    el.style.top = Math.round(y) + 'px';\r\n}\r\nexports.alignToEvent = alignToEvent;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isPlayingAnimation = exports.stopAnimation = exports.animateToNextFrame = exports.animateTo = exports.animateFrom = exports.animate = exports.animateStyleValueTo = exports.animateStyleValueFrom = exports.animateStyleValue = exports.animateInterpolatedValue = exports.getCSSEasingValue = exports.getEasingFunction = void 0;\r\nconst style_1 = require(\"./style\");\r\nconst utils_1 = require(\"./utils\");\r\n/** Default animation duration, plays aniamtion for millseconds according to this property by default. */\r\nconst DefaultAnimationDuration = 200;\r\n/** Default animation duration, plays aniamtion with easing according to this property by default. */\r\nconst DefaultAnimationEasing = 'ease-out-quad';\r\n/** Cache element and their current playing animation. */\r\nconst ElementAnimationCache = new WeakMap();\r\n/** Cache element and their current playing animation. */\r\nconst ElementAnimationStopper = new WeakMap();\r\n/** Specifies easing name and their bezier parameters, copied from `Bourbon` source codes. */\r\nconst CUBIC_BEZIER_EASINGS = {\r\n    // BASE\r\n    'ease': [0.250, 0.100, 0.250, 1.000],\r\n    'ease-in': [0.420, 0.000, 1.000, 1.000],\r\n    'ease-out': [0.000, 0.000, 0.580, 1.000],\r\n    'ease-in-out': [0.420, 0.000, 0.580, 1.000],\r\n    // EASE IN\r\n    'ease-in-quad': [0.550, 0.085, 0.680, 0.530],\r\n    'ease-in-cubic': [0.550, 0.055, 0.675, 0.190],\r\n    'ease-in-quart': [0.895, 0.030, 0.685, 0.220],\r\n    'ease-in-quint': [0.755, 0.050, 0.855, 0.060],\r\n    'ease-in-sine': [0.470, 0.000, 0.745, 0.715],\r\n    'ease-in-expo': [0.950, 0.050, 0.795, 0.035],\r\n    'ease-in-circ': [0.600, 0.040, 0.980, 0.335],\r\n    'ease-in-back': [0.600, -0.280, 0.735, 0.045],\r\n    // EASE OUT\r\n    'ease-out-quad': [0.250, 0.460, 0.450, 0.940],\r\n    'ease-out-cubic': [0.215, 0.610, 0.355, 1.000],\r\n    'ease-out-quart': [0.165, 0.840, 0.440, 1.000],\r\n    'ease-out-quint': [0.230, 1.000, 0.320, 1.000],\r\n    'ease-out-sine': [0.390, 0.575, 0.565, 1.000],\r\n    'ease-out-expo': [0.190, 1.000, 0.220, 1.000],\r\n    'ease-out-circ': [0.075, 0.820, 0.165, 1.000],\r\n    'ease-out-back': [0.175, 0.885, 0.320, 1.275],\r\n    // EASE IN OUT\r\n    'ease-in-out-quad': [0.455, 0.030, 0.515, 0.955],\r\n    'ease-in-out-cubic': [0.645, 0.045, 0.355, 1.000],\r\n    'ease-in-out-quart': [0.770, 0.000, 0.175, 1.000],\r\n    'ease-in-out-quint': [0.860, 0.000, 0.070, 1.000],\r\n    'ease-in-out-sine': [0.445, 0.050, 0.550, 0.950],\r\n    'ease-in-out-expo': [1.000, 0.000, 0.000, 1.000],\r\n    'ease-in-out-circ': [0.785, 0.135, 0.150, 0.860],\r\n    'ease-in-out-back': [0.680, -0.550, 0.265, 1.550],\r\n};\r\n/** The default style of element, which is not `0` */\r\nconst DefaultNotNumericStyleProperties = {\r\n    transform: 'none'\r\n};\r\n/** Cached compiled easing functions. */\r\nconst easingFns = {\r\n    linear: function (x) {\r\n        return x;\r\n    }\r\n};\r\n/**\r\n * Get a `(x) => y` function from easing name.\r\n * @param easing The extended easing name.\r\n */\r\nfunction getEasingFunction(name) {\r\n    if (name === 'linear') {\r\n        return easingFns[name];\r\n    }\r\n    else {\r\n        return easingFns[name] = getCubicBezierEasingFunction(name);\r\n    }\r\n}\r\nexports.getEasingFunction = getEasingFunction;\r\n/**\r\n * Get `cubic-bezier(...)` as CSS easing from easing name.\r\n * @param easing The extended easing name.\r\n */\r\nfunction getCSSEasingValue(easing) {\r\n    return CUBIC_BEZIER_EASINGS.hasOwnProperty(easing)\r\n        ? 'cubic-bezier(' + CUBIC_BEZIER_EASINGS[easing].join(', ') + ')'\r\n        : easing;\r\n}\r\nexports.getCSSEasingValue = getCSSEasingValue;\r\n/** Compile a easing function from extended easing name. */\r\nfunction getCubicBezierEasingFunction(name) {\r\n    //\tF(t)  = (1-t)^3 * P0 + 3t(1-t)^2 * P1 + 3t^2(1-t)^2 * P2 + t^3 * P3, t in [0, 1]\r\n    //\r\n    //\tGet the x axis projecting function, and knows x0 = 0, x3 = 1, got:\r\n    //\tCx(t) = 3t(1-t)^2 * x1 + 3t^2(1-t) * x2 + t^3\r\n    //\t\t  = (3x1 - 3x2 + 1) * t^3 + (-6x1 + 3x2) * t^2 + 3x1 * t\r\n    //\t\r\n    //\tFrom Cx(t) = x, got t by binary iteration algorithm, then pass it to y axis projecting function:\r\n    //\tCy(t) = (3y1 - 3y2 + 1) * t^3 + (-6y1 + 3y2) * t^2 + 3y1 * t\r\n    let [x1, y1, x2, y2] = CUBIC_BEZIER_EASINGS[name];\r\n    let a = 3 * x1 - 3 * x2 + 1;\r\n    let b = -6 * x1 + 3 * x2;\r\n    let c = 3 * x1;\r\n    let ay = 3 * y1 - 3 * y2 + 1;\r\n    let by = -6 * y1 + 3 * y2;\r\n    let cy = 3 * y1;\r\n    return function (x) {\r\n        if (x === 0) {\r\n            return 0;\r\n        }\r\n        else if (x === 1) {\r\n            return 1;\r\n        }\r\n        let d = -x;\r\n        let t1 = 0;\r\n        let t2 = 1;\r\n        let t = (t1 + t2) / 2;\r\n        while (t2 - t1 > 0.0001) {\r\n            let v = ((a * t + b) * t + c) * t + d;\r\n            if (v < 0) {\r\n                t1 = t;\r\n            }\r\n            else {\r\n                t2 = t;\r\n            }\r\n            t = (t1 + t2) / 2;\r\n        }\r\n        return ((ay * t + by) * t + cy) * t;\r\n    };\r\n}\r\n/** Play per frame animation when no standard animation available. */\r\nfunction playPerFrameAnimation(duration, easing, onInterval, onEnd) {\r\n    let startTimestamp = performance.now();\r\n    let easingFn = getEasingFunction(easing);\r\n    let frameId = 0;\r\n    let runNextFrame = () => {\r\n        frameId = requestAnimationFrame((timestamp) => {\r\n            let timeDiff = timestamp - startTimestamp;\r\n            let x = timeDiff / duration;\r\n            if (x >= 1) {\r\n                frameId = 0;\r\n                onInterval(1);\r\n                if (onEnd) {\r\n                    onEnd(true);\r\n                }\r\n            }\r\n            else {\r\n                let y = easingFn(x);\r\n                onInterval(y);\r\n                runNextFrame();\r\n            }\r\n        });\r\n    };\r\n    runNextFrame();\r\n    return () => {\r\n        if (frameId) {\r\n            cancelAnimationFrame(frameId);\r\n            if (onEnd) {\r\n                onEnd(false);\r\n            }\r\n        }\r\n    };\r\n}\r\n/**\r\n * Animate by a value range, `fn` recives current value that interpolate from `startValue` to `endValue` as parameter.\r\n * Execute animation by setting values per frame in `requestAnimationFrame`.\r\n * @param fn The function which will got a current state number value as parameter.\r\n * @param startValue The start value.\r\n * @param endValue  The end value.\r\n * @param duration The animation duration.\r\n * @param easing  The animation easing.\r\n */\r\nfunction animateInterpolatedValue(fn, startValue, endValue, duration = DefaultAnimationDuration, easing = DefaultAnimationEasing) {\r\n    let stop;\r\n    let promise = new Promise((resolve) => {\r\n        stop = playPerFrameAnimation(duration, easing, (y) => {\r\n            fn(startValue + (endValue - startValue) * y);\r\n        }, resolve);\r\n    });\r\n    return {\r\n        promise,\r\n        stop: stop,\r\n    };\r\n}\r\nexports.animateInterpolatedValue = animateInterpolatedValue;\r\n/**\r\n * Animate numberic style value even `scrollLeft` and `scrollTop` on `el`.\r\n * Execute animation per frames by setting values per frame in `requestAnimationFrame`.\r\n * @param el The element to animate.\r\n * @param property The style property or `scrollLeft` and `scrollTop`.\r\n * @param startValue The start value of `property`.\r\n * @param endValue  The end value of `property`.\r\n * @param duration The animation duration.\r\n * @param easing  The animation easing.\r\n */\r\nfunction animateStyleValue(el, property, startValue, endValue, duration = DefaultAnimationDuration, easing = DefaultAnimationEasing) {\r\n    let promise = new Promise((resolve) => {\r\n        let stop = playPerFrameAnimation(duration, easing, (y) => {\r\n            let value = startValue + (endValue - startValue) * y;\r\n            if (property === 'scrollTop' || property === 'scrollLeft') {\r\n                el[property] = value;\r\n            }\r\n            else {\r\n                style_1.setStyleValue(el, property, value);\r\n            }\r\n        }, resolve);\r\n        let stopper = () => {\r\n            stop();\r\n            ElementAnimationStopper.delete(el);\r\n        };\r\n        ElementAnimationStopper.set(el, stopper);\r\n    });\r\n    return promise;\r\n}\r\nexports.animateStyleValue = animateStyleValue;\r\n/**\r\n * Animate numberic style value even `scrollLeft` and `scrollTop` on `el`.\r\n * Execute animation per frames by setting values per frame in `requestAnimationFrame`.\r\n * @param el The element to animate.\r\n * @param property The style property or `scrollLeft` and `scrollTop`.\r\n * @param startValue The start value.\r\n * @param duration The animation duration.\r\n * @param easing  The animation easing.\r\n */\r\nfunction animateStyleValueFrom(el, property, startValue, duration = DefaultAnimationDuration, easing = DefaultAnimationEasing) {\r\n    let endValue;\r\n    if (property === 'scrollTop' || property === 'scrollLeft') {\r\n        endValue = el[property];\r\n    }\r\n    else {\r\n        endValue = style_1.getStyleValueAsNumber(el, property);\r\n    }\r\n    return animateStyleValue(el, property, startValue, endValue, duration, easing);\r\n}\r\nexports.animateStyleValueFrom = animateStyleValueFrom;\r\n/**\r\n * Animate numberic style value even `scrollLeft` and `scrollTop` on `el`.\r\n * Execute animation per frames by setting values per frame in `requestAnimationFrame`.\r\n * @param el The element to animate.\r\n * @param property The style property or `scrollLeft` and `scrollTop`.\r\n * @param endValue The end value.\r\n * @param duration The animation duration.\r\n * @param easing  The animation easing.\r\n */\r\nfunction animateStyleValueTo(el, property, endValue, duration = DefaultAnimationDuration, easing = DefaultAnimationEasing) {\r\n    let startValue;\r\n    if (property === 'scrollTop' || property === 'scrollLeft') {\r\n        startValue = el[property];\r\n    }\r\n    else {\r\n        startValue = style_1.getStyleValueAsNumber(el, property);\r\n    }\r\n    return animateStyleValue(el, property, startValue, endValue, duration, easing);\r\n}\r\nexports.animateStyleValueTo = animateStyleValueTo;\r\n/**\r\n * Execute standard web animation on element.\r\n * After animation end, the state of element will go back to the start state.\r\n * @param el The element to execute web animation.\r\n * @param startFrame The start frame.\r\n * @param endFrame The end frame.\r\n * @param duration The animation duration.\r\n * @param easing  The animation easing.\r\n */\r\nfunction animate(el, startFrame, endFrame, duration = DefaultAnimationDuration, easing = DefaultAnimationEasing) {\r\n    if (!el.animate) {\r\n        return Promise.resolve(false);\r\n    }\r\n    stopAnimation(el);\r\n    startFrame = utils_1.normativeStyleObject(startFrame);\r\n    endFrame = utils_1.normativeStyleObject(endFrame);\r\n    let cubicEasing = getCSSEasingValue(easing);\r\n    let animation = el.animate([startFrame, endFrame], {\r\n        easing: cubicEasing,\r\n        duration,\r\n    });\r\n    ElementAnimationCache.set(el, animation);\r\n    return new Promise((resolve) => {\r\n        animation.addEventListener('finish', () => {\r\n            ElementAnimationCache.delete(el);\r\n            resolve(true);\r\n        }, false);\r\n        animation.addEventListener('cancel', () => {\r\n            ElementAnimationCache.delete(el);\r\n            resolve(false);\r\n        }, false);\r\n    });\r\n}\r\nexports.animate = animate;\r\n/**\r\n * Execute standard web animation on element with start frame specified.\r\n * The end frame will be set as zero or empty values.\r\n * @param el The element to execute web animation.\r\n * @param startFrame The start frame.\r\n * @param duration The animation duration.\r\n * @param easing  The animation easing.\r\n */\r\nfunction animateFrom(el, startFrame, duration = DefaultAnimationDuration, easing = DefaultAnimationEasing) {\r\n    let endFrame = {};\r\n    let style = getComputedStyle(el);\r\n    for (let property in startFrame) {\r\n        endFrame[property] = style[property] || DefaultNotNumericStyleProperties[property] || '0';\r\n    }\r\n    return animate(el, startFrame, endFrame, duration, easing);\r\n}\r\nexports.animateFrom = animateFrom;\r\n/**\r\n * Execute standard web animation on element with end frame specified.\r\n * The end frame will be specified as values of current state.\r\n * After animation executed, will apply end frame values to element.\r\n * @param el The element to execute web animation.\r\n * @param endFrame The end frame.\r\n * @param duration The animation duration.\r\n * @param easing  The animation easing.\r\n */\r\nasync function animateTo(el, endFrame, duration = DefaultAnimationDuration, easing = DefaultAnimationEasing) {\r\n    let startFrame = {};\r\n    let style = getComputedStyle(el);\r\n    // Fix '' to `0` or `none`\r\n    let standardEndFrame = Object.assign({}, endFrame);\r\n    for (let property in standardEndFrame) {\r\n        if (standardEndFrame[property] === '') {\r\n            standardEndFrame[property] = DefaultNotNumericStyleProperties[property] || '0';\r\n        }\r\n    }\r\n    for (let property in endFrame) {\r\n        startFrame[property] = style[property] || DefaultNotNumericStyleProperties[property] || '0';\r\n    }\r\n    let finish = await animate(el, startFrame, standardEndFrame, duration, easing);\r\n    if (finish) {\r\n        style_1.setStyleValues(el, endFrame);\r\n    }\r\n    return finish;\r\n}\r\nexports.animateTo = animateTo;\r\n/**\r\n * Execute standard web animation, captures current state as start frame, and captures a new state later as end frame.\r\n * @param el The element to execute web animation.\r\n * @param properties The style properties to capture.\r\n * @param duration The animation duration.\r\n * @param easing  The animation easing.\r\n */\r\nfunction animateToNextFrame(el, properties, duration = DefaultAnimationDuration, easing = DefaultAnimationEasing) {\r\n    if (!el.animate) {\r\n        return Promise.resolve(false);\r\n    }\r\n    stopAnimation(el);\r\n    if (typeof properties === 'string') {\r\n        properties = [properties];\r\n    }\r\n    let startFrame = {};\r\n    let style = getComputedStyle(el);\r\n    for (let property of properties) {\r\n        startFrame[property] = style[property];\r\n    }\r\n    return new Promise(resolve => {\r\n        requestAnimationFrame(() => {\r\n            animateFrom(el, startFrame, duration, easing).then(resolve);\r\n        });\r\n    });\r\n}\r\nexports.animateToNextFrame = animateToNextFrame;\r\n/**\r\n * Stop executing standard web animation on element.\r\n * Returns whether stopped animation.\r\n * @param el The element to stop animation at.\r\n */\r\nfunction stopAnimation(el) {\r\n    let animation = ElementAnimationCache.get(el);\r\n    if (animation) {\r\n        animation.cancel();\r\n        ElementAnimationCache.delete(el);\r\n        return true;\r\n    }\r\n    let stopper = ElementAnimationStopper.get(el);\r\n    if (stopper) {\r\n        stopper();\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexports.stopAnimation = stopAnimation;\r\n/**\r\n * Test if element is playing an animation.\r\n * @param el The element to test animation at.\r\n */\r\nfunction isPlayingAnimation(el) {\r\n    let animation = ElementAnimationCache.get(el);\r\n    if (animation) {\r\n        return true;\r\n    }\r\n    let stopper = ElementAnimationStopper.get(el);\r\n    if (stopper) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexports.isPlayingAnimation = isPlayingAnimation;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.locateLastVisibleIndex = exports.locateFirstVisibleIndex = exports.isVisibleInViewport = exports.getRect = exports.getOuterHeight = exports.getOuterWidth = exports.getInnerHeight = exports.getInnerWidth = exports.getElementIndex = exports.getNodeIndex = void 0;\r\nconst array_1 = require(\"../base/array\");\r\nconst style_1 = require(\"./style\");\r\n/**\r\n * Get the index of node in it's node siblings.\r\n * @param node The node.\r\n */\r\nfunction getNodeIndex(node) {\r\n    if (node.parentNode) {\r\n        let i = 0;\r\n        for (let child of node.parentNode.childNodes) {\r\n            if (child === node) {\r\n                return i;\r\n            }\r\n            i++;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\nexports.getNodeIndex = getNodeIndex;\r\n/**\r\n * Get the index of element in it's element siblings.\r\n * @param el The node.\r\n */\r\nfunction getElementIndex(el) {\r\n    if (el.parentNode) {\r\n        let i = 0;\r\n        for (let child of el.parentNode.children) {\r\n            if (child === el) {\r\n                return i;\r\n            }\r\n            i++;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\nexports.getElementIndex = getElementIndex;\r\n/**\r\n * Get inner width of element, which equals `clientWidth - paddingWidths` or `width - paddingWidths - scrollbarWidth`.\r\n * Note that this method may cause page reflow.\r\n * @param el The element to get width.\r\n */\r\nfunction getInnerWidth(el) {\r\n    let w = el.clientWidth;\r\n    if (w) {\r\n        return el.clientWidth - style_1.getStyleValueAsNumber(el, 'paddingLeft') - style_1.getStyleValueAsNumber(el, 'paddingRight');\r\n    }\r\n    else {\r\n        return 0;\r\n    }\r\n}\r\nexports.getInnerWidth = getInnerWidth;\r\n/**\r\n * Get inner height of element, which equals to `clientHeight - paddingHeights` or `height - paddingHeights - scrollbarHeight`.\r\n * Note that this method may cause page reflow.\r\n * @param el The element to get height.\r\n */\r\nfunction getInnerHeight(el) {\r\n    let h = el.clientHeight;\r\n    if (h) {\r\n        return h - style_1.getStyleValueAsNumber(el, 'paddingTop') - style_1.getStyleValueAsNumber(el, 'paddingBottom');\r\n    }\r\n    else {\r\n        return 0;\r\n    }\r\n}\r\nexports.getInnerHeight = getInnerHeight;\r\n/**\r\n * Get outer width of element, which equals `offsetWidth + marginWidths`.\r\n * Note that this method may cause page reflow.\r\n * @param el The element to get width.\r\n */\r\nfunction getOuterWidth(el) {\r\n    let w = el.offsetWidth;\r\n    if (w) {\r\n        return w + style_1.getStyleValueAsNumber(el, 'marginLeft') + style_1.getStyleValueAsNumber(el, 'marginRight');\r\n    }\r\n    else {\r\n        return 0;\r\n    }\r\n}\r\nexports.getOuterWidth = getOuterWidth;\r\n/**\r\n * Get inner height of element, which equals `offsetHeight + marginHeights`.\r\n * Note that this method may cause page reflow.\r\n * @param el The element to get height.\r\n */\r\nfunction getOuterHeight(el) {\r\n    let h = el.offsetHeight;\r\n    if (h) {\r\n        return h + style_1.getStyleValueAsNumber(el, 'marginTop') + style_1.getStyleValueAsNumber(el, 'marginBottom');\r\n    }\r\n    else {\r\n        return 0;\r\n    }\r\n}\r\nexports.getOuterHeight = getOuterHeight;\r\n/**\r\n * Get an rect object just like `getBoundingClientRect`.\r\n * The didderence is it always returns the rect of visible part for `<html>`, and properties are writable.\r\n * Note that this method may cause page reflow.\r\n * @param el The element to get rect size.\r\n */\r\nfunction getRect(el) {\r\n    if (el === document.documentElement) {\r\n        let dw = document.documentElement.clientWidth;\r\n        let dh = document.documentElement.clientHeight;\r\n        return {\r\n            top: 0,\r\n            right: dw,\r\n            bottom: dh,\r\n            left: 0,\r\n            width: dw,\r\n            height: dh,\r\n        };\r\n    }\r\n    else {\r\n        let rect = el.getBoundingClientRect();\r\n        return {\r\n            top: rect.top,\r\n            right: rect.right,\r\n            bottom: rect.bottom,\r\n            left: rect.left,\r\n            width: rect.width,\r\n            height: rect.height,\r\n        };\r\n    }\r\n}\r\nexports.getRect = getRect;\r\n/**\r\n * Check if element is visible in current viewport, element must also be not fully covered.\r\n * Note that this method may cause page reflow.\r\n * @param el The element to check if is in view.\r\n * @param percentage Specify how much percentage of el size implies in view.\r\n * @param additionalElement Normally a popup element with `el` as it's trigger. it may cover `el` when page resizing.\r\n */\r\nfunction isVisibleInViewport(el, percentage = 0.5, additionalElement) {\r\n    let dw = document.documentElement.clientWidth;\r\n    let dh = document.documentElement.clientHeight;\r\n    let rect = getRect(el);\r\n    let xIntersect = Math.min(dw, rect.right) - Math.max(0, rect.left);\r\n    let yIntersect = Math.min(dh, rect.bottom) - Math.max(0, rect.top);\r\n    let inRange = xIntersect / Math.min(rect.width, dw) > percentage\r\n        && yIntersect / Math.min(rect.height, dh) > percentage;\r\n    if (inRange) {\r\n        if (el.disabled) {\r\n            return true;\r\n        }\r\n        let elementInPoint = document.elementFromPoint(rect.left + rect.width / 2, rect.top + rect.height / 2);\r\n        let notBeCovered = el.contains(elementInPoint) || (additionalElement === null || additionalElement === void 0 ? void 0 : additionalElement.contains(elementInPoint));\r\n        if (notBeCovered) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexports.isVisibleInViewport = isVisibleInViewport;\r\n/**\r\n * Locate the first element in els that is is visible inside container.\r\n * @container Container to check visible inside.\r\n * @param els Element list to check.\r\n * @param minimumVisibleRate If more than such rate of element in viewport, we consider it as visible.\r\n */\r\nfunction locateFirstVisibleIndex(container, els, minimumVisibleRate = 0.5) {\r\n    return locateVisibleIndex(container, els, minimumVisibleRate, false);\r\n}\r\nexports.locateFirstVisibleIndex = locateFirstVisibleIndex;\r\n/**\r\n * Locate the last element in els that is is visible inside container.\r\n * @container Container to check visible inside.\r\n * @param els Element list to check.\r\n * @param minimumVisibleRate If more than such rate of element in viewport, we consider it as visible.\r\n */\r\nfunction locateLastVisibleIndex(container, els, minimumVisibleRate = 0.5) {\r\n    return locateVisibleIndex(container, els, minimumVisibleRate, true);\r\n}\r\nexports.locateLastVisibleIndex = locateLastVisibleIndex;\r\nfunction locateVisibleIndex(container, els, minimumVisibleRate, locateLast) {\r\n    let containerRect = container.getBoundingClientRect();\r\n    let index = array_1.binaryFindIndexToInsert(els, (el) => {\r\n        let rect = el.getBoundingClientRect();\r\n        let yIntersect = Math.min(containerRect.bottom, rect.bottom) - Math.max(containerRect.top, rect.top);\r\n        let intersectRate = yIntersect / Math.min(containerRect.height, rect.height);\r\n        // Fully above.\r\n        if (rect.bottom < containerRect.top) {\r\n            return 1;\r\n        }\r\n        // Fully behind.\r\n        else if (rect.top > containerRect.bottom) {\r\n            return -1;\r\n        }\r\n        // Partly cross in top position.\r\n        else if (rect.top < containerRect.top && intersectRate < minimumVisibleRate) {\r\n            return 1;\r\n        }\r\n        // Partly cross in bottom position.\r\n        else if (rect.bottom < containerRect.bottom && intersectRate < minimumVisibleRate) {\r\n            return -1;\r\n        }\r\n        // Enough percentage that intersect with.\r\n        // If `preferLast` is true, prefer moving to right.\r\n        else {\r\n            return locateLast ? 1 : -1;\r\n        }\r\n    });\r\n    if (locateLast) {\r\n        if (index > 0) {\r\n            index -= 1;\r\n        }\r\n    }\r\n    return index;\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getFilesFromTransfer = exports.selectMultipleFolders = exports.selectFolder = exports.selectMultipleFile = exports.selectFile = exports.downloadText = exports.downloadURL = void 0;\r\nconst base_1 = require(\"../base\");\r\n/**\r\n * Download url as a file with specified `fileName`.\r\n * Not that `fileName` may not work for crossed domain resources in some browsers.\r\n * @param url The URL to download.\r\n * @param fileName The file name.\r\n */\r\nfunction downloadURL(url, fileName) {\r\n    let a = document.createElement('a');\r\n    a.hidden = true;\r\n    a.href = url;\r\n    if (fileName) {\r\n        a.download = fileName;\r\n    }\r\n    document.body.appendChild(a);\r\n    a.click();\r\n    a.remove();\r\n}\r\nexports.downloadURL = downloadURL;\r\n/**\r\n * Download string as a file with specified `fileName`.\r\n * Not that `fileName` may not work for crossed domain resources in some browsers.\r\n * @param fileName The file name.\r\n * @param text The text to download.\r\n * @param mime The MIME type of file.\r\n */\r\nfunction downloadText(fileName, text, type = 'text/plain') {\r\n    let blob = new Blob([text], { type });\r\n    let fs = new FileReader;\r\n    fs.onload = () => {\r\n        fs.onload = null;\r\n        let a = document.createElement('a');\r\n        a.download = fileName;\r\n        a.href = fs.result;\r\n        document.body.append(a);\r\n        a.click();\r\n        a.remove();\r\n    };\r\n    fs.readAsDataURL(blob);\r\n}\r\nexports.downloadText = downloadText;\r\n/**\r\n * Select a single file that matches `MIME` type from clicking a `<input type=\"file\">`.\r\n * @param The MIME type of files.\r\n */\r\nfunction selectFile(mime) {\r\n    return selectFileOrFolder(mime, false, false);\r\n}\r\nexports.selectFile = selectFile;\r\n/**\r\n * Select multiple files match `MIME` type from clicking a `<input type=\"file\" multiple>`.\r\n * @param The MIME type of files.\r\n */\r\nfunction selectMultipleFile(mime) {\r\n    return selectFileOrFolder(mime, false, true);\r\n}\r\nexports.selectMultipleFile = selectMultipleFile;\r\n/** Select a single folder from clicking a `<input type=\"file\" directory>`. */\r\nfunction selectFolder() {\r\n    return selectFileOrFolder(\"*\", true, false);\r\n}\r\nexports.selectFolder = selectFolder;\r\n/** Select multiple folders from clicking a `<input type=\"file\" directory multiple>`. */\r\nfunction selectMultipleFolders() {\r\n    return selectFileOrFolder(\"*\", true, true);\r\n}\r\nexports.selectMultipleFolders = selectMultipleFolders;\r\n/** Select file or folder, multiple or not. */\r\nfunction selectFileOrFolder(mime, isFolder, isMultiple) {\r\n    return new Promise((resolve) => {\r\n        let input = document.createElement('input');\r\n        input.type = 'file';\r\n        input.hidden = true;\r\n        input.accept = mime;\r\n        input.multiple = isMultiple;\r\n        if (isFolder) {\r\n            input.setAttribute('directory', '');\r\n            input.setAttribute('webkitdirectory', '');\r\n        }\r\n        input.onchange = () => {\r\n            if (input.files) {\r\n                resolve(isMultiple ? [...input.files] : input.files[0] || null);\r\n            }\r\n            else {\r\n                resolve(null);\r\n            }\r\n        };\r\n        async function onDomFocus() {\r\n            await base_1.sleep(1000);\r\n            document.removeEventListener('focus', onDomFocus, false);\r\n            input.onchange = null;\r\n            input.remove();\r\n        }\r\n        document.addEventListener('focus', onDomFocus, false);\r\n        document.body.appendChild(input);\r\n        input.click();\r\n    });\r\n}\r\n/**\r\n * Get files in `DataTransfer` object that captured from drop event.\r\n * Only work on Chrome.\r\n * @param transfer The ` DataTransfer` object from drop event.\r\n */\r\nasync function getFilesFromTransfer(transfer) {\r\n    let transferFiles = [...transfer.files];\r\n    let files = [];\r\n    if (transfer.items && typeof DataTransferItem === 'function' && (DataTransferItem.prototype.hasOwnProperty('getAsEntry') || DataTransferItem.prototype.webkitGetAsEntry)) {\r\n        let items = [...transfer.items].filter(item => item.kind === 'file');\r\n        try {\r\n            for (let item of items) {\r\n                let entry = item.hasOwnProperty('getAsEntry') ? item.getAsEntry() : item.webkitGetAsEntry();\r\n                files.push(...await readFilesFromEntry(entry));\r\n            }\r\n        }\r\n        catch (err) {\r\n            files = transferFiles;\r\n        }\r\n    }\r\n    // Can only read files\r\n    else {\r\n        files = transferFiles;\r\n    }\r\n    return files;\r\n}\r\nexports.getFilesFromTransfer = getFilesFromTransfer;\r\n/** Read files from a file entry. */\r\nasync function readFilesFromEntry(entry) {\r\n    let files = [];\r\n    return new Promise(async (resolve, reject) => {\r\n        if (!entry) {\r\n            resolve([]);\r\n        }\r\n        else if (entry.isFile) {\r\n            entry.file((file) => {\r\n                file.path = file.path || entry.fullPath;\r\n                files.push(file);\r\n                resolve(files);\r\n            }, reject);\r\n        }\r\n        else if (entry.isDirectory) {\r\n            let reader = entry.createReader();\r\n            try {\r\n                while (true) {\r\n                    let filesInFolder = await readFilesFromDirectoryReader(reader);\r\n                    files.push(...filesInFolder);\r\n                    if (!filesInFolder.length) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n            resolve(files);\r\n        }\r\n    });\r\n}\r\n/** Read files from a directory reader. */\r\nfunction readFilesFromDirectoryReader(reader) {\r\n    return new Promise((resolve, reject) => {\r\n        let files = [];\r\n        // readEntries API can only read at most 100 files each time, so if reader isn't completed, still read it.\r\n        reader.readEntries(async (entries) => {\r\n            if (entries && entries.length) {\r\n                try {\r\n                    for (let entry of entries) {\r\n                        files.push(...await readFilesFromEntry(entry));\r\n                    }\r\n                }\r\n                catch (err) {\r\n                    reject(err);\r\n                }\r\n                resolve(files);\r\n            }\r\n            else {\r\n                resolve(files);\r\n            }\r\n        }, reject);\r\n    });\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.decodeHTML = exports.encodeHTML = void 0;\r\n/**\r\n * Encode `<>` to `&...` to makesure HTML codes are safely to be appended into document.\r\n * @param code Text to be encoded.\r\n */\r\nfunction encodeHTML(code) {\r\n    return code.replace(/</g, '&lt;').replace(/>/g, '&gt;');\r\n}\r\nexports.encodeHTML = encodeHTML;\r\n/**\r\n * Decode HTML codes which includes `&...` to be readable characters.\r\n * @param code Encoded HTML codes.\r\n */\r\nfunction decodeHTML(code) {\r\n    let parser = new DOMParser();\r\n    let dom = parser.parseFromString(`<!DOCTYPE html><body>${code}</body></html>`, 'text/html');\r\n    return dom.body.textContent;\r\n}\r\nexports.decodeHTML = decodeHTML;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__exportStar(require(\"./style\"), exports);\r\n__exportStar(require(\"./element\"), exports);\r\n__exportStar(require(\"./align\"), exports);\r\n__exportStar(require(\"./scroll\"), exports);\r\n__exportStar(require(\"./animate\"), exports);\r\n__exportStar(require(\"./mouse-leave\"), exports);\r\n__exportStar(require(\"./file\"), exports);\r\n__exportStar(require(\"./query\"), exports);\r\n__exportStar(require(\"./storage\"), exports);\r\n__exportStar(require(\"./watch-layout\"), exports);\r\n__exportStar(require(\"./net\"), exports);\r\n__exportStar(require(\"./html\"), exports);\r\n__exportStar(require(\"./timing\"), exports);\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MouseLeave = void 0;\r\n/**\r\n * It's common that popup2 triggered from an existing popup1,\r\n * later when mouse moved to popup2, popup1 should disappear because mouse leaves.\r\n * This is not correct, so we implemented a mouse popup stack and keep parent visible when child still having mouse inside.\r\n *\r\n * Caution: never forget to unregister mouse leave binding before elements disconnected.\r\n */\r\nvar MouseLeave;\r\n(function (MouseLeave) {\r\n    /** Existed mouse leave controllers. */\r\n    const Controllers = new Set();\r\n    /** Add one controller. */\r\n    function addControler(controller) {\r\n        Controllers.add(controller);\r\n    }\r\n    MouseLeave.addControler = addControler;\r\n    /** Delete one controller. */\r\n    function deleteControler(controller) {\r\n        Controllers.delete(controller);\r\n    }\r\n    MouseLeave.deleteControler = deleteControler;\r\n    /**\r\n     * Make sure `trigger` and all their ancestors can't call mouse leave callback and always visible.\r\n     * Normally used for contextmenu to keep parent popup visible.\r\n     * @param trigger Element to keep visible.\r\n     * @param popup Popup element that lock trigger element for preview. You should always provide this except there is no popup element.\r\n     */\r\n    function lock(trigger, popup = null) {\r\n        // 1. When popup2 generated, we check the trigger element if it was contained (not equal) in element of existing popups.\r\n        // 2. If so, we lock the exist popup until popup2 disappeared.\r\n        let controller = getControllerWhichPopupContains(trigger);\r\n        if (controller) {\r\n            controller.requestLock(trigger, popup);\r\n        }\r\n    }\r\n    MouseLeave.lock = lock;\r\n    /**\r\n     * Release locking `trigger` element.\r\n     * @param trigger Element don't want to keep anymore.\r\n     * @param popup Popup element that lock trigger element for preview. You should always provide this except there is no popup element.\r\n     */\r\n    function unlock(trigger, popup = null) {\r\n        let controller = getControllerWhichPopupContains(trigger);\r\n        if (controller) {\r\n            controller.releaseLock(trigger, popup);\r\n        }\r\n    }\r\n    MouseLeave.unlock = unlock;\r\n    /** Get Controller whose related elements contains and or equal one of specified elements. */\r\n    function getControllerWhichPopupContains(trigger) {\r\n        for (let controller of [...Controllers].reverse()) {\r\n            if (controller.popup.contains(trigger)) {\r\n                return controller;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Checks whether element or any of it's ancestors was kept to be visible.\r\n     * If element is not locked, you can destroy or reuse it immediately.\r\n     * @param el Element to check, normally a popup element.\r\n     */\r\n    function checkLocked(el) {\r\n        for (let controller of [...Controllers].reverse()) {\r\n            if (controller.popup.contains(el)) {\r\n                return controller.beLocked();\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    MouseLeave.checkLocked = checkLocked;\r\n    /**\r\n     * Call `callback` after mouse leaves all of the elements for `ms` milliseconds.\r\n     * It's very usefull to handle mouse hover event in menu & submenu.\r\n     * @param els Single element or element array to capture leaves at.\r\n     * @param callback The callback to call after mouse leaves all the elements.\r\n     * @param options Leave control options.\r\n     */\r\n    function on(trigger, popup, callback, options) {\r\n        let controller = new MouseLeaveController(trigger, popup, false, callback, options);\r\n        return () => controller.cancel();\r\n    }\r\n    MouseLeave.on = on;\r\n    /**\r\n     * Call `callback` after mouse leaves all of the elements for `ms` milliseconds, only trigger `callback` for once.\r\n     * It's very usefull to handle mouse event in menu & submenu.\r\n     * @param els els Single element or element array to capture leaves at.\r\n     * @param callback The callback to call after mouse leaves all the elements.\r\n     * @param options Leave control options.\r\n     */\r\n    function once(trigger, popup, callback, options) {\r\n        let controller = new MouseLeaveController(trigger, popup, true, callback, options);\r\n        return () => controller.cancel();\r\n    }\r\n    MouseLeave.once = once;\r\n})(MouseLeave = exports.MouseLeave || (exports.MouseLeave = {}));\r\nclass MouseLeaveController {\r\n    constructor(trigger, popup, isOnce, callback, options = {}) {\r\n        var _a;\r\n        /** Is mouse inside any of `els`. */\r\n        this.mouseIn = false;\r\n        /** Elements that locked current popup and make it to be visible. */\r\n        this.locks = new Map();\r\n        /** Is the controller canceld. */\r\n        this.ended = false;\r\n        /** Timeout to countdown time delay for calling `callback` */\r\n        this.timeout = null;\r\n        this.trigger = trigger;\r\n        this.popup = popup;\r\n        this.isOnce = isOnce;\r\n        this.callback = callback;\r\n        this.delay = (_a = options.delay) !== null && _a !== void 0 ? _a : 200;\r\n        if (options.mouseIn) {\r\n            this.onMouseEnter();\r\n        }\r\n        this.bindedOnMouseEnter = this.onMouseEnter.bind(this);\r\n        this.bindedOnMouseLeave = this.onMouseLeave.bind(this);\r\n        for (let el of [trigger, popup]) {\r\n            el.addEventListener('mouseenter', this.bindedOnMouseEnter, false);\r\n            el.addEventListener('mouseleave', this.bindedOnMouseLeave, false);\r\n        }\r\n        MouseLeave.addControler(this);\r\n    }\r\n    onMouseEnter() {\r\n        this.mouseIn = true;\r\n        MouseLeave.lock(this.trigger, this.popup);\r\n        this.clearTimeout();\r\n    }\r\n    onMouseLeave() {\r\n        this.mouseIn = false;\r\n        MouseLeave.unlock(this.trigger, this.popup);\r\n        if (!this.beLocked()) {\r\n            this.startTimeout();\r\n        }\r\n    }\r\n    startTimeout() {\r\n        this.clearTimeout();\r\n        this.timeout = setTimeout(() => this.onTimeout(), this.delay);\r\n    }\r\n    startTimeoutIfNot() {\r\n        if (!this.timeout) {\r\n            this.startTimeout();\r\n        }\r\n    }\r\n    onTimeout() {\r\n        this.timeout = null;\r\n        if (!this.mouseIn) {\r\n            this.flush();\r\n        }\r\n    }\r\n    clearTimeout() {\r\n        if (this.timeout) {\r\n            clearTimeout(this.timeout);\r\n            this.timeout = null;\r\n        }\r\n    }\r\n    flush() {\r\n        if (this.ended) {\r\n            return;\r\n        }\r\n        if (this.isOnce) {\r\n            this.cancel();\r\n        }\r\n        else {\r\n            this.releaseAllLocks();\r\n        }\r\n        this.callback();\r\n    }\r\n    cancel() {\r\n        if (this.ended) {\r\n            return;\r\n        }\r\n        this.clearTimeout();\r\n        for (let el of [this.trigger, this.popup]) {\r\n            el.removeEventListener('mouseenter', this.bindedOnMouseEnter, false);\r\n            el.removeEventListener('mouseleave', this.bindedOnMouseLeave, false);\r\n        }\r\n        MouseLeave.unlock(this.trigger, this.popup);\r\n        this.releaseAllLocks();\r\n        this.ended = true;\r\n        MouseLeave.deleteControler(this);\r\n    }\r\n    /** Whether was locked to keep visible. */\r\n    beLocked() {\r\n        return this.locks.size > 0;\r\n    }\r\n    /** Lock because want to keep `el` visible, request comes from `popup`. */\r\n    requestLock(el, popup) {\r\n        this.clearTimeout();\r\n        let identifiers = this.locks.get(el);\r\n        if (!identifiers) {\r\n            identifiers = new Set();\r\n            this.locks.set(el, identifiers);\r\n        }\r\n        identifiers.add(popup);\r\n        // Mouse leave will cause unlock in sequence,\r\n        // So after mouse in, must relock in sequence.\r\n        MouseLeave.lock(this.trigger, popup);\r\n    }\r\n    /** Release a lock. */\r\n    releaseLock(el, popup) {\r\n        let identifiers = this.locks.get(el);\r\n        if (identifiers) {\r\n            identifiers.delete(popup);\r\n            if (identifiers.size === 0) {\r\n                this.locks.delete(el);\r\n            }\r\n        }\r\n        MouseLeave.unlock(this.trigger, popup);\r\n        // May already started timeout because of mouse leave.\r\n        if (!this.beLocked() && !this.mouseIn) {\r\n            MouseLeave.unlock(this.trigger, this.popup);\r\n            this.startTimeoutIfNot();\r\n        }\r\n    }\r\n    /**\r\n     * Release all locks that from outside.\r\n     * This method is not required if everything goes well.\r\n     * But implement it will make it stronger.\r\n     */\r\n    releaseAllLocks() {\r\n        for (let [el, popups] of this.locks) {\r\n            for (let popup of popups) {\r\n                MouseLeave.unlock(el, popup);\r\n            }\r\n        }\r\n        this.locks = new Map();\r\n    }\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.loader = exports.ResourceLoader = void 0;\r\nconst base_1 = require(\"../base\");\r\n/**\r\n * Preload resources from their urls, and get total progress notifications.\r\n * Please beware of the CORS settings at the server.\r\n * If you want the progress working, please makesure the `content-length` response header is available.\r\n */\r\nclass ResourceLoader extends base_1.Emitter {\r\n    constructor(options = {}) {\r\n        var _a;\r\n        super();\r\n        /** URL base. */\r\n        this.base = '';\r\n        this.loaded = 0;\r\n        this.loadedCount = 0;\r\n        this.totalCount = 0;\r\n        this.base = (_a = options.base) !== null && _a !== void 0 ? _a : '';\r\n        this.on('finish', () => {\r\n            this.loaded = 0;\r\n            this.loadedCount = 0;\r\n            this.totalCount = 0;\r\n        });\r\n    }\r\n    /** Returns a promise which will be resolved after all loading resources loaded. */\r\n    untilFinish() {\r\n        return new Promise((resolve, reject) => {\r\n            this.once('finish', resolve);\r\n            this.once('error', reject);\r\n        });\r\n    }\r\n    /** Load one resource. */\r\n    async load(url, type) {\r\n        this.totalCount++;\r\n        let lastLoadedRate = 0;\r\n        return new Promise(async (resolve, reject) => {\r\n            try {\r\n                let blob = await this.loadResourceBlob(url, (loaded, total) => {\r\n                    let newLoadedRate = loaded / total || 0;\r\n                    this.loaded += newLoadedRate - lastLoadedRate;\r\n                    lastLoadedRate = newLoadedRate;\r\n                    this.emit('progress', Math.min(this.loaded, this.totalCount), this.totalCount);\r\n                });\r\n                let response = blob ? await this.getFromBlob(blob, type || 'blob') : null;\r\n                this.loadedCount++;\r\n                this.emit('progress', this.loadedCount, this.totalCount);\r\n                if (this.loadedCount === this.totalCount) {\r\n                    this.emit('finish');\r\n                }\r\n                resolve(response);\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n                this.emit('error', err);\r\n            }\r\n        });\r\n    }\r\n    /** Load as text string. */\r\n    async loadText(url) {\r\n        return await this.load(url, 'text');\r\n    }\r\n    /** Load as json data. */\r\n    async loadJSON(url) {\r\n        return await this.load(url, 'json');\r\n    }\r\n    /** Load as blob. */\r\n    async loadBlob(url) {\r\n        return await this.load(url, 'blob');\r\n    }\r\n    /** Load as an array buffer. */\r\n    async loadBuffer(url) {\r\n        return await this.load(url, 'buffer');\r\n    }\r\n    /** Load css source and append into document. */\r\n    async loadCSS(url) {\r\n        return await this.load(url, 'css');\r\n    }\r\n    /** Load js source and append into document. */\r\n    async loadJS(url) {\r\n        return await this.load(url, 'js');\r\n    }\r\n    /** Load as an image element. */\r\n    async loadImage(url) {\r\n        return await this.load(url, 'image');\r\n    }\r\n    /** Load as an audio element. */\r\n    async loadAudio(url) {\r\n        return await this.load(url, 'audio');\r\n    }\r\n    /** Load as an video element. */\r\n    async loadVideo(url) {\r\n        return await this.load(url, 'video');\r\n    }\r\n    /** Convert relative URL to absolute type. */\r\n    getAbsoluteURL(url) {\r\n        if (/^(?:https?:|\\/\\/)/.test(url) || !this.base) {\r\n            return url;\r\n        }\r\n        return this.base + url;\r\n    }\r\n    /** Load one resource. */\r\n    async loadResourceBlob(url, onprogress) {\r\n        let absloteURL = this.getAbsoluteURL(url);\r\n        return new Promise((resolve, reject) => {\r\n            let xhr = new XMLHttpRequest();\r\n            xhr.responseType = 'blob';\r\n            xhr.open('GET', absloteURL);\r\n            xhr.onprogress = (e) => {\r\n                if (e.lengthComputable) {\r\n                    onprogress(e.loaded, e.total);\r\n                }\r\n            };\r\n            xhr.onloadend = () => {\r\n                if (xhr.status >= 200 && xhr.status < 400) {\r\n                    resolve(xhr.response);\r\n                }\r\n                else {\r\n                    reject();\r\n                }\r\n            };\r\n            xhr.send();\r\n        });\r\n    }\r\n    /** Handle resource returned blob data. */\r\n    async getFromBlob(blob, type) {\r\n        let response;\r\n        if (type === 'blob') {\r\n            response = blob;\r\n        }\r\n        else if (type === 'css') {\r\n            response = await this.loadStyle(blob);\r\n        }\r\n        else if (type === 'js') {\r\n            response = await this.loadScript(blob);\r\n        }\r\n        else if (type === 'text') {\r\n            response = this.getAsText(blob);\r\n        }\r\n        else if (type === 'json') {\r\n            response = this.getAsJSON(blob);\r\n        }\r\n        else if (type === 'buffer') {\r\n            response = this.getAsBuffer(blob);\r\n        }\r\n        else if (type === 'image') {\r\n            response = this.getAsImage(blob);\r\n        }\r\n        else if (type === 'audio') {\r\n            response = this.getAsAudio(blob);\r\n        }\r\n        else if (type === 'video') {\r\n            response = this.getAsVideo(blob);\r\n        }\r\n        return response;\r\n    }\r\n    /** Load style resource as a style tag. */\r\n    loadStyle(blob) {\r\n        return new Promise((resolve, reject) => {\r\n            let link = document.createElement('link');\r\n            link.rel = 'stylesheet';\r\n            link.href = URL.createObjectURL(blob);\r\n            document.head.append(link);\r\n            link.addEventListener('load', () => resolve(link));\r\n            link.addEventListener('error', () => reject());\r\n        });\r\n    }\r\n    /** Load script resource as a script tag. */\r\n    loadScript(blob) {\r\n        return new Promise((resolve, reject) => {\r\n            let script = document.createElement('script');\r\n            script.async = false;\r\n            script.src = URL.createObjectURL(blob);\r\n            document.head.append(script);\r\n            script.addEventListener('load', () => resolve(script));\r\n            script.addEventListener('error', () => reject());\r\n        });\r\n    }\r\n    /** Get resource blob as text.*/\r\n    getAsText(blob) {\r\n        return new Promise(resolve => {\r\n            let reader = new FileReader();\r\n            reader.onload = () => {\r\n                resolve(reader.result);\r\n            };\r\n            reader.readAsText(blob);\r\n        });\r\n    }\r\n    /** Get resource blob as JSON. */\r\n    async getAsJSON(blob) {\r\n        let text = await this.getAsText(blob);\r\n        if (!text) {\r\n            return null;\r\n        }\r\n        return JSON.parse(text);\r\n    }\r\n    /** Get resource blob as array buffer. */\r\n    async getAsBuffer(blob) {\r\n        return new Promise((resolve, reject) => {\r\n            let reader = new FileReader();\r\n            reader.onload = () => {\r\n                resolve(reader.result);\r\n            };\r\n            reader.onerror = err => {\r\n                reject(err);\r\n            };\r\n            reader.readAsArrayBuffer(blob);\r\n        });\r\n    }\r\n    /**\r\n     * Get resource as image.\r\n     * Never forget to detach blob url of the image after not use it anymore.\r\n     */\r\n    async getAsImage(blob) {\r\n        return new Promise((resolve, reject) => {\r\n            let blobURL = URL.createObjectURL(blob);\r\n            let img = new Image();\r\n            img.src = blobURL;\r\n            img.onload = () => resolve(img);\r\n            img.onerror = err => reject(err);\r\n        });\r\n    }\r\n    /**\r\n     * Get resource blob as audio element.\r\n     * Never forget to detach blob url of the image after not use it anymore.\r\n     */\r\n    async getAsAudio(blob) {\r\n        return new Promise((resolve, reject) => {\r\n            let blobURL = URL.createObjectURL(blob);\r\n            let audio = document.createElement('audio');\r\n            audio.preload = 'auto';\r\n            audio.oncanplaythrough = () => {\r\n                resolve(audio);\r\n            };\r\n            audio.onerror = err => {\r\n                reject(err);\r\n            };\r\n            audio.src = blobURL;\r\n        });\r\n    }\r\n    /**\r\n     * Get resource blob as video element.\r\n     * Never forget to detach blob url of the image after not use it anymore.\r\n     */\r\n    async getAsVideo(blob) {\r\n        return new Promise((resolve, reject) => {\r\n            let blobURL = URL.createObjectURL(blob);\r\n            let video = document.createElement('video');\r\n            video.preload = 'auto';\r\n            video.oncanplaythrough = () => {\r\n                resolve(video);\r\n            };\r\n            video.onerror = err => {\r\n                reject(err);\r\n            };\r\n            video.src = blobURL;\r\n        });\r\n    }\r\n}\r\nexports.ResourceLoader = ResourceLoader;\r\n/** Default loader to load miscellaneous resources. */\r\nexports.loader = new ResourceLoader();\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.useQuery = exports.parseQuery = void 0;\r\n/**\r\n * Parse `url` search part to a query parameter object.\r\n * @param url The url to parse query parameters.\r\n */\r\nfunction parseQuery(url) {\r\n    let match = url.match(/\\?(.+)/);\r\n    let pieces = match ? match[1].split('&') : [];\r\n    let query = {};\r\n    for (let piece of pieces) {\r\n        let [key, value] = piece.split('=');\r\n        if (key) {\r\n            value = decodeURIComponent(value || '');\r\n            query[key] = value;\r\n        }\r\n    }\r\n    return query;\r\n}\r\nexports.parseQuery = parseQuery;\r\n/**\r\n * Combine base `url` and `query` parameters to a new URL.\r\n * @param url The base url.\r\n * @param query The query parameter object.\r\n */\r\nfunction useQuery(url, query) {\r\n    let hasQuery = url.includes('?');\r\n    if (typeof query === 'string') {\r\n        return url + (hasQuery ? '&' : '?') + query;\r\n    }\r\n    else if (query && typeof query === 'object') {\r\n        for (let key in query) {\r\n            let value = encodeURIComponent(query[key]);\r\n            url += (hasQuery ? '&' : '?') + key + '=' + value;\r\n            hasQuery = true;\r\n        }\r\n    }\r\n    return url;\r\n}\r\nexports.useQuery = useQuery;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.scrollToTop = exports.getScrollOffset = exports.getScrollDirection = exports.scrollToView = exports.getClosestScrollWrapper = exports.getScrollbarWidth = exports.isContentOverflow = void 0;\r\nconst animate_1 = require(\"./animate\");\r\n/**\r\n * Returns if content of element overflow and element is scrollable.\r\n * May return `true` although element has no scroll bar.\r\n * Note that this method may cause reflow.\r\n * @param el The element to check overflow state.\r\n */\r\nfunction isContentOverflow(el) {\r\n    return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth;\r\n}\r\nexports.isContentOverflow = isContentOverflow;\r\n/** Cached scroll bar width. */\r\nlet scrollBarWidth = null;\r\n/**\r\n * Get scroll bar width.\r\n * After first time running, the returned value will keep unchanged.\r\n * Note that this method will cause reflow for the first time.\r\n */\r\nfunction getScrollbarWidth() {\r\n    if (scrollBarWidth !== null) {\r\n        return scrollBarWidth;\r\n    }\r\n    let div = document.createElement('div');\r\n    div.style.cssText = 'width:100px; height:100px; overflow:scroll; position:absolute; left:-100px; top:-100px;';\r\n    document.body.append(div);\r\n    scrollBarWidth = div.offsetWidth - div.clientWidth;\r\n    div.remove();\r\n    return scrollBarWidth;\r\n}\r\nexports.getScrollbarWidth = getScrollbarWidth;\r\n/**\r\n * Find the closest scroll wrapper, which has `overflow: auto / scroll` set.\r\n * Note that this method may cause reflow.\r\n * @param el The element to check scroll wrapper.\r\n */\r\nfunction getClosestScrollWrapper(el) {\r\n    while (el\r\n        && el.scrollWidth <= el.clientWidth\r\n        && el.scrollHeight <= el.clientHeight) {\r\n        el = el.parentElement;\r\n    }\r\n    return el;\r\n}\r\nexports.getClosestScrollWrapper = getClosestScrollWrapper;\r\n/**\r\n * Scroll scrollbars of closest scroll wrapper for minimal distance to make element be fully visible.\r\n * Returns `true` if scrolled.\r\n * @param el The element you want to see.\r\n * @param gap Keep a little distance from the element's edge to the viewport's edge.\r\n * @param duration If specified, will run an animation when scrolling.\r\n * @param easing The animation esing.\r\n */\r\nfunction scrollToView(el, gap = 0, duration = 0, easing = 'ease-out') {\r\n    let wrapper = getClosestScrollWrapper(el);\r\n    if (!wrapper) {\r\n        return false;\r\n    }\r\n    let direction = getScrollDirection(wrapper);\r\n    if (!direction) {\r\n        return false;\r\n    }\r\n    if (direction === 'y') {\r\n        let oldScrollY = wrapper.scrollTop;\r\n        let newScrollY = null;\r\n        let offsetY = getScrollOffset(el, wrapper, direction);\r\n        // Needs to scroll for pxs to top edges align\r\n        let topOffset = offsetY - gap - oldScrollY;\r\n        // Needs to scroll for pxs to bottom edges align\r\n        let botOffset = offsetY + el.offsetHeight + gap - wrapper.clientHeight - oldScrollY;\r\n        // Needs to scroll up\r\n        if (topOffset < 0 && botOffset < 0) {\r\n            newScrollY = Math.max(topOffset, botOffset) + oldScrollY;\r\n        }\r\n        // Needs to scroll down\r\n        else if (botOffset > 0 && topOffset > 0) {\r\n            newScrollY = Math.min(botOffset, topOffset) + oldScrollY;\r\n        }\r\n        if (newScrollY !== null && newScrollY !== oldScrollY) {\r\n            if (duration) {\r\n                animate_1.animateStyleValueTo(wrapper, 'scrollTop', newScrollY, duration, easing);\r\n            }\r\n            else {\r\n                wrapper.scrollTop = newScrollY;\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    if (direction === 'x') {\r\n        let offsetX = getScrollOffset(el, wrapper, direction);\r\n        let scrollX = wrapper.scrollLeft;\r\n        let newScrollX = 0;\r\n        let startOffset = offsetX - gap - scrollX;\r\n        let endOffset = offsetX + el.offsetWidth + gap - scrollX - wrapper.clientWidth;\r\n        if (startOffset < 0 && endOffset < 0 || el.offsetWidth > wrapper.clientWidth) {\r\n            newScrollX = Math.max(0, offsetX - gap);\r\n        }\r\n        else if (endOffset > 0 && startOffset > 0) {\r\n            newScrollX = Math.min(wrapper.scrollWidth, offsetX + el.offsetWidth + gap) - wrapper.clientWidth;\r\n        }\r\n        if (newScrollX !== scrollX) {\r\n            if (duration) {\r\n                animate_1.animateStyleValueTo(wrapper, 'scrollLeft', newScrollX, duration, easing);\r\n            }\r\n            else {\r\n                wrapper.scrollLeft = newScrollX;\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexports.scrollToView = scrollToView;\r\n/**\r\n * Get the scroll direction of scroll wrapper, may be `'x' | 'y' | ''`.\r\n * @param wrapper The element to check scroll direction.\r\n */\r\nfunction getScrollDirection(wrapper) {\r\n    let direction = null;\r\n    if (wrapper.scrollHeight > wrapper.clientHeight) {\r\n        direction = 'y';\r\n    }\r\n    else if (wrapper.scrollWidth > wrapper.clientWidth) {\r\n        direction = 'x';\r\n    }\r\n    return direction;\r\n}\r\nexports.getScrollDirection = getScrollDirection;\r\n/**\r\n * Get element's top or left offset from it's scroll wrapper's scrollable start edges,\r\n * which also means the scroll wrapper's scrollTop property value when top edges match.\r\n * This value is not affected by current scroll position.\r\n * @param el The element to test offset.\r\n * @param wrapper The scroll wrapper.\r\n * @param direction The scroll direction, `'x' | 'y'`.\r\n */\r\nfunction getScrollOffset(el, wrapper, direction) {\r\n    let prop = direction === 'x' ? 'offsetLeft' : 'offsetTop';\r\n    let parent = el.offsetParent;\r\n    let y = el[prop];\r\n    if (!parent || parent === wrapper) { }\r\n    else if (parent.contains(wrapper)) {\r\n        y -= wrapper[prop];\r\n    }\r\n    else {\r\n        while (parent.offsetParent && parent.offsetParent !== wrapper) {\r\n            parent = parent.offsetParent;\r\n            y += parent[prop];\r\n        }\r\n    }\r\n    return y;\r\n}\r\nexports.getScrollOffset = getScrollOffset;\r\n/**\r\n * Scroll scrollbars to make element in the top of the viewport area.\r\n * Returns `true` if scrolled.\r\n * @param el The element you want to see.\r\n * @param gap Keep a little distance from the element's edge to the viewport's edge.\r\n * @param duration If specified, will run an animation when scrolling.\r\n * @param easing The animation esing.\r\n */\r\nfunction scrollToTop(el, gap = 0, duration = 0, easing = 'ease-out') {\r\n    let wrapper = getClosestScrollWrapper(el);\r\n    if (!wrapper) {\r\n        return false;\r\n    }\r\n    let offsetY = getScrollOffset(el, wrapper, 'y');\r\n    let oldScrollY = wrapper.scrollTop;\r\n    let newScrollY = Math.max(0, offsetY - gap);\r\n    if (newScrollY !== oldScrollY) {\r\n        if (duration) {\r\n            animate_1.animateStyleValueTo(wrapper, 'scrollTop', newScrollY, duration, easing);\r\n        }\r\n        else {\r\n            wrapper.scrollTop = newScrollY;\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexports.scrollToTop = scrollToTop;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Settings = exports.storage = void 0;\r\nconst emitter_1 = require(\"../base/emitter\");\r\nclass JSONStorage {\r\n    constructor(prefix) {\r\n        /** Key prefix to identify self set local storage properties. */\r\n        this.prefix = '';\r\n        /** Expire suffix of properties to mark expire time. */\r\n        this.expireSuffix = '_expires_';\r\n        /** Supported state cache. */\r\n        this.supported = null;\r\n        this.prefix = prefix;\r\n    }\r\n    /**\r\n     * Test whether local storage is supported.\r\n     * Will return `false` in browser's private mode.\r\n     */\r\n    isSupported() {\r\n        if (this.supported !== null) {\r\n            return this.supported;\r\n        }\r\n        try {\r\n            let key = this.prefix + 'test_supported';\r\n            localStorage[key] = 1;\r\n            delete localStorage[key];\r\n            return true;\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Test whether has set `key` in local storage.\r\n     * @param key The key of the data item.\r\n     */\r\n    has(key) {\r\n        if (!this.isSupported()) {\r\n            return null;\r\n        }\r\n        key = this.prefix + key;\r\n        return key in localStorage;\r\n    }\r\n    get(key, defaultValue = null) {\r\n        if (!this.isSupported()) {\r\n            return null;\r\n        }\r\n        key = this.prefix + key;\r\n        let value = localStorage[key];\r\n        if (value === undefined) {\r\n            return defaultValue;\r\n        }\r\n        if (value && typeof value === 'string') {\r\n            try {\r\n                value = JSON.parse(value);\r\n                let expires = localStorage[key + this.expireSuffix];\r\n                if (expires && expires < Date.now()) {\r\n                    delete localStorage[key];\r\n                    delete localStorage[key + this.expireSuffix];\r\n                    return defaultValue;\r\n                }\r\n                else {\r\n                    return value;\r\n                }\r\n            }\r\n            catch (err) {\r\n                return defaultValue;\r\n            }\r\n        }\r\n        else {\r\n            return defaultValue;\r\n        }\r\n    }\r\n    /**\r\n     * Cache json data into local storage by `key`.\r\n     * Returns `true` if cached.\r\n     * @param key The key of the data item.\r\n     * @param value The json data to cache.\r\n     * @param expires An optional expire time in second.\r\n     */\r\n    set(key, value, expires) {\r\n        if (!this.isSupported()) {\r\n            return null;\r\n        }\r\n        key = this.prefix + key;\r\n        localStorage[key] = JSON.stringify(value);\r\n        if (expires && expires > 0) {\r\n            localStorage[key + this.expireSuffix] = Date.now() + expires * 1000;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Delete cached json data in localStorage by `key`.\r\n     * Returns `true` if deleted.\r\n     * @param key The key of the data item.\r\n     */\r\n    delete(key) {\r\n        if (!this.isSupported()) {\r\n            return null;\r\n        }\r\n        key = this.prefix + key;\r\n        delete localStorage[key + this.expireSuffix];\r\n        return delete localStorage[key];\r\n    }\r\n    /**\r\n     * Returns a new storage to cache data using `namespace` as prefix.\r\n     * @param namespace The prefix of keys.\r\n     */\r\n    group(namespace) {\r\n        return new JSONStorage(this.prefix + '_' + namespace);\r\n    }\r\n}\r\n/** Like `LocalStorage` very much, except here it read and write JSON datas. */\r\nexports.storage = new JSONStorage('_ff_');\r\n/** Used to caches settings, can restore them after reload page. */\r\nclass Settings extends emitter_1.Emitter {\r\n    constructor(storageKey, defaultData) {\r\n        super();\r\n        this.willSave = false;\r\n        this.storageKey = storageKey;\r\n        this.defaultData = defaultData;\r\n        this.initializeDate();\r\n    }\r\n    initializeDate() {\r\n        let defaultKeys = Object.keys(this.defaultData);\r\n        let storageData = this.getStorageData();\r\n        // Key must exist in default data.\r\n        if (storageData) {\r\n            for (let key of Object.keys(storageData)) {\r\n                if (!defaultKeys.includes(key)) {\r\n                    delete (storageData[key]);\r\n                }\r\n            }\r\n        }\r\n        this.storageData = storageData || {};\r\n    }\r\n    /** Returns whether have set this property. */\r\n    has(key) {\r\n        return this.storageData.hasOwnProperty(key);\r\n    }\r\n    /** Get setting value by key. */\r\n    get(key) {\r\n        if (this.has(key)) {\r\n            return this.storageData[key];\r\n        }\r\n        else {\r\n            return this.defaultData[key];\r\n        }\r\n    }\r\n    /** Set setting value by key. */\r\n    set(key, value) {\r\n        if (value !== this.storageData[key] || typeof value === 'object') {\r\n            this.storageData[key] = value;\r\n            this.saveStorageData();\r\n            this.emit('change', key);\r\n        }\r\n    }\r\n    /** Delete a storage value by it's key. */\r\n    delete(key) {\r\n        if (this.has(key)) {\r\n            delete this.storageData[key];\r\n            this.saveStorageData();\r\n        }\r\n    }\r\n    /** Get raw data from local storage. */\r\n    getStorageData() {\r\n        return exports.storage.get(this.storageKey);\r\n    }\r\n    /** Save data to local storage, note it doesn't save immediately. */\r\n    saveStorageData() {\r\n        if (!this.willSave) {\r\n            Promise.resolve().then(() => {\r\n                this.saveStorageDataImmediately();\r\n                this.willSave = false;\r\n            });\r\n            this.willSave = true;\r\n        }\r\n    }\r\n    /** Save data to local storage, note it doesn't save immediately. */\r\n    saveStorageDataImmediately() {\r\n        exports.storage.set(this.storageKey, this.storageData);\r\n    }\r\n}\r\nexports.Settings = Settings;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.setStyleValues = exports.setStyleValue = exports.getStyleValue = exports.getStyleValueAsNumber = void 0;\r\nconst utils_1 = require(\"./utils\");\r\n/**\r\n * Get computed style value as number from element.\r\n * Note that this method may cause reflow.\r\n * @param el The element to get numeric value.\r\n * @param property The property name in camer case, `backgroundColor` as example.\r\n */\r\nfunction getStyleValueAsNumber(el, property) {\r\n    let value = getStyleValue(el, property);\r\n    return value ? parseFloat(value) || 0 : 0;\r\n}\r\nexports.getStyleValueAsNumber = getStyleValueAsNumber;\r\n/**\r\n * Get computed style value from element.\r\n * Note that this method may cause reflow.\r\n * @param el The element to get style value.\r\n * @param propertyName The property name in camer case, `backgroundColor` as example.\r\n */\r\nfunction getStyleValue(el, propertyName) {\r\n    return getComputedStyle(el)[propertyName];\r\n}\r\nexports.getStyleValue = getStyleValue;\r\n/**\r\n * Set value of specified `property` for element.\r\n * @param el The element to set CSS value.\r\n * @param propertyName The property name in camel case. `backgroundColor` as example.\r\n * @param value The value in string or number type. E.g.: value `100` for `width` property wil be fixed to `100px`.\r\n */\r\nfunction setStyleValue(el, propertyName, value) {\r\n    el.style.setProperty(propertyName, utils_1.normativeStyleValue(propertyName, value));\r\n}\r\nexports.setStyleValue = setStyleValue;\r\n/**\r\n * Assign styles whose properties and values specified by `propertyMap` to element.\r\n * @param el The element to set CSS values.\r\n * @param propertyMap The property name in camel case, `backgroundColor` as example.\r\n */\r\nfunction setStyleValues(el, propertyMap) {\r\n    for (let prop of Object.keys(propertyMap)) {\r\n        setStyleValue(el, prop, propertyMap[prop]);\r\n    }\r\n}\r\nexports.setStyleValues = setStyleValues;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ensureDocumentComplete = exports.ensureWindowLoaded = void 0;\r\n/**\r\n * Returns a promise which will be resolved after window loaded,\r\n * or resolved immediately if window is already loaded.\r\n */\r\nfunction ensureWindowLoaded() {\r\n    return new Promise(resolve => {\r\n        let entrys = window.performance.getEntriesByType(\"navigation\");\r\n        if (entrys.length > 0 && entrys[0].loadEventEnd > 0) {\r\n            resolve();\r\n        }\r\n        else {\r\n            window.addEventListener('load', () => resolve());\r\n        }\r\n    });\r\n}\r\nexports.ensureWindowLoaded = ensureWindowLoaded;\r\n/**\r\n * Returns a promise which will be resolved after document completed,\r\n * or resolved immediately if document is already completed.\r\n */\r\nfunction ensureDocumentComplete() {\r\n    return new Promise(resolve => {\r\n        let entrys = window.performance.getEntriesByType(\"navigation\");\r\n        if (entrys.length > 0 && entrys[0].domContentLoadedEventEnd > 0) {\r\n            resolve();\r\n        }\r\n        else {\r\n            document.addEventListener('DOMContentLoaded', () => resolve(), false);\r\n        }\r\n    });\r\n}\r\nexports.ensureDocumentComplete = ensureDocumentComplete;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.normativeStyleObject = exports.normativeStyleValue = void 0;\r\n/** Format number type value to a standard style value. */\r\nfunction normativeStyleValue(property, value) {\r\n    if (typeof value === 'number' && /(?:width|height|left|right|top|bottom|size)$/i.test(property)) {\r\n        value = value + 'px';\r\n    }\r\n    else {\r\n        value = value.toString();\r\n    }\r\n    return value;\r\n}\r\nexports.normativeStyleValue = normativeStyleValue;\r\n/** Format number type value of the object to a standard style value. */\r\nfunction normativeStyleObject(styleObject) {\r\n    for (let property of Object.keys(styleObject)) {\r\n        styleObject[property] = normativeStyleValue(property, styleObject[property]);\r\n    }\r\n    return styleObject;\r\n}\r\nexports.normativeStyleObject = normativeStyleObject;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LayoutWatcher = exports.watchLayoutUntil = exports.watchLayoutOnce = exports.watchLayout = void 0;\r\nconst base_1 = require(\"../base\");\r\nconst element_1 = require(\"./element\");\r\nconst WatchStateFns = {\r\n    show(el) {\r\n        return el.offsetWidth > 0 || el.offsetHeight > 0;\r\n    },\r\n    hide(el) {\r\n        return el.offsetWidth === 0 && el.offsetHeight === 0;\r\n    },\r\n    inview(el) {\r\n        return element_1.isVisibleInViewport(el);\r\n    },\r\n    outview(el) {\r\n        return !element_1.isVisibleInViewport(el);\r\n    },\r\n    size(el) {\r\n        return {\r\n            width: el.clientWidth,\r\n            height: el.clientHeight,\r\n        };\r\n    },\r\n    rect(el) {\r\n        return element_1.getRect(el);\r\n    },\r\n};\r\n/**\r\n * Watch specified layout state, trigger `callback` if state changed.\r\n * Note that this method may slow page speed and cause additional reflow.\r\n * @param el The element to watch.\r\n * @param type Watch state type, can be `show | hide | inview | outview | size | rect`.\r\n * @param callback The callback to call when state changed.\r\n * @returns A cancel function.\r\n */\r\nfunction watchLayout(el, type, callback) {\r\n    let watcher = new LayoutWatcher(el, type, callback);\r\n    watcher.watch();\r\n    return watcher.unwatch.bind(watcher);\r\n}\r\nexports.watchLayout = watchLayout;\r\n/**\r\n * Watch specified layout state, trigger `callback` if it changed for only once.\r\n * Note that this method may slow page speed and cause additional reflow.\r\n * @param el The element to watch.\r\n * @param type Watch state type, can be `show | hide | inview | outview | size | rect`.\r\n * @param callback The callback to call when state changed.\r\n * @returns A cancel function.\r\n */\r\nfunction watchLayoutOnce(el, type, callback) {\r\n    let watcher = new LayoutWatcher(el, type, callback, { once: true });\r\n    watcher.watch();\r\n    return watcher.unwatch.bind(watcher);\r\n}\r\nexports.watchLayoutOnce = watchLayoutOnce;\r\n/**\r\n * Watch specified layout state, trigger `callback` if the state becomes `true` and never trigger again.\r\n * Note that this method may slow page speed and cause additional reflow.\r\n * @param el The element to watch.\r\n * @param type Watch state type, can be `show | hide | inview | outview`.\r\n * @param callback The callback to call when state becomes `true`.\r\n * @returns A cancel function.\r\n */\r\nfunction watchLayoutUntil(el, type, callback) {\r\n    let watcher = new LayoutWatcher(el, type, callback, { untilTrue: true });\r\n    watcher.watch();\r\n    return watcher.unwatch.bind(watcher);\r\n}\r\nexports.watchLayoutUntil = watchLayoutUntil;\r\nclass LayoutWatcher {\r\n    constructor(el, type, callback, options = {}) {\r\n        this.observer = null;\r\n        this.frameId = null;\r\n        this.interval = null;\r\n        this.oldState = null;\r\n        this.unwatchChange = null;\r\n        this.el = el;\r\n        this.type = type;\r\n        this.callback = callback;\r\n        this.options = options;\r\n        this.getState = WatchStateFns[type];\r\n    }\r\n    /** Begin to watch. */\r\n    watch() {\r\n        this.resetState();\r\n        if (this.type === 'size' && typeof window.ResizeObserver === 'function' && !this.options.intervalTime) {\r\n            this.observer = new window.ResizeObserver(this.onResize.bind(this));\r\n            this.observer.observe(this.el);\r\n        }\r\n        else if ((this.type === 'inview' || this.type === 'outview') && typeof IntersectionObserver === 'function' && !this.options.intervalTime) {\r\n            this.observer = new IntersectionObserver(this.onInviewChange.bind(this));\r\n            this.observer.observe(this.el);\r\n        }\r\n        else if (this.options.intervalTime) {\r\n            this.interval = new base_1.Interval(this.checkStateInInterval.bind(this), this.options.intervalTime);\r\n        }\r\n        else if (this.options.checkInAnimationFrame) {\r\n            this.frameId = requestAnimationFrame(this.checkStateInAnimationFrame.bind(this));\r\n        }\r\n        else {\r\n            this.unwatchChange = watchDocumentChange(this.checkStateInInterval.bind(this));\r\n        }\r\n    }\r\n    /** End watch. */\r\n    unwatch() {\r\n        var _a, _b;\r\n        if (this.observer) {\r\n            this.observer.disconnect();\r\n        }\r\n        else if (this.options.intervalTime) {\r\n            (_a = this.interval) === null || _a === void 0 ? void 0 : _a.cancel();\r\n        }\r\n        else if (this.options.checkInAnimationFrame) {\r\n            if (this.frameId) {\r\n                cancelAnimationFrame(this.frameId);\r\n            }\r\n        }\r\n        else {\r\n            (_b = this.unwatchChange) === null || _b === void 0 ? void 0 : _b.call(this);\r\n        }\r\n    }\r\n    onResize(entries) {\r\n        for (let { contentRect } of entries) {\r\n            this.onNewState({\r\n                width: contentRect.width,\r\n                height: contentRect.height\r\n            });\r\n        }\r\n    }\r\n    onInviewChange(entries) {\r\n        for (let { intersectionRatio } of entries) {\r\n            let newState = this.type === 'inview' ? intersectionRatio > 0 : intersectionRatio === 0;\r\n            this.onNewState(newState);\r\n        }\r\n    }\r\n    checkStateInAnimationFrame() {\r\n        let newState = this.getState(this.el);\r\n        this.onNewState(newState);\r\n        this.frameId = requestAnimationFrame(this.checkStateInAnimationFrame.bind(this));\r\n    }\r\n    checkStateInInterval() {\r\n        let newState = this.getState(this.el);\r\n        this.onNewState(newState);\r\n    }\r\n    onNewState(newState) {\r\n        if (!this.isValueOrObjectEqual(newState, this.oldState)) {\r\n            this.oldState = newState;\r\n            this.callback(newState);\r\n            if (this.options.once || this.options.untilTrue && newState) {\r\n                this.unwatch();\r\n            }\r\n        }\r\n    }\r\n    isValueOrObjectEqual(a, b) {\r\n        if (a === b) {\r\n            return true;\r\n        }\r\n        if (typeof a !== 'object' || typeof b !== 'object' || !a || !b) {\r\n            return false;\r\n        }\r\n        let keysA = Object.keys(a);\r\n        let keysB = Object.keys(b);\r\n        if (keysA.length !== keysB.length) {\r\n            return false;\r\n        }\r\n        for (let key of keysA) {\r\n            if (!b.hasOwnProperty(key)) {\r\n                return false;\r\n            }\r\n            let valueA = a[key];\r\n            let valueB = b[key];\r\n            if (valueA !== valueB) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Check state manually.\r\n     * Don't forget to call `resetState` before begin to check state.\r\n     */\r\n    checkState() {\r\n        let newState = this.getState(this.el);\r\n        if (!this.isValueOrObjectEqual(newState, this.oldState)) {\r\n            this.oldState = newState;\r\n            this.callback(newState);\r\n        }\r\n    }\r\n    /** Reset current state. */\r\n    resetState() {\r\n        this.oldState = this.getState(this.el);\r\n    }\r\n}\r\nexports.LayoutWatcher = LayoutWatcher;\r\nlet mutationObserver = null;\r\nlet mutationObserverCallbacks = [];\r\nlet willEmitDocumentChange = false;\r\nfunction watchDocumentChange(callback) {\r\n    if (!mutationObserver) {\r\n        mutationObserver = new MutationObserver(emitDocumentChangeLater);\r\n        mutationObserver.observe(document.documentElement, { subtree: true, childList: true, attributes: true });\r\n    }\r\n    if (mutationObserverCallbacks.length === 0) {\r\n        window.addEventListener('resize', emitDocumentChangeLater);\r\n        window.addEventListener('wheel', emitDocumentChangeLater);\r\n    }\r\n    mutationObserverCallbacks.push(callback);\r\n    return () => {\r\n        unwatchDocumentChange(callback);\r\n    };\r\n}\r\nfunction unwatchDocumentChange(callback) {\r\n    mutationObserverCallbacks = mutationObserverCallbacks.filter(v => v !== callback);\r\n    if (mutationObserverCallbacks.length === 0 && mutationObserver) {\r\n        mutationObserver.disconnect();\r\n        mutationObserver = null;\r\n    }\r\n    if (mutationObserverCallbacks.length === 0) {\r\n        window.removeEventListener('resize', emitDocumentChangeLater);\r\n        window.removeEventListener('wheel', emitDocumentChangeLater);\r\n    }\r\n}\r\nfunction emitDocumentChangeLater() {\r\n    if (!willEmitDocumentChange) {\r\n        requestAnimationFrame(emitDocumentChange);\r\n        willEmitDocumentChange = true;\r\n    }\r\n}\r\nfunction emitDocumentChange() {\r\n    for (let callback of mutationObserverCallbacks) {\r\n        callback();\r\n    }\r\n    willEmitDocumentChange = false;\r\n}\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__exportStar(require(\"./base\"), exports);\r\n__exportStar(require(\"./dom\"), exports);\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ClassNameBinding = void 0;\r\nconst define_1 = require(\"./define\");\r\nconst style_parser_1 = require(\"../internals/style-parser\");\r\n/**\r\n * `:class` binding will add class names to current element.\r\n *\r\n * `:class=\"class1 class2\"` - Like class name strings.\r\n * `:class.class-name=${booleanValue}` - Add class name if booleanValue is `true`.\r\n * `:class=${[class1, class2]}` - Add multiply class names from array.\r\n * `:class=${{class1: value1, class2: value2}}` - Add multiply class names from their mapped boolean values.\r\n */\r\nlet ClassNameBinding = class ClassNameBinding {\r\n    constructor(el, context, modifiers) {\r\n        this.lastClassNames = [];\r\n        if (modifiers) {\r\n            if (modifiers.length > 1) {\r\n                throw new Error(`Modifier \"${modifiers.join('.')}\" is not allowed, at most one modifier as class name can be specified for \":class\"!`);\r\n            }\r\n            if (!/^\\$?[\\w-]+$/.test(modifiers[0])) {\r\n                throw new Error(`Modifier \"${modifiers[0]}\" is not a valid class name!`);\r\n            }\r\n        }\r\n        this.el = el;\r\n        this.modifiers = modifiers;\r\n        this.scopeName = (context === null || context === void 0 ? void 0 : context.el.localName) || '';\r\n        this.scopedClassNames = this.scopeName ? style_parser_1.getScopedClassNames(this.scopeName) : undefined;\r\n    }\r\n    update(value) {\r\n        let newClassNames = [];\r\n        if (value) {\r\n            newClassNames = this.parseClass(value);\r\n        }\r\n        for (let name of this.lastClassNames) {\r\n            if (!newClassNames.includes(name)) {\r\n                this.el.classList.remove(name);\r\n            }\r\n        }\r\n        for (let name of newClassNames) {\r\n            if (!this.lastClassNames.includes(name)) {\r\n                this.el.classList.add(name);\r\n            }\r\n        }\r\n        this.lastClassNames = newClassNames;\r\n    }\r\n    parseClass(value) {\r\n        let o = {};\r\n        if (this.modifiers) {\r\n            if (value) {\r\n                o[this.modifiers[0]] = true;\r\n            }\r\n        }\r\n        else if (Array.isArray(value)) {\r\n            for (let name of value) {\r\n                o[name] = true;\r\n            }\r\n        }\r\n        else if (value && typeof value === 'object') {\r\n            for (let key of Object.keys(value)) {\r\n                o[key] = !!value[key];\r\n            }\r\n        }\r\n        else if (typeof value === 'string') {\r\n            for (let name of value.split(/\\s+/)) {\r\n                if (name) {\r\n                    o[name] = true;\r\n                }\r\n            }\r\n        }\r\n        let names = [];\r\n        for (let name in o) {\r\n            if (o[name]) {\r\n                if (this.scopedClassNames && this.scopedClassNames.has(name)) {\r\n                    name = name + '__' + this.scopeName;\r\n                }\r\n                names.push(name);\r\n            }\r\n        }\r\n        return names;\r\n    }\r\n    remove() {\r\n        if (this.lastClassNames) {\r\n            this.el.classList.remove(...this.lastClassNames);\r\n        }\r\n    }\r\n};\r\nClassNameBinding = __decorate([\r\n    define_1.defineBinding('class')\r\n], ClassNameBinding);\r\nexports.ClassNameBinding = ClassNameBinding;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.refBinding = exports.BindingReferences = exports.BindingResult = exports.defineBinding = void 0;\r\nconst references_1 = require(\"../helpers/references\");\r\n/** Cache all binding classes. */\r\nconst DefinedBindingMap = new Map();\r\nfunction defineBinding(name, Binding) {\r\n    if (DefinedBindingMap.has(name)) {\r\n        console.warn(`You are trying to overwrite binding definition \"${name}\"`);\r\n    }\r\n    if (Binding) {\r\n        DefinedBindingMap.set(name, Binding);\r\n        return function (...args) {\r\n            return new BindingResult(name, ...args);\r\n        };\r\n    }\r\n    else {\r\n        return (Binding) => {\r\n            return defineBinding(name, Binding);\r\n        };\r\n    }\r\n}\r\nexports.defineBinding = defineBinding;\r\n/**\r\n * Returned from calling defined bindings like `show(...)`, `hide(...)`.\r\n * Used to cache parameters and update template later.\r\n * @typeparam A parameters type.\r\n */\r\nclass BindingResult {\r\n    constructor(name, ...args) {\r\n        this.name = name;\r\n        this.args = args;\r\n    }\r\n}\r\nexports.BindingResult = BindingResult;\r\n/** Class to help handle reference from binding result to it's binding class. */\r\nclass BindingReferencesClass extends references_1.ResultReferences {\r\n    /** Calls reference callback when binging instance created. */\r\n    createFromResult(el, context, result, modifiers) {\r\n        let BindingConstructor = DefinedBindingMap.get(result.name);\r\n        if (!BindingConstructor) {\r\n            throw new Error(`\":${result.name}\" on \"<${el.localName}>\" is not a registered binding class!`);\r\n        }\r\n        let binding = new BindingConstructor(el, context, modifiers);\r\n        this.createReference(result, binding);\r\n        binding.update(...result.args);\r\n        return binding;\r\n    }\r\n}\r\nexports.BindingReferences = new BindingReferencesClass();\r\n/**\r\n * Reference binding instance after it created and before updating.\r\n * Use it like:\r\n * ```ts\r\n * <tag refBinding(show(...))>\r\n * ```\r\n *\r\n * @param result The binding result like `show(...)`.\r\n * @param ref Callback after binding instance was just created and not update yet.\r\n * @param unref Callback after binding instance was removed directly, not calls when was contained in a removed template.\r\n * @return The `result` parameter.\r\n */\r\nfunction refBinding(result, ref, unref) {\r\n    exports.BindingReferences.addReference(result, ref);\r\n    if (unref) {\r\n        exports.BindingReferences.addUnReference(result, unref);\r\n    }\r\n    return result;\r\n}\r\nexports.refBinding = refBinding;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DisabledBinding = exports.EnableBinding = void 0;\r\nconst define_1 = require(\"./define\");\r\n/**\r\n * `:enable` binding will set `disabled` state for element if it's binded value is `false`.\r\n *\r\n * `:enable=${booleanValue}`\r\n */\r\nlet EnableBinding = class EnableBinding {\r\n    constructor(el) {\r\n        this.el = el;\r\n    }\r\n    update(value) {\r\n        if (value) {\r\n            this.el.removeAttribute('disabled');\r\n        }\r\n        else {\r\n            this.el.setAttribute('disabled', '');\r\n        }\r\n    }\r\n    remove() {\r\n        this.el.removeAttribute('disabled');\r\n    }\r\n};\r\nEnableBinding = __decorate([\r\n    define_1.defineBinding('enable')\r\n], EnableBinding);\r\nexports.EnableBinding = EnableBinding;\r\n/**\r\n * `:disable` binding will set `disabled` state for element if it's binded value is `true`.\r\n *\r\n * `:disable=${booleanValue}`\r\n */\r\nlet DisabledBinding = class DisabledBinding {\r\n    constructor(el) {\r\n        this.el = el;\r\n    }\r\n    update(value) {\r\n        if (value) {\r\n            this.el.setAttribute('disabled', '');\r\n        }\r\n        else {\r\n            this.el.removeAttribute('disabled');\r\n        }\r\n    }\r\n    remove() {\r\n        this.el.removeAttribute('disabled');\r\n    }\r\n};\r\nDisabledBinding = __decorate([\r\n    define_1.defineBinding('disable')\r\n], DisabledBinding);\r\nexports.DisabledBinding = DisabledBinding;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.HTMLBinding = void 0;\r\nconst define_1 = require(\"./define\");\r\n/**\r\n * `:html` binding will update html content for element.\r\n *\r\n * `:html=${InnerHTMLCodes}`\r\n */\r\nlet HTMLBinding = class HTMLBinding {\r\n    constructor(el) {\r\n        this.el = el;\r\n    }\r\n    update(value) {\r\n        this.el.innerHTML = value === null || value === undefined ? '' : String(value);\r\n    }\r\n    remove() {\r\n        this.el.innerHTML = '';\r\n    }\r\n};\r\nHTMLBinding = __decorate([\r\n    define_1.defineBinding('html')\r\n], HTMLBinding);\r\nexports.HTMLBinding = HTMLBinding;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar define_1 = require(\"./define\");\r\nObject.defineProperty(exports, \"defineBinding\", { enumerable: true, get: function () { return define_1.defineBinding; } });\r\nObject.defineProperty(exports, \"BindingResult\", { enumerable: true, get: function () { return define_1.BindingResult; } });\r\nObject.defineProperty(exports, \"BindingReferences\", { enumerable: true, get: function () { return define_1.BindingReferences; } });\r\nObject.defineProperty(exports, \"refBinding\", { enumerable: true, get: function () { return define_1.refBinding; } });\r\n__exportStar(require(\"./show-hide\"), exports);\r\nrequire(\"./class\");\r\nrequire(\"./style\");\r\nrequire(\"./model\");\r\nrequire(\"./ref\");\r\nrequire(\"./ref-component\");\r\nrequire(\"./html\");\r\nrequire(\"./enable-disable\");\r\nrequire(\"./src\");\r\nrequire(\"./show-hide\");\r\nrequire(\"./slot\");\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ModelBinding = void 0;\r\nconst define_1 = require(\"./define\");\r\nconst component_1 = require(\"../component\");\r\nconst dom_event_1 = require(\"../internals/dom-event\");\r\n/** All modifiers for model binding. */\r\nconst AllowedModelModifiers = ['lazy', 'number'];\r\n/**\r\n * `:model` binding will bind inputable element's value with specified property of current component.\r\n *\r\n * `:model=\"propertyName\"` - Bind with property of current component.\r\n * `:model=\"objectProperty.propertyName\"` - Bind with sub property of one object in current component.\r\n * `:model.lazy=\"propertyName\"` - Uses `change` event to update component value, not `input`.\r\n * `:model.number=\"propertyName\"` - Convert input value to number and then update component value.\r\n */\r\nlet ModelBinding = class ModelBinding {\r\n    constructor(el, context, modifiers) {\r\n        /** Is boolean value, `true` for checkbox or radio. */\r\n        this.isBooleanValue = false;\r\n        /** Is `<select multiple>`. */\r\n        this.isMultiSelect = false;\r\n        this.com = null;\r\n        this.unwatch = null;\r\n        if (!context) {\r\n            throw new ReferenceError(`A context must be provided when using \":model=property\"!`);\r\n        }\r\n        if (modifiers) {\r\n            if (modifiers.length > 2) {\r\n                throw new Error(`Modifier \"${modifiers.join('.')}\" is not allowed, at most two modifiers can be specified for \":model\"!`);\r\n            }\r\n            for (let modifier of modifiers) {\r\n                if (!AllowedModelModifiers.includes(modifier)) {\r\n                    throw new Error(`Modifier \"${modifiers}\" is not allowed, it must be one of ${AllowedModelModifiers.map(m => `\"${m}\"`).join(', ')}!`);\r\n                }\r\n            }\r\n        }\r\n        this.el = el;\r\n        this.modifiers = modifiers;\r\n        this.context = context;\r\n        this.isComModel = el.localName.includes('-');\r\n        if (this.isComModel) {\r\n            this.property = 'value'; // will check `checked` property later.\r\n            this.eventName = 'change'; // never be `input`.\r\n        }\r\n        else {\r\n            let isFormField = ['input', 'select', 'textarea'].includes(el.localName);\r\n            let isLazy = modifiers && modifiers[0] === 'lazy';\r\n            this.isBooleanValue = el.localName === 'input' && (el.type === 'checkbox' || el.type === 'radio');\r\n            this.isMultiSelect = el.localName === 'select' && el.multiple;\r\n            if (this.isBooleanValue) {\r\n                this.property = 'checked';\r\n                this.eventName = 'change';\r\n            }\r\n            else if (isFormField) {\r\n                this.property = 'value';\r\n                this.eventName = isLazy ? 'change' : 'input';\r\n            }\r\n            // `div@contendeditable` cant trigger change and blur event but not input event\r\n            else {\r\n                this.property = 'innerHTML';\r\n                this.eventName = isLazy ? 'blur' : 'input';\r\n            }\r\n        }\r\n    }\r\n    // Normally this method should only be called for once.\r\n    update(modelName) {\r\n        if (!modelName || typeof modelName !== 'string') {\r\n            throw new Error(`\"${modelName}\" is not a valid model name!`);\r\n        }\r\n        this.modelName = modelName;\r\n        if (this.isComModel) {\r\n            if (this.com) {\r\n                this.updateComModel();\r\n            }\r\n            else {\r\n                component_1.getComponentEarly(this.el, com => {\r\n                    this.bindComModel(com);\r\n                    this.updateComModel();\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            this.updateElementModel();\r\n            this.watchContextModelValue();\r\n        }\r\n    }\r\n    bindComModel(com) {\r\n        this.com = com;\r\n    }\r\n    updateComModel() {\r\n        let com = this.com;\r\n        // Some component use `checked` property as model value.\r\n        if (com.hasOwnProperty('checked') && typeof com.checked === 'boolean') {\r\n            this.property = 'checked';\r\n        }\r\n        com.on(this.eventName, this.assignModelValueToContext, this);\r\n        this.watchContextModelValue();\r\n    }\r\n    watchContextModelValue() {\r\n        if (this.unwatch) {\r\n            this.unwatch();\r\n        }\r\n        // There is a problem here:\r\n        // When the `:model` part was removed, it can't be unwatch after relatated element removed.\r\n        // `:model` is convient but eval, isn't it?\r\n        this.unwatch = this.context.watchImmediately(this.getModelValueFromContext.bind(this), this.setModelValueToTarget.bind(this));\r\n    }\r\n    getModelValueFromContext() {\r\n        let properties = this.modelName.split('.');\r\n        let value = this.context;\r\n        for (let property of properties) {\r\n            if (value && typeof value === 'object') {\r\n                value = value[property];\r\n            }\r\n            else {\r\n                value = undefined;\r\n                break;\r\n            }\r\n        }\r\n        return value;\r\n    }\r\n    assignModelValueToContext(value) {\r\n        let properties = this.modelName.split('.');\r\n        let object = this.context;\r\n        for (let i = 0; i < properties.length; i++) {\r\n            let property = properties[i];\r\n            if (object && typeof object === 'object') {\r\n                if (i < properties.length - 1) {\r\n                    object = object[property];\r\n                }\r\n                else {\r\n                    object[property] = value;\r\n                }\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    updateElementModel() {\r\n        dom_event_1.on(this.el, this.eventName, this.onEventInputOrChange.bind(this));\r\n    }\r\n    onEventInputOrChange(_e) {\r\n        let value;\r\n        let isNumber = this.modifiers && this.modifiers.includes('number');\r\n        if (this.isMultiSelect) {\r\n            value = Array.from(this.el.options).filter(o => o.selected).map(o => o.value);\r\n            if (isNumber) {\r\n                value = value.map(Number);\r\n            }\r\n        }\r\n        else {\r\n            value = this.el[this.property];\r\n            if (isNumber) {\r\n                value = Number(value);\r\n            }\r\n        }\r\n        this.assignModelValueToContext(value);\r\n    }\r\n    setModelValueToTarget(value) {\r\n        if (this.isComModel) {\r\n            let com = this.com;\r\n            if (com[this.property] !== value) {\r\n                com[this.property] = value;\r\n            }\r\n        }\r\n        else {\r\n            this.setInputValue(value);\r\n        }\r\n    }\r\n    setInputValue(value) {\r\n        if (this.isMultiSelect && !Array.isArray(value)) {\r\n            throw new Error(`:model=\"${this.modelName}\" of select[multiple] requires an array as value!`);\r\n        }\r\n        if (this.isMultiSelect) {\r\n            for (let option of this.el.options) {\r\n                option.selected = value.includes(option.value);\r\n            }\r\n        }\r\n        else {\r\n            let el = this.el;\r\n            value = value === null || value === undefined ? '' : value;\r\n            // Here need to avoid:\r\n            //   input value changed ->\r\n            //   write value to context ->\r\n            //   trigger watcher ->\r\n            //   write same value to input, which may cause cursor position lost.\r\n            // So we must compare the value firstly.\r\n            if (el[this.property] !== value) {\r\n                el[this.property] = value;\r\n            }\r\n        }\r\n    }\r\n    remove() {\r\n        this.setInputValue('');\r\n    }\r\n};\r\nModelBinding = __decorate([\r\n    define_1.defineBinding('model')\r\n], ModelBinding);\r\nexports.ModelBinding = ModelBinding;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RefComponentBinding = void 0;\r\nconst component_1 = require(\"../component\");\r\nconst define_1 = require(\"./define\");\r\n/**\r\n * To reference current element as a `refs` property or captures component and passes to a handler as a parameter.\r\n * Note when references the component may not applied properties and triggers `created`.\r\n *\r\n * `:refComponent=\"name\"`- Reference as a property in current component at `.refs.refName`, note it will be updated everytime after element changed.\r\n * `:refComponent=${this.onRef}` - Call reference function with the component as parameter, note it will be called everytime after element changed.\r\n */\r\nlet RefComponentBinding = class RefComponentBinding {\r\n    constructor(el, context) {\r\n        if (!context) {\r\n            throw new ReferenceError(`A context must be provided when using \":ref\" binding!`);\r\n        }\r\n        this.el = el;\r\n        this.context = context;\r\n    }\r\n    update(value) {\r\n        component_1.getComponentEarly(this.el, (com) => {\r\n            if (com) {\r\n                if (typeof value === 'string') {\r\n                    this.context[value] = com;\r\n                }\r\n                else if (typeof value === 'function') {\r\n                    value.call(this.context, com);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    remove() { }\r\n};\r\nRefComponentBinding = __decorate([\r\n    define_1.defineBinding('refComponent')\r\n], RefComponentBinding);\r\nexports.RefComponentBinding = RefComponentBinding;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RefBinding = void 0;\r\nconst define_1 = require(\"./define\");\r\n/**\r\n * To reference current element as a `refs` property or captures and passes to a handler.\r\n *\r\n * `:ref=\"name\"` - Reference as a value in current component at `.refs.refName`, note it will be updated everytime after element changed.\r\n * `:ref=${this.onRef}` - Call reference function with current element as parameter, note it will be called everytime after element changed.\r\n */\r\nlet RefBinding = class RefBinding {\r\n    constructor(el, context) {\r\n        if (!context) {\r\n            throw new ReferenceError(`A context must be provided when using \":ref\" binding!`);\r\n        }\r\n        this.el = el;\r\n        this.context = context;\r\n    }\r\n    update(value) {\r\n        if (typeof value === 'string') {\r\n            this.context.refs[value] = this.el;\r\n        }\r\n        else if (typeof value === 'function') {\r\n            value.call(this.context, this.el);\r\n        }\r\n    }\r\n    remove() { }\r\n};\r\nRefBinding = __decorate([\r\n    define_1.defineBinding('ref')\r\n], RefBinding);\r\nexports.RefBinding = RefBinding;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.hide = exports.HideBinding = exports.show = exports.ShowBinding = void 0;\r\nconst define_1 = require(\"./define\");\r\nconst contextual_transition_1 = require(\"../internals/contextual-transition\");\r\n/**\r\n * `:show` binding will keep element visible if it's binded value is `true`.\r\n *\r\n * `:show=${anyValue}`\r\n */\r\nclass ShowBinding {\r\n    constructor(el, context) {\r\n        this.value = undefined;\r\n        this.el = el;\r\n        this.transition = new contextual_transition_1.ContextualTransition(context);\r\n    }\r\n    update(value, options) {\r\n        value = !!value;\r\n        this.transition.updateOptions(options);\r\n        if (value !== this.value) {\r\n            if (value) {\r\n                this.el.hidden = false;\r\n                if (this.transition.shouldPlayEnter()) {\r\n                    this.transition.playEnter(this.el);\r\n                }\r\n            }\r\n            else {\r\n                if (this.transition.shouldPlayLeave()) {\r\n                    this.transition.playLeave(this.el).then(finish => {\r\n                        if (finish) {\r\n                            this.el.hidden = true;\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    this.el.hidden = true;\r\n                }\r\n            }\r\n            this.value = value;\r\n        }\r\n    }\r\n    remove() {\r\n        this.el.hidden = false;\r\n    }\r\n}\r\nexports.ShowBinding = ShowBinding;\r\n/**\r\n * `show(...)` binding will keep element visible if it's binded value is `true`.\r\n * You may also use `:show` if no need to specify transition.\r\n *\r\n * `show(visible: any, transition: TransitionOptions)`\r\n * `show(visible: any, options: {transition: TransitionOptions, enterAtStart, leaveAtStart, onend})`\r\n */\r\nexports.show = define_1.defineBinding('show', ShowBinding);\r\n/**\r\n * `:hide` binding will keep element hideen if it's binded value is `true`.\r\n *\r\n * `:hide=${anyValue}`\r\n */\r\nclass HideBinding extends ShowBinding {\r\n    update(value, options) {\r\n        super.update(!value, options);\r\n    }\r\n}\r\nexports.HideBinding = HideBinding;\r\n/**\r\n * `hide()` binding will keep element hideen if it's binded value is `true`.\r\n *\r\n * `hide(hidden: any, transition: TransitionOptions)`\r\n * `hide(hidden: any, options: {transition: TransitionOptions, enterAtStart, leaveAtStart, onend})`\r\n */\r\nexports.hide = define_1.defineBinding('hide', HideBinding);\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SlotBinding = void 0;\r\nconst component_1 = require(\"../component\");\r\nconst define_1 = require(\"./define\");\r\n/**\r\n * Insert current element into closest component at mapped `<slot>` position,\r\n * and also reference current element as a `slots` property.\r\n *\r\n * `:slot=\"slotName\"` - Insert into the position specified by `<slot name=\"slotName\">`.\r\n */\r\nlet SlotBinding = class SlotBinding {\r\n    constructor(el, context) {\r\n        this.el = el;\r\n        this.context = context;\r\n    }\r\n    update(slotName) {\r\n        // Prepared `slots` properties before trigger `created` event.\r\n        component_1.getClosestComponentEarly(this.el, com => {\r\n            // When extend super component and provide `:slot`, use current context as slot context.\r\n            com = com || this.context;\r\n            if (com) {\r\n                this.updateComSlot(slotName, com);\r\n            }\r\n        });\r\n    }\r\n    updateComSlot(slotName, com) {\r\n        if (!com.slots[slotName]) {\r\n            com.slots[slotName] = [];\r\n        }\r\n        com.slots[slotName].push(this.el);\r\n    }\r\n    remove() { }\r\n};\r\nSlotBinding = __decorate([\r\n    define_1.defineBinding('slot')\r\n], SlotBinding);\r\nexports.SlotBinding = SlotBinding;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SrcBinding = void 0;\r\nconst define_1 = require(\"./define\");\r\n/** Caches global loaded URLs. */\r\nconst SrcLoadedURLs = new Set();\r\n/**\r\n * `:src` binding will update the src property of media element.\r\n *\r\n * `:src=${URL}`\r\n *\r\n * Note after reuse an image and reset it's src, it will keep old image until the new one loaded.\r\n */\r\nlet SrcBinding = class SrcBinding {\r\n    constructor(el) {\r\n        /** Current resource location. */\r\n        this.src = '';\r\n        if (el instanceof HTMLMediaElement) {\r\n            throw new Error('\":src\" binding can only binded with HTMLMediaElement!');\r\n        }\r\n        this.el = el;\r\n    }\r\n    update(value) {\r\n        this.src = value;\r\n        if (SrcLoadedURLs.has(value)) {\r\n            this.el.src = value;\r\n        }\r\n        else if (value) {\r\n            this.el.src = '';\r\n            let img = new Image();\r\n            img.onload = () => {\r\n                SrcLoadedURLs.add(value);\r\n                // Must re validate it, or src will be wrongly updated.\r\n                if (value === this.src) {\r\n                    this.el.src = value;\r\n                }\r\n            };\r\n            img.src = value;\r\n        }\r\n        else {\r\n            this.el.src = '';\r\n        }\r\n    }\r\n    remove() {\r\n        this.el.src = '';\r\n    }\r\n};\r\nSrcBinding = __decorate([\r\n    define_1.defineBinding('src')\r\n], SrcBinding);\r\nexports.SrcBinding = SrcBinding;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.StyleBinding = void 0;\r\nconst define_1 = require(\"./define\");\r\n/** All modifiers for style binding. */\r\nconst AllowedStyleModifiers = ['px', 'percent', 'url'];\r\n/**\r\n * `:style` binding will update style values for current element.\r\n *\r\n * `:style=\"normalStyleProperties\"` - Just like normal style properties.\r\n * `:style.style-name=${value}` - Set style value for specified style proeprty.\r\n * `:style.style-name.px=${numberValue}` - Convert numberValue to `?px` and set as style value.\r\n * `:style=${{styleName1: value1, styleName2: value2}}` - Add multiply styles from properties and mapped values.\r\n */\r\nlet StyleBinding = class StyleBinding {\r\n    constructor(el, _context, modifiers) {\r\n        this.lastStyle = {};\r\n        if (modifiers) {\r\n            if (modifiers.length > 2) {\r\n                throw new Error(`Modifier \"${modifiers.join('.')}\" is not allowed, at most two modifiers (as style name property value modifier) can be specified for \":style\"!`);\r\n            }\r\n            if (modifiers.length === 2 && !AllowedStyleModifiers.includes(modifiers[1])) {\r\n                throw new Error(`Modifier \"${modifiers[1]}\" is not allowed, it must be one of ${AllowedStyleModifiers.join(', ')}!`);\r\n            }\r\n            if (!/^[\\w-]+$/.test(modifiers[0]) || AllowedStyleModifiers.includes(modifiers[0])) {\r\n                throw new Error(`Modifier \"${modifiers[0]}\" is not a valid style property!`);\r\n            }\r\n        }\r\n        this.el = el;\r\n        this.modifiers = modifiers;\r\n    }\r\n    update(value) {\r\n        let oldStyleNames = Object.keys(this.lastStyle);\r\n        let newStyle = this.parseStyle(value);\r\n        let newStyleNames = Object.keys(newStyle);\r\n        for (let name of oldStyleNames) {\r\n            if (!newStyleNames.includes(name)) {\r\n                this.el.style[name] = '';\r\n            }\r\n        }\r\n        for (let name of newStyleNames) {\r\n            if (!oldStyleNames.includes(name) || this.lastStyle[name] !== newStyle[name]) {\r\n                this.setStyle(name, newStyle[name]);\r\n            }\r\n        }\r\n        this.lastStyle = newStyle;\r\n    }\r\n    setStyle(name, value) {\r\n        var _a;\r\n        let unit = ((_a = this.modifiers) === null || _a === void 0 ? void 0 : _a[1]) || '';\r\n        if (value === null || value === undefined) {\r\n            value = '';\r\n        }\r\n        else if (unit === 'px') {\r\n            // More units like `s`, `deg` is very rare to use.\r\n            value = value + 'px';\r\n        }\r\n        else if (unit === 'percent') {\r\n            value = value + '%';\r\n        }\r\n        else if (unit === 'url') {\r\n            value = 'url(\"' + value + '\")';\r\n        }\r\n        if (typeof value === 'number') {\r\n            value = value + 'px';\r\n        }\r\n        this.el.style[name] = value;\r\n    }\r\n    parseStyle(style) {\r\n        let o = {};\r\n        if (this.modifiers) {\r\n            if (typeof style === 'string' && style !== '' || typeof style === 'number') {\r\n                o[this.modifiers[0]] = style;\r\n            }\r\n        }\r\n        else if (Array.isArray(style)) {\r\n            for (let item of style.join(';').split(/\\s*;\\s*/)) {\r\n                let [name, value] = item.split(/\\s*:\\s*/);\r\n                if (name && value) {\r\n                    o[name] = value;\r\n                }\r\n            }\r\n        }\r\n        else if (style && typeof style === 'object') {\r\n            o = style;\r\n        }\r\n        else if (style && typeof style === 'string') {\r\n            for (let item of style.split(/\\s*;\\s*/)) {\r\n                let [name, value] = item.split(/\\s*:\\s*/);\r\n                if (name && value) {\r\n                    o[name] = value;\r\n                }\r\n            }\r\n        }\r\n        return o;\r\n    }\r\n    remove() {\r\n        if (this.lastStyle) {\r\n            for (let name of Object.keys(this.lastStyle)) {\r\n                this.el.style[name] = '';\r\n            }\r\n        }\r\n    }\r\n};\r\nStyleBinding = __decorate([\r\n    define_1.defineBinding('style')\r\n], StyleBinding);\r\nexports.StyleBinding = StyleBinding;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Component = void 0;\r\nconst template_1 = require(\"../template\");\r\nconst queue_1 = require(\"../queue\");\r\nconst observer_1 = require(\"../observer\");\r\nconst watchers_1 = require(\"../watchers\");\r\nconst node_anchor_1 = require(\"../internals/node-anchor\");\r\nconst from_element_1 = require(\"./from-element\");\r\nconst life_cycle_1 = require(\"./life-cycle\");\r\nconst internal_event_emitter_1 = require(\"../internals/internal-event-emitter\");\r\nconst style_parser_1 = require(\"../internals/style-parser\");\r\nconst node_range_1 = require(\"../internals/node-range\");\r\nconst updatable_queue_1 = require(\"../queue/helpers/updatable-queue\");\r\n/**\r\n * Super class of all the components, create automacially when element appearance in the document.\r\n * @typeparam E Event interface in `{eventName: (...args) => void}` format.\r\n */\r\nclass Component extends internal_event_emitter_1.InternalEventEmitter {\r\n    constructor(el) {\r\n        super();\r\n        /**\r\n         * Caches referenced elements from `:ref=\"refName\"`.\r\n         * You should redefine the type as `{name: HTMLElement, ...}`.\r\n         */\r\n        this.refs = {};\r\n        /**\r\n         * Caches slot elements from `:slot=\"slotName\"`.\r\n         * You should redefine the type as `{name: HTMLElement[], ...}`.\r\n         */\r\n        this.slots = {};\r\n        /* Whether current component connected with a document. */\r\n        this.__connected = false;\r\n        /** Whether have updated for at least once. */\r\n        this.__updated = false;\r\n        this.__rootPart = null;\r\n        /** `WatcherGroup` instance to cache watchers binded with current component. */\r\n        this.__watcherGroup = null;\r\n        this.el = el;\r\n        this.__restNodeRange = new node_range_1.ContainerRange(el);\r\n        return observer_1.observeComTarget(this);\r\n    }\r\n    /** Called after component created and properties assigned. */\r\n    __emitCreated() {\r\n        // Not called from constructor function because properties of child classes are not prepared yet.\r\n        from_element_1.setElementComponentMap(this.el, this);\r\n        life_cycle_1.emitComponentCreationCallbacks(this.el, this);\r\n        this.onCreated();\r\n        this.emit('created');\r\n    }\r\n    /** Called after connected each time, also after `__emitCreated`. */\r\n    __emitConnected(isFirstTimeConnected) {\r\n        if (!isFirstTimeConnected) {\r\n            if (this.__watcherGroup) {\r\n                this.__watcherGroup.connect();\r\n            }\r\n        }\r\n        this.__connected = true;\r\n        // Why `update` but not `__updateImmediately`?\r\n        // On component connected callbacks, may delete a child elements as element of other components.\r\n        // In this scenorio using `update` will keep it not been updated.\r\n        this.update();\r\n        this.onConnected();\r\n        this.emit('connected');\r\n        life_cycle_1.onComponentConnected(this);\r\n    }\r\n    /** Called after disconnected each time. */\r\n    __emitDisconnected() {\r\n        observer_1.clearDependenciesOf(this);\r\n        if (this.__watcherGroup) {\r\n            this.__watcherGroup.disconnect();\r\n        }\r\n        this.__connected = false;\r\n        this.onDisconnected();\r\n        this.emit('disconnected');\r\n        life_cycle_1.onComponentDisconnected(this);\r\n    }\r\n    /**\r\n     * Called from a global queued stack to do updating.\r\n     * Set `force` to `true` to force updating happens even in a document fragment.\r\n     */\r\n    __updateImmediately(force = false) {\r\n        // Don't update after disconnected, or the watcher will be observed and do meaningless updating.\r\n        if (!(this.__connected || force)) {\r\n            return;\r\n        }\r\n        observer_1.startUpdating(this);\r\n        try {\r\n            let result = this.render();\r\n            observer_1.endUpdating(this);\r\n            if (this.__rootPart) {\r\n                this.__rootPart.update(result);\r\n            }\r\n            else if (result !== null) {\r\n                this.__rootPart = new template_1.NodePart(new node_anchor_1.NodeAnchor(this.el, node_anchor_1.NodeAnchorType.Container), this);\r\n                this.__rootPart.update(result);\r\n            }\r\n        }\r\n        catch (err) {\r\n            observer_1.endUpdating(this);\r\n            console.warn(err);\r\n        }\r\n        if (!this.__updated) {\r\n            this.__updated = true;\r\n            this.onReady();\r\n            this.emit('ready');\r\n        }\r\n        this.onUpdated();\r\n        this.emit('updated');\r\n        queue_1.onRenderComplete(() => {\r\n            this.onRendered();\r\n            this.emit('rendered');\r\n        });\r\n    }\r\n    /**\r\n     * Defines what current component should render.\r\n     * Child class should overwrite this method, normally returns html`...` or string.\r\n     * You can choose to not overwrite `render()` to keep it returns `null`,\r\n     * when you just need one element and don't want to render any child nodes.\r\n     */\r\n    render() {\r\n        return null;\r\n    }\r\n    /**\r\n     * Call this to partially or fully update inner contents asynchronously.\r\n     * Never overwrite this method until you know what you are doing.\r\n     */\r\n    update() {\r\n        queue_1.enqueueUpdatableInOrder(this, this, updatable_queue_1.UpdatableUpdateOrder.Component);\r\n    }\r\n    /**\r\n     * Called when component instance was just created and all properties assigned.\r\n     * All the child nodes that belongs to parent context but contained in current component are prepared.\r\n     * But self child nodes, `slots`, `refs`, events are not prepared until `onReady`.\r\n     * You may change some data or visit parent nodes, or register events when `onCreated`.\r\n     */\r\n    onCreated() { }\r\n    /**\r\n     * Called after all the data, child nodes are prepared, but child components are not prepared.\r\n     * Later it will keep updating other components, so don't check computed styles on child nodes.\r\n     * If need so, uses `onRenderComplete` or `untilRenderComplete`.\r\n     * You may visit or adjust child nodes or register more events when `onReady`.\r\n     */\r\n    onReady() { }\r\n    /**\r\n     * Called after every time all the data and child nodes updated.\r\n     * Seam with `onReady`, child components may not been updated yet,\r\n     * so don't check computed styles on child nodes.\r\n     * If need so, uses `onRenderComplete` or `untilRenderComplete`.\r\n     * You may reset some properties or capture some nodes dynamically here,\r\n     * but normally you don't need to.\r\n     */\r\n    onUpdated() { }\r\n    /**\r\n     * Called after all the data and child nodes, components updated.\r\n     * You can visit computed styles of elemenets event component elemenet now.\r\n     */\r\n    onRendered() { }\r\n    /**\r\n     * Called when root element was inserted into document.\r\n     * This will be called for each time you insert the element into document.\r\n     * If you need to register global listeners like `resize` when element in document, restore them here.\r\n     */\r\n    onConnected() { }\r\n    /**\r\n     * Called when root element removed from document.\r\n     * This will be called for each time you removed the element into document.\r\n     * If you register global listeners like `resize`, don't forget to unregister them here.\r\n     */\r\n    onDisconnected() { }\r\n    /** Returns promise which will be resolved after component is ready. */\r\n    async untilReady() {\r\n        if (this.__updated) {\r\n            return;\r\n        }\r\n        else {\r\n            return new Promise(resolve => {\r\n                this.once('ready', resolve);\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Watchs returned value of `fn` and calls `callback` with this value as parameter after the value changed.\r\n     * Will set callback scope as current component.\r\n     */\r\n    watch(fn, callback) {\r\n        return this.__getWatcherGroup().watch(fn, callback.bind(this));\r\n    }\r\n    /**\r\n     * Watchs returned value of `fn` and calls `callback` with this value as parameter after the value changed.\r\n     * Will call `callback` immediately.\r\n     * Will set callback scope as current component.\r\n     */\r\n    watchImmediately(fn, callback) {\r\n        return this.__getWatcherGroup().watchImmediately(fn, callback.bind(this));\r\n    }\r\n    /**\r\n     * Watchs returned value of `fn` and calls `callback` with this value as parameter after the value changed.\r\n     * Calls `callback` for only once.\r\n     * Will set callback scope as current component.\r\n     */\r\n    watchOnce(fn, callback) {\r\n        return this.__getWatcherGroup().watchOnce(fn, callback.bind(this));\r\n    }\r\n    /**\r\n     * Watchs returned value of `fn` and calls `callback` with this value as parameter after the value becomes true like.\r\n     * Will set callback scope as current component.\r\n     */\r\n    watchUntil(fn, callback) {\r\n        return this.__getWatcherGroup().watchUntil(fn, callback.bind(this));\r\n    }\r\n    /** Ensure `__watcherGroup` to be initialized. */\r\n    __getWatcherGroup() {\r\n        if (!this.__watcherGroup) {\r\n            this.__watcherGroup = new watchers_1.WatcherGroup(this);\r\n        }\r\n        return this.__watcherGroup;\r\n    }\r\n    /** Update all watchers binded with current component. */\r\n    __updateWatcherGroup() {\r\n        // Why didn't update watcher group just in `com.__updateImmediately()`:\r\n        // Component collect dependencies and trigger updating when required,\r\n        // while watcher group do the similar things and runs indenpent.\r\n        // They should not affect each other.\r\n        if (this.__watcherGroup) {\r\n            this.__watcherGroup.update();\r\n        }\r\n    }\r\n    /** returns scoped class name E `.name -> .name__com-name` */\r\n    scopeClassName(className) {\r\n        let startsWithDot = className[0] === '.';\r\n        let classNameWithoutDot = startsWithDot ? className.slice(1) : className;\r\n        let scopedClassNameSet = style_parser_1.getScopedClassNames(this.el.localName);\r\n        if (scopedClassNameSet && scopedClassNameSet.has(classNameWithoutDot)) {\r\n            return className + '__' + this.el.localName;\r\n        }\r\n        else {\r\n            return className;\r\n        }\r\n    }\r\n}\r\nexports.Component = Component;\r\n/**\r\n * This static property contains style text used as styles for current component.\r\n * Class names will be scoped as `.className__componentName`.\r\n * Tag selector will be nested as: `p` -> `com-name p`.\r\n *\r\n * You can nest css codes just like in SCSS, and use `$` to reference parent selector.\r\n */\r\nComponent.style = null;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.defineCustomElement = void 0;\r\nconst define_1 = require(\"./define\");\r\nconst from_element_1 = require(\"./from-element\");\r\n// When `connectedCallback` called on a element, it's child nodes are not ready yet.\r\n// So we can't leave an element into document firstly, and wait it to be connected,\r\n// but must render all the html codes with javascript, and insert into document in bundle.\r\n// Otherwise If we include bundled js behind all other custom element tags in a document, or with `defer` property,\r\n// since elements were prepared already, then they will be connected in component registration order, not in element order.\r\n// We fix this by connect connect elements later, and sort them before connect each.\r\n// Both `connectedCallback` and `disconnectedCallback` may triggered multiple times when element moving or removing.\r\n// So we must delay the component connect and disconnect operation by a queue.\r\n/** Using queue to delay the connect and disconnect operations for elements. */\r\nlet toConnectSoonCache = new Set();\r\nlet toDisconnectSoonCache = new Set();\r\n/** Whether having things in queue to update. */\r\nlet needsUpdate = false;\r\n/** Defines custom element to connect and create component automatically. */\r\nfunction defineCustomElement(name) {\r\n    customElements.define(name, class FlitElement extends HTMLElement {\r\n        // Although spec says connect callback will not be called when inserting element to a document fragment,\r\n        // but I still find it may be triggrred in a rate.\r\n        connectedCallback() {\r\n            if (!(this.ownerDocument instanceof DocumentFragment)) {\r\n                enqueueConnect(this);\r\n            }\r\n        }\r\n        // Moving or removing element will trigger disconnected callback each time.\r\n        disconnectedCallback() {\r\n            enqueueDisconnect(this);\r\n        }\r\n    });\r\n}\r\nexports.defineCustomElement = defineCustomElement;\r\n/** Enqueue connection for an element. */\r\nfunction enqueueConnect(el) {\r\n    // Can avoid appending elements triggers disconnect and connect soon.\r\n    if (toDisconnectSoonCache.has(el)) {\r\n        toDisconnectSoonCache.delete(el);\r\n    }\r\n    else {\r\n        toConnectSoonCache.add(el);\r\n        if (!needsUpdate) {\r\n            enqueueUpdate();\r\n        }\r\n    }\r\n}\r\n/** Enqueue disconnection for an element. */\r\nfunction enqueueDisconnect(el) {\r\n    // Can avoid inserting elements into a fragment and then removed triggers connect.\r\n    if (toConnectSoonCache.has(el)) {\r\n        toConnectSoonCache.delete(el);\r\n    }\r\n    else {\r\n        toDisconnectSoonCache.add(el);\r\n        if (!needsUpdate) {\r\n            enqueueUpdate();\r\n        }\r\n    }\r\n}\r\n/** Enqueue a updating task if no task yet. */\r\nfunction enqueueUpdate() {\r\n    Promise.resolve().then(update);\r\n    needsUpdate = true;\r\n}\r\n/** Update, handle all connect and disconnect requests. */\r\nfunction update() {\r\n    if (toConnectSoonCache.size > 0) {\r\n        updateConnectRequests();\r\n    }\r\n    // Disconnect elements later may avoid it slows followed rendering.\r\n    if (toDisconnectSoonCache.size > 0) {\r\n        updateDisconnectRequests();\r\n    }\r\n    needsUpdate = false;\r\n}\r\n/** Handle all connect requests. */\r\nfunction updateConnectRequests() {\r\n    let toConnectImmediately = [...toConnectSoonCache];\r\n    // Connect element in natural element order.\r\n    // Important: elements were sorted as connect order, just like element order.\r\n    // So wouln't cost time to sort.\r\n    toConnectImmediately.sort((a, b) => {\r\n        return a.compareDocumentPosition(b) & a.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;\r\n    });\r\n    // More connect requests will come, must delay them.\r\n    toConnectSoonCache = new Set();\r\n    for (let el of toConnectImmediately) {\r\n        // `el` may not in document,\r\n        // e.g., inserted into a fragment.\r\n        // No need to worry about forgetting to instantiate it,\r\n        // it will trigger `connectedCallback` again after insert into document.\r\n        // Here also have a small rate document not contains el.\r\n        connectElement(el);\r\n    }\r\n}\r\n/** Handle all disconnect requests. */\r\nfunction updateDisconnectRequests() {\r\n    // More connect requests will be added, must delay them.\r\n    let toDisconnectImmediately = toDisconnectSoonCache;\r\n    toDisconnectSoonCache = new Set();\r\n    // Element order of disconnect is not important.\r\n    for (let el of toDisconnectImmediately.keys()) {\r\n        disconnectElement(el);\r\n    }\r\n}\r\n/** Connect element and create component. */\r\nfunction connectElement(el) {\r\n    let com = from_element_1.getComponent(el);\r\n    let isFirstTimeCreated = false;\r\n    if (!com) {\r\n        com = define_1.createComponent(el);\r\n        isFirstTimeCreated = true;\r\n    }\r\n    com.__emitConnected(isFirstTimeCreated);\r\n}\r\n/** Disconnect element and emit disconnect event for component. */\r\nfunction disconnectElement(el) {\r\n    let com = from_element_1.getComponent(el);\r\n    if (com) {\r\n        com.__emitDisconnected();\r\n    }\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.createComponent = exports.define = void 0;\r\nconst custom_element_1 = require(\"./custom-element\");\r\nconst style_1 = require(\"./style\");\r\nfunction define(name, Com) {\r\n    if (!name.includes('-')) {\r\n        throw new Error(`\"${name}\" can't be defined as custom element, a custom element name must contain \"-\"!`);\r\n    }\r\n    // Used for `@define(name)` decorator.\r\n    if (!Com) {\r\n        return function (Com) {\r\n            define(name, Com);\r\n        };\r\n    }\r\n    // `define(name, Com)`\r\n    else {\r\n        defineComponentConstructor(name, Com);\r\n        custom_element_1.defineCustomElement(name);\r\n        return undefined;\r\n    }\r\n}\r\nexports.define = define;\r\n/** To cache `name -> component constructor` */\r\nconst ComponentConstructorMap = new Map();\r\n/**\r\n * Defines a component with specified name and class, from `define(name, Com)`.\r\n * @param name The component name, same with `define()`.\r\n * @param Com The component class constructor.\r\n */\r\nfunction defineComponentConstructor(name, Com) {\r\n    if (ComponentConstructorMap.has(name)) {\r\n        console.warn(`You are trying to overwrite component definition \"${name}\"!`);\r\n    }\r\n    ComponentConstructorMap.set(name, Com);\r\n}\r\n/**\r\n * Get component constructor from name, used to instantiate specified component from it's defined name.\r\n * @param name The component name, same with the name in `define(name, ...)`.\r\n */\r\nfunction getComponentConstructor(name) {\r\n    return ComponentConstructorMap.get(name);\r\n}\r\n/** Create a component manually, when we exactly know this is a custom element. */\r\nfunction createComponent(el) {\r\n    let Com = getComponentConstructor(el.localName);\r\n    style_1.ensureComponentStyle(Com, el.localName);\r\n    let com = new Com(el);\r\n    com.__emitCreated();\r\n    return com;\r\n}\r\nexports.createComponent = createComponent;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getClosestComponentEarly = exports.getComponentEarly = exports.getClosestComponentOfType = exports.getComponentAsync = exports.getComponent = exports.setElementComponentMap = void 0;\r\nconst life_cycle_1 = require(\"./life-cycle\");\r\n/** To cache `el -> com` map and find component from element. */\r\nconst elementComponentMap = new WeakMap();\r\n/** Set element -> component instance map. */\r\nfunction setElementComponentMap(el, com) {\r\n    elementComponentMap.set(el, com);\r\n}\r\nexports.setElementComponentMap = setElementComponentMap;\r\n/**\r\n * Get component instance from custom element.\r\n * @param el The element to get component instance at.\r\n * @return The found component or `null` if no component registered on the element.\r\n */\r\nfunction getComponent(el) {\r\n    return elementComponentMap.get(el) || null;\r\n}\r\nexports.getComponent = getComponent;\r\n/**\r\n * Get component instance from root element asynchronously.\r\n * Returns a promise which will be resolved after component created and triggers `created` event.\r\n * @param el The element to get component instance at.\r\n * @return The found component or `null` if is not a custom element.\r\n */\r\nfunction getComponentAsync(el) {\r\n    if (el.localName.includes('-')) {\r\n        let com = elementComponentMap.get(el);\r\n        if (com) {\r\n            return Promise.resolve(com);\r\n        }\r\n        else {\r\n            return new Promise(resolve => {\r\n                life_cycle_1.onComponentCreatedAt(el, resolve);\r\n            });\r\n        }\r\n    }\r\n    else {\r\n        return Promise.resolve(null);\r\n    }\r\n}\r\nexports.getComponentAsync = getComponentAsync;\r\n/**\r\n * Get closest component matches constructor from the closest ancestor custom element.\r\n * It's very common that you extend a component and define a new custom element,\r\n * So you will can't find the parent component from the tag name.\r\n * But you can still match super class by this method.\r\n * @param el The element to search from it and it's ancestors for component instance.\r\n * @param Com The component constructor to search.\r\n * @returns The found component or `null` if no component found.\r\n */\r\nfunction getClosestComponentOfType(el, Com) {\r\n    let parent = el;\r\n    while (parent && parent instanceof HTMLElement) {\r\n        if (parent.localName.includes('-')) {\r\n            let com = getComponent(parent);\r\n            if (com instanceof Com) {\r\n                return com;\r\n            }\r\n        }\r\n        parent = parent.parentElement;\r\n    }\r\n    return null;\r\n}\r\nexports.getClosestComponentOfType = getClosestComponentOfType;\r\n/**\r\n * Get component instance from root element as soon as component created,\r\n * Before properties applied and before trigging `created` event.\r\n * Or immediately when component already been created.\r\n * Only for inner use.\r\n * @param el The element to get component instance at.\r\n */\r\nfunction getComponentEarly(el, callback) {\r\n    if (el.localName.includes('-')) {\r\n        let com = elementComponentMap.get(el);\r\n        if (com) {\r\n            callback(com);\r\n        }\r\n        else {\r\n            life_cycle_1.onComponentCreatedAt(el, callback);\r\n        }\r\n    }\r\n    else {\r\n        callback(null);\r\n    }\r\n}\r\nexports.getComponentEarly = getComponentEarly;\r\n/**\r\n * Get closest component from the closest ancestor custom element.\r\n * Only for inner use.\r\n * @param el The element to search from it and it's ancestors.\r\n */\r\nfunction getClosestComponentEarly(el, callback) {\r\n    let parent = el;\r\n    while (parent && parent instanceof HTMLElement) {\r\n        if (parent.localName.includes('-')) {\r\n            getComponentEarly(parent, callback);\r\n            return;\r\n        }\r\n        parent = parent.parentElement;\r\n    }\r\n    callback(null);\r\n}\r\nexports.getClosestComponentEarly = getClosestComponentEarly;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar component_1 = require(\"./component\");\r\nObject.defineProperty(exports, \"Component\", { enumerable: true, get: function () { return component_1.Component; } });\r\nvar from_element_1 = require(\"./from-element\");\r\nObject.defineProperty(exports, \"getComponent\", { enumerable: true, get: function () { return from_element_1.getComponent; } });\r\nObject.defineProperty(exports, \"getComponentAsync\", { enumerable: true, get: function () { return from_element_1.getComponentAsync; } });\r\nObject.defineProperty(exports, \"getClosestComponentOfType\", { enumerable: true, get: function () { return from_element_1.getClosestComponentOfType; } });\r\nObject.defineProperty(exports, \"getComponentEarly\", { enumerable: true, get: function () { return from_element_1.getComponentEarly; } });\r\nObject.defineProperty(exports, \"getClosestComponentEarly\", { enumerable: true, get: function () { return from_element_1.getClosestComponentEarly; } });\r\nvar life_cycle_1 = require(\"./life-cycle\");\r\nObject.defineProperty(exports, \"updateAllComponents\", { enumerable: true, get: function () { return life_cycle_1.updateAllComponents; } });\r\nvar style_1 = require(\"./style\");\r\nObject.defineProperty(exports, \"addGlobalStyle\", { enumerable: true, get: function () { return style_1.addGlobalStyle; } });\r\nObject.defineProperty(exports, \"updateAllStyles\", { enumerable: true, get: function () { return style_1.updateAllStyles; } });\r\nvar define_1 = require(\"./define\");\r\nObject.defineProperty(exports, \"define\", { enumerable: true, get: function () { return define_1.define; } });\r\nObject.defineProperty(exports, \"createComponent\", { enumerable: true, get: function () { return define_1.createComponent; } });\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.updateAllComponents = exports.onComponentDisconnected = exports.onComponentConnected = exports.emitComponentCreationCallbacks = exports.onComponentCreatedAt = void 0;\r\n/** To cache callbacks after component initialized */\r\nconst ComponentCreationCallbackCache = new WeakMap();\r\n/** To cache all the connected components that element connected. */\r\nconst ConnectedComponents = new Set();\r\n/** Call callbacks after component instance created, and before triggering `created` event. */\r\nfunction onComponentCreatedAt(el, callback) {\r\n    let callbacks = ComponentCreationCallbackCache.get(el);\r\n    if (!callbacks) {\r\n        ComponentCreationCallbackCache.set(el, (callbacks = []));\r\n    }\r\n    callbacks.push(callback);\r\n}\r\nexports.onComponentCreatedAt = onComponentCreatedAt;\r\n/**\r\n * Call after component created.\r\n * Used to assign properties from `.props`, or bind component events by `@com-event`.\r\n */\r\nfunction emitComponentCreationCallbacks(el, com) {\r\n    let callbacks = ComponentCreationCallbackCache.get(el);\r\n    if (callbacks) {\r\n        for (let callback of callbacks) {\r\n            callback(com);\r\n        }\r\n        ComponentCreationCallbackCache.delete(el);\r\n    }\r\n}\r\nexports.emitComponentCreationCallbacks = emitComponentCreationCallbacks;\r\n/** On component element connected into document or fragment. */\r\nfunction onComponentConnected(com) {\r\n    ConnectedComponents.add(com);\r\n}\r\nexports.onComponentConnected = onComponentConnected;\r\n/** On component element disconnected into document or fragment. */\r\nfunction onComponentDisconnected(com) {\r\n    ConnectedComponents.delete(com);\r\n}\r\nexports.onComponentDisconnected = onComponentDisconnected;\r\n/**\r\n * Updates all the components that elements are connected nto document, and their watchers.\r\n * e.g., you may call this after language changes and not automatically detected.\r\n */\r\nfunction updateAllComponents() {\r\n    for (let com of ConnectedComponents) {\r\n        com.update();\r\n        com.__updateWatcherGroup();\r\n    }\r\n}\r\nexports.updateAllComponents = updateAllComponents;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.updateAllStyles = exports.addGlobalStyle = exports.ensureComponentStyle = void 0;\r\nconst style_parser_1 = require(\"../internals/style-parser\");\r\n/** Caches `Component -> style element`. */\r\nconst ComponentStyleAndTagMap = new Map();\r\n/** Caches global style element and their source. */\r\nconst GlobalStyleAndTags = [];\r\n/** Calls after any one instance of component constructor connected, to ensure it's relied styles appended into document. */\r\nfunction ensureComponentStyle(Com, name) {\r\n    if (Com.style && !ComponentStyleAndTagMap.has(Com)) {\r\n        let styleTag = createStyleElement(Com.style, name);\r\n        ComponentStyleAndTagMap.set(Com, styleTag);\r\n    }\r\n}\r\nexports.ensureComponentStyle = ensureComponentStyle;\r\n/**\r\n * Create <style> tag and insert it into body.\r\n * `name` should be `global` for global style.\r\n */\r\nfunction createStyleElement(style, scopeName) {\r\n    let styleTag = document.createElement('style');\r\n    styleTag.setAttribute('name', scopeName);\r\n    styleTag.textContent = getStyleContent(style, scopeName);\r\n    document.head.append(styleTag);\r\n    return styleTag;\r\n}\r\n/** Get style text from static style property. */\r\nfunction getStyleContent(style, scopeName) {\r\n    if (typeof style === 'function') {\r\n        style = style();\r\n    }\r\n    return style_parser_1.parseStyleCodes(String(style), scopeName === 'global' ? '' : scopeName);\r\n}\r\n/**\r\n * Add a global style. compare to normal style codes, it can use variables and can be updated dinamically.\r\n * @param style A string, css`...`, or a function return those.\r\n * @returns A newly created style tag element.\r\n */\r\nfunction addGlobalStyle(style) {\r\n    let scopeName = 'global';\r\n    let styleTag = createStyleElement(style, scopeName);\r\n    GlobalStyleAndTags.push({ style, tag: styleTag });\r\n    return styleTag;\r\n}\r\nexports.addGlobalStyle = addGlobalStyle;\r\n/** Updates all style codes for all the components, you may call this after theme changed. */\r\nfunction updateAllStyles() {\r\n    // `updateStyles` should always been called along with `updateAllComponents`,\r\n    // So we should makesure `updateStyles` in the same micro task with `updateAllComponents`.\r\n    for (let [Com, tag] of ComponentStyleAndTagMap.entries()) {\r\n        if (Com.style) {\r\n            let newContent = getStyleContent(Com.style, tag.getAttribute('name'));\r\n            if (newContent !== tag.textContent) {\r\n                tag.textContent = newContent;\r\n            }\r\n        }\r\n    }\r\n    for (let { style, tag } of GlobalStyleAndTags) {\r\n        if (typeof style === 'function') {\r\n            let newContent = getStyleContent(style, tag.getAttribute('name'));\r\n            if (newContent !== tag.textContent) {\r\n                tag.textContent = newContent;\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.updateAllStyles = updateAllStyles;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.cache = exports.CacheDirective = void 0;\r\nconst define_1 = require(\"./define\");\r\nconst template_1 = require(\"../template\");\r\nconst contextual_transition_1 = require(\"../internals/contextual-transition\");\r\nclass CacheDirective {\r\n    constructor(anchor, context) {\r\n        this.templates = [];\r\n        this.currentTemplate = null;\r\n        this.anchor = anchor;\r\n        this.context = context;\r\n        this.transition = new contextual_transition_1.ContextualTransition(context);\r\n    }\r\n    canMergeWith() {\r\n        return true;\r\n    }\r\n    merge(result, options) {\r\n        this.transition.updateOptions(options);\r\n        if (result) {\r\n            // Matches, merge them. will not play transition.\r\n            if (this.currentTemplate && this.currentTemplate.canMergeWith(result)) {\r\n                this.currentTemplate.merge(result);\r\n            }\r\n            else {\r\n                // Moves out current.\r\n                if (this.currentTemplate) {\r\n                    this.movesOutCurrentTemplate();\r\n                }\r\n                // Find one that can be reused.\r\n                let template = this.templates.find(t => t.canMergeWith(result));\r\n                if (template) {\r\n                    template.merge(result);\r\n                    this.anchor.insert(template.extractToFragment());\r\n                    this.tryPlayEnterTransition(template);\r\n                    this.currentTemplate = template;\r\n                }\r\n                // Create new.\r\n                else {\r\n                    this.makeNewTemplate(result);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // Moves out current.\r\n            if (this.currentTemplate) {\r\n                this.movesOutCurrentTemplate();\r\n            }\r\n        }\r\n    }\r\n    async movesOutCurrentTemplate() {\r\n        let template = this.currentTemplate;\r\n        let playing = false;\r\n        if (this.transition.shouldPlayLeave()) {\r\n            let firstElement = template.getFirstElement();\r\n            if (firstElement) {\r\n                this.transition.playLeave(firstElement).then((finish) => {\r\n                    if (finish) {\r\n                        template.movesOut();\r\n                    }\r\n                });\r\n                playing = true;\r\n            }\r\n        }\r\n        if (!playing) {\r\n            template.movesOut();\r\n        }\r\n        this.currentTemplate = null;\r\n    }\r\n    makeNewTemplate(result) {\r\n        let template = new template_1.Template(result, this.context);\r\n        this.anchor.insert(template.extractToFragment());\r\n        this.tryPlayEnterTransition(template);\r\n        this.currentTemplate = template;\r\n        this.templates.push(template);\r\n    }\r\n    async tryPlayEnterTransition(template) {\r\n        if (this.transition.shouldPlayEnter()) {\r\n            let firstElement = template.getFirstElement();\r\n            if (firstElement) {\r\n                await this.transition.playEnter(firstElement);\r\n            }\r\n        }\r\n    }\r\n    remove() {\r\n        if (this.currentTemplate) {\r\n            this.currentTemplate.remove();\r\n        }\r\n    }\r\n}\r\nexports.CacheDirective = CacheDirective;\r\n/**\r\n * `cache(changableContent, ?options)` will toggle rendering content, and also cache old content to restore it quickly.\r\n * Note that when old rendering result restored, the scroll positions in it will fall back to start position.\r\n *\r\n * @param result The html`...` result, can be `null` or an empty string.\r\n * @param options Options for transition.\r\n */\r\nexports.cache = define_1.defineDirective(CacheDirective);\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.refDirective = exports.DirectiveReferences = exports.DirectiveResult = exports.defineDirective = void 0;\r\nconst references_1 = require(\"../helpers/references\");\r\n/**\r\n * Defines a directive from a class which implements `Directive`.\r\n * Returns a function call which will generate a `DirectiveResult`.\r\n *\r\n * A `Directive` works like Binding, but it used to generate HTML code pieces,\r\n * not like `Binding` to modify properties of an element.\r\n *\r\n * It's hard to define a custom directive, please read source codes before doing this.\r\n */\r\nfunction defineDirective(Dir) {\r\n    return function (...args) {\r\n        return new DirectiveResult(Dir, ...args);\r\n    };\r\n}\r\nexports.defineDirective = defineDirective;\r\n/**\r\n * Returned from calling directive functions like `repeat`.\r\n * Used to cache parameters and update template later.\r\n */\r\nclass DirectiveResult {\r\n    constructor(Dir, ...args) {\r\n        /** Reference function when uses `refDirective(...)`. */\r\n        this.ref = null;\r\n        this.directiveConstructor = Dir;\r\n        this.args = args;\r\n    }\r\n}\r\nexports.DirectiveResult = DirectiveResult;\r\n/** Class to help handle reference from directive result to it's directive class. */\r\nclass DirectiveReferencesClass extends references_1.ResultReferences {\r\n    /** Calls reference callback when binging instance created. */\r\n    createFromResult(anchor, context, result) {\r\n        let Dir = result.directiveConstructor;\r\n        let directive = new Dir(anchor, context);\r\n        this.createReference(result, directive);\r\n        directive.merge(...result.args);\r\n        return directive;\r\n    }\r\n}\r\nexports.DirectiveReferences = new DirectiveReferencesClass();\r\n/**\r\n * Reference to directive instance after it created and before merge.\r\n *  * Use it like:\r\n * ```ts\r\n * >refDirective(repeat(...))<\r\n * ```\r\n *\r\n * @param result The directive result like `repeat(...)`.\r\n * @param ref Callback with the directive object as parameter.\r\n * @param unref Callback after directive instance was removed directly, not calls when was contained in a removed template.\r\n * @return The `result` parameter.\r\n */\r\nfunction refDirective(result, ref, unref) {\r\n    exports.DirectiveReferences.addReference(result, ref);\r\n    if (unref) {\r\n        exports.DirectiveReferences.addUnReference(result, unref);\r\n    }\r\n    return result;\r\n}\r\nexports.refDirective = refDirective;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.OffsetChildren = void 0;\r\nclass OffsetChildren {\r\n    constructor(parent, offset) {\r\n        this.parent = parent;\r\n        this.offset = offset;\r\n    }\r\n    getChildren() {\r\n        return [...this.parent.children].slice(this.offset);\r\n    }\r\n    childAt(index) {\r\n        return this.parent.children[this.offset + index];\r\n    }\r\n}\r\nexports.OffsetChildren = OffsetChildren;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PageDataGetter = void 0;\r\nconst utils_1 = require(\"../../helpers/utils\");\r\nclass PageDataGetter {\r\n    constructor(asyncDataGetter, immediateDataGetter = null) {\r\n        this.cache = null;\r\n        this.version = 0;\r\n        this.asyncDataGetter = asyncDataGetter;\r\n        this.immediateDataGetter = immediateDataGetter;\r\n    }\r\n    /** Get data items immediately. */\r\n    getImmediateData(startIndex, endIndex) {\r\n        let items;\r\n        if (this.immediateDataGetter) {\r\n            items = this.immediateDataGetter(startIndex, endIndex);\r\n        }\r\n        else {\r\n            items = this.getSharedData(startIndex, endIndex);\r\n        }\r\n        return items;\r\n    }\r\n    /** Get shared part with previously loaded data. */\r\n    getSharedData(startIndex, endIndex) {\r\n        let items = [];\r\n        let count = endIndex - startIndex;\r\n        if (this.cache) {\r\n            if (startIndex < this.cache.startIndex) {\r\n                items.push(...utils_1.repeatForTimes(null, Math.min(this.cache.startIndex - startIndex, count)));\r\n            }\r\n            // Shared part.\r\n            items.push(...this.cache.items.slice(Math.max(this.cache.startIndex, startIndex), Math.min(this.cache.endIndex, endIndex)));\r\n            if (endIndex > this.cache.endIndex) {\r\n                items.push(...utils_1.repeatForTimes(null, Math.max(endIndex - this.cache.endIndex, count)));\r\n            }\r\n        }\r\n        else {\r\n            items.push(...utils_1.repeatForTimes(null, count));\r\n        }\r\n        return items;\r\n    }\r\n    /** Get fresh data items. */\r\n    async getFreshData(startIndex, endIndex) {\r\n        let version = ++this.version;\r\n        let items = await this.asyncDataGetter(startIndex, endIndex);\r\n        if (this.version === version) {\r\n            this.cache = {\r\n                startIndex,\r\n                endIndex,\r\n                items,\r\n            };\r\n        }\r\n        return items;\r\n    }\r\n}\r\nexports.PageDataGetter = PageDataGetter;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PartialRenderingProcessor = void 0;\r\nconst utils_1 = require(\"../../helpers/utils\");\r\nconst queue_1 = require(\"../../queue\");\r\nclass PartialRenderingProcessor {\r\n    constructor(scroller, slider, sliderChildren) {\r\n        /** Size of each time render count. */\r\n        this.renderCount = 50;\r\n        /** Render count of groups, increase if not enough. */\r\n        this.renderGroupCount = 1;\r\n        /** Border tio and bottom width. */\r\n        this.scrollerBorderTopWidth = 0;\r\n        this.scrollerBorderBottomWidth = 0;\r\n        /** The start index of first item in the whole data. */\r\n        this.startIndex = 0;\r\n        /** The end index of next position of last item in the whole data. */\r\n        this.endIndex = 0;\r\n        /** The start index of first item and should be applied when next time rendering. */\r\n        this.startIndexToApply = 0;\r\n        /** Current total data count. */\r\n        this.totalDataCount = 0;\r\n        /** Data changed or data count changed and need to be applied. */\r\n        this.needToApplyDataCountChange = false;\r\n        /**\r\n         * Average item height in pixels, it is used to calculate the position of the `slider`.\r\n         * It will be detected automatically from the first rendering if was not initialized.\r\n         */\r\n        this.averageItemHeight = 0;\r\n        /** The item count, will not update placeholder height when scrolling up. */\r\n        this.itemCountWhenUpdatePlaceholderHeight = 0;\r\n        /** If is not `null`, means updating is not completed yet. */\r\n        this.untilUpdatingCompletePromise = null;\r\n        this.scroller = scroller;\r\n        this.slider = slider;\r\n        this.sliderChildren = sliderChildren;\r\n        this.palceholder = document.createElement('div');\r\n        this.palceholder.style.cssText = 'position: absolute; left: 0; top: 0; width: 1px; visibility: hidden;';\r\n        this.scroller.prepend(this.palceholder);\r\n        queue_1.onRenderComplete(() => {\r\n            this.onFirstTimeRenderCompleted();\r\n        });\r\n    }\r\n    /** Update `renderCount` property. */\r\n    updateRenderCount(renderCount) {\r\n        this.renderCount = renderCount;\r\n    }\r\n    /** Get how many groups need to render. */\r\n    getRenderGroupCount() {\r\n        return this.renderGroupCount;\r\n    }\r\n    /** Begin to validate css properties after elements rendered. */\r\n    onFirstTimeRenderCompleted() {\r\n        let computedStyle = getComputedStyle(this.scroller);\r\n        if (!['scroll', 'auto'].includes(computedStyle.overflowY)) {\r\n            throw 'The  style value \"overflow-y\" of scroller element out of \"liveRepeat\" directive must be \"scroll\" or \"auto\"!';\r\n        }\r\n        if (computedStyle.position === 'static') {\r\n            throw 'The style value \"position\" of scroller element out of \"liveRepeat\" directive must not be \"static\"!';\r\n        }\r\n        if (getComputedStyle(this.slider).position !== 'absolute') {\r\n            throw 'The style value \"position\" of slider element out of \"liveRepeat\" directive must not be \"absolute\"!';\r\n        }\r\n        this.scrollerBorderTopWidth = Number(getComputedStyle(this.scroller).borderTopWidth.replace('px', '')) || 0;\r\n        this.scrollerBorderBottomWidth = Number(getComputedStyle(this.scroller).borderBottomWidth.replace('px', '')) || 0;\r\n    }\r\n    /** Will locate to index when next time rendering. */\r\n    setStartIndex(index) {\r\n        this.startIndexToApply = index;\r\n    }\r\n    /** Whether specifies a start index. */\r\n    isStartIndexSpecified() {\r\n        return this.startIndexToApply !== null;\r\n    }\r\n    /** Update total data count after reload data. */\r\n    updateDataCount(dataCount) {\r\n        if (dataCount !== this.totalDataCount) {\r\n            this.totalDataCount = dataCount;\r\n            this.needToApplyDataCountChange = true;\r\n            this.itemCountWhenUpdatePlaceholderHeight = 0;\r\n        }\r\n    }\r\n    /**\r\n     * Update from applied start index or current scroll position.\r\n     * Note it must call `doDataUpdating` synchronously since it's already in a updating queue.\r\n     */\r\n    updateRendering(doDataUpdating) {\r\n        let willApplyStartIndex = this.startIndexToApply !== null;\r\n        // Scroll to specified index.\r\n        if (willApplyStartIndex) {\r\n            this.updateWhenStartIndexWillApply(doDataUpdating);\r\n        }\r\n        // Data should changed or partly changed, reset from current scroll position.\r\n        else if (this.needToApplyDataCountChange) {\r\n            this.updateFromCurrentScrollOffset(doDataUpdating);\r\n            this.needToApplyDataCountChange = false;\r\n        }\r\n        // Just keep indices and update data.\r\n        else {\r\n            doDataUpdating(this.startIndex, this.endIndex, null);\r\n        }\r\n        this.lockUpdatingByPromise(queue_1.untilRenderComplete().then(() => {\r\n            this.updatePlaceholderHeightProgressive();\r\n            // Re-calcuate position and scroll offset.\r\n            if (willApplyStartIndex) {\r\n                this.resetSliderPosition();\r\n                this.updateScrollOffset();\r\n            }\r\n        }));\r\n    }\r\n    /**\r\n     * Update only when current rendering can't cover scroller, and will keep continuous scroll position.\r\n     * Note it must call `doDataUpdating` synchronously since it may be in a updating queue.\r\n     * Returns whether updated.\r\n     */\r\n    updateRenderingSmoothlyIfNeeded(doDataUpdating) {\r\n        // Last updating is not completed.\r\n        if (this.untilUpdatingCompletePromise) {\r\n            return false;\r\n        }\r\n        // Reach start or end edge.\r\n        if (this.startIndex === 0 && this.endIndex === this.totalDataCount) {\r\n            return false;\r\n        }\r\n        let updatePromise = this.updateFromCoverage(doDataUpdating);\r\n        if (updatePromise) {\r\n            this.lockUpdatingByPromise(updatePromise.then(() => {\r\n                this.updatePlaceholderHeightProgressive();\r\n            }));\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    /** Prevent updating before promise been completed. */\r\n    async lockUpdatingByPromise(promise) {\r\n        this.untilUpdatingCompletePromise = promise;\r\n        await promise;\r\n        this.untilUpdatingCompletePromise = null;\r\n    }\r\n    /** Update when start index specified. */\r\n    updateWhenStartIndexWillApply(doDataUpdating) {\r\n        this.updateIndices(this.startIndexToApply);\r\n        this.startIndexToApply = null;\r\n        this.resetSliderPosition();\r\n        doDataUpdating(this.startIndex, this.endIndex, null);\r\n    }\r\n    /** Update start and end index before rendering. */\r\n    updateIndices(startIndex) {\r\n        let renderCount = this.renderCount * this.renderGroupCount;\r\n        startIndex = Math.min(startIndex, this.totalDataCount - renderCount);\r\n        startIndex = Math.max(0, startIndex);\r\n        let endIndex = startIndex + renderCount;\r\n        endIndex = Math.min(endIndex, this.totalDataCount);\r\n        this.startIndex = startIndex;\r\n        this.endIndex = endIndex;\r\n    }\r\n    /**\r\n     * Update height of placeholder progressive, form current item count and their height.\r\n     * Must wait for render completed.\r\n     */\r\n    updatePlaceholderHeightProgressive() {\r\n        if (this.endIndex > 0 && this.endIndex >= this.itemCountWhenUpdatePlaceholderHeight || this.endIndex === this.totalDataCount) {\r\n            let scrollerRect = this.getScrollerClientRect();\r\n            let sliderRect = this.slider.getBoundingClientRect();\r\n            let scrollHeight = this.scroller.scrollTop + sliderRect.bottom - scrollerRect.top;\r\n            this.averageItemHeight = scrollHeight / this.endIndex;\r\n            this.palceholder.style.height = this.averageItemHeight * this.totalDataCount + 'px';\r\n            this.itemCountWhenUpdatePlaceholderHeight = this.endIndex;\r\n        }\r\n    }\r\n    /** Get a fixed client rect of scroller. */\r\n    getScrollerClientRect() {\r\n        let scrollerRect = utils_1.getRect(this.scroller);\r\n        scrollerRect.top += this.scrollerBorderTopWidth;\r\n        scrollerRect.bottom -= this.scrollerBorderBottomWidth;\r\n        scrollerRect.height -= this.scrollerBorderTopWidth + this.scrollerBorderBottomWidth;\r\n        return scrollerRect;\r\n    }\r\n    /** Update position of `slider` after set new indices. */\r\n    updateSliderPosition(direction, position) {\r\n        if (direction === 'top') {\r\n            this.slider.style.top = position + 'px';\r\n            this.slider.style.bottom = 'auto';\r\n        }\r\n        else {\r\n            this.slider.style.bottom = position + 'px';\r\n            this.slider.style.top = 'auto';\r\n        }\r\n    }\r\n    /** Update position of `slider` after set new index. */\r\n    resetSliderPosition() {\r\n        // May `averageItemHeight` be `0`, will update later in this scenario.\r\n        let countBeforeStart = this.startIndex;\r\n        let newTop = this.averageItemHeight * countBeforeStart;\r\n        this.updateSliderPosition('top', newTop);\r\n    }\r\n    /** Update scroll offset of `scroller` after set new `startIndex`. */\r\n    updateScrollOffset() {\r\n        let countBeforeStart = this.startIndex;\r\n        this.scroller.scrollTop = this.averageItemHeight * countBeforeStart;\r\n    }\r\n    /**\r\n     * Validate if slider fully covers scroller and update indices if not.\r\n     * Returns whether updated indices.\r\n     */\r\n    updateFromCoverage(doDataUpdating) {\r\n        let scrollerRect = this.getScrollerClientRect();\r\n        let sliderRect = this.slider.getBoundingClientRect();\r\n        let renderCount = this.renderCount * this.renderGroupCount;\r\n        let unexpectedScrollEnd = this.scroller.scrollTop + this.scroller.clientHeight === this.scroller.scrollHeight && this.endIndex < this.totalDataCount;\r\n        let unexpectedScrollStart = this.scroller.scrollTop === 0 && this.startIndex > 0;\r\n        let promise = null;\r\n        // No intersection, reset slider position from current slider scroll offset.\r\n        let hasNoIntersection = sliderRect.bottom < scrollerRect.top || sliderRect.top > scrollerRect.bottom;\r\n        if (hasNoIntersection) {\r\n            this.updateFromCurrentScrollOffset(doDataUpdating);\r\n            promise = queue_1.untilRenderComplete();\r\n        }\r\n        // Scroll down and can't cover at bottom direction.\r\n        // Otherwise will still load more when touch bottom scrolling edge and still more data exist.\r\n        else if (sliderRect.bottom < scrollerRect.bottom || unexpectedScrollEnd) {\r\n            let roughFirstVisibleIndex = utils_1.locateFirstVisibleIndex(this.scroller, this.sliderChildren.getChildren(), 0);\r\n            let oldStartIndex = this.startIndex;\r\n            let newStartIndex = this.startIndex + roughFirstVisibleIndex;\r\n            this.updateIndices(newStartIndex);\r\n            promise = this.updateWithSliderPositionStable('down', oldStartIndex, scrollerRect, doDataUpdating);\r\n        }\r\n        // Scroll up and can't cover at top direction.\r\n        // Keeps last visible index as endIndex.\r\n        // Otherwise will still load more when touch top scrolling edge and still more data exist.\r\n        else if (sliderRect.top > scrollerRect.top || unexpectedScrollStart) {\r\n            let roughLastVisibleIndex = utils_1.locateLastVisibleIndex(this.scroller, this.sliderChildren.getChildren(), 0);\r\n            let oldStartIndex = this.startIndex;\r\n            let newEndIndex = this.startIndex + roughLastVisibleIndex + 1;\r\n            let newStartIndex = newEndIndex - renderCount;\r\n            this.updateIndices(newStartIndex);\r\n            promise = this.updateWithSliderPositionStable('up', oldStartIndex, scrollerRect, doDataUpdating);\r\n        }\r\n        // Not updated otherwise.\r\n        return promise;\r\n    }\r\n    /** Re-generate indices from current scroll offset. */\r\n    updateFromCurrentScrollOffset(doDataUpdating) {\r\n        this.resetIndices();\r\n        this.resetSliderPosition();\r\n        doDataUpdating(this.startIndex, this.endIndex, null);\r\n    }\r\n    /** Reset indices from current scroll offset. */\r\n    resetIndices() {\r\n        let newStartIndex = this.averageItemHeight > 0 ? Math.floor(this.scroller.scrollTop / this.averageItemHeight) : 0;\r\n        this.updateIndices(newStartIndex);\r\n    }\r\n    /** Update slider position to keep it in a stable position after updating data items. */\r\n    async updateWithSliderPositionStable(scrollDirection, oldStartIndex, scrollerRect, doDataUpdating) {\r\n        let visibleIndex = scrollDirection === 'down' ? this.startIndex - oldStartIndex : this.endIndex - 1 - oldStartIndex;\r\n        let visibleElement = this.sliderChildren.childAt(visibleIndex);\r\n        let updateData = () => { doDataUpdating(this.startIndex, this.endIndex, scrollDirection); };\r\n        if (!visibleElement) {\r\n            throw new Error(`Wrongly rendered: can\\'t found expected element in specified index!`);\r\n        }\r\n        // When reach start index but may not reach scroll start.\r\n        if (this.startIndex === 0) {\r\n            await this.updateWhenReachStartIndex(visibleElement, updateData);\r\n        }\r\n        // When reach end index but may not reach scroll end.\r\n        else if (this.endIndex === this.totalDataCount) {\r\n            await this.updateWhenReachEndIndex(visibleElement, updateData);\r\n        }\r\n        // When reach start index but not scroll index.\r\n        else if (this.startIndex > 0 && this.scroller.scrollTop === 0) {\r\n            await this.updateWhenReachScrollStart(visibleElement, scrollerRect, updateData);\r\n        }\r\n        // When reach scroll end but not end index.\r\n        else if (this.endIndex < this.totalDataCount && this.scroller.scrollTop + this.scroller.clientHeight === this.scroller.scrollHeight) {\r\n            await this.updateWhenReachScrollEnd(visibleElement, scrollerRect, updateData);\r\n        }\r\n        // Keeps visible element in the same scroll position.\r\n        else if (scrollDirection === 'down') {\r\n            await this.updateNormallyWhenScrollingDown(visibleElement, scrollerRect, updateData);\r\n        }\r\n        // Keeps visible element in the same scroll position.\r\n        else {\r\n            await this.updateNormallyWhenScrollingUp(visibleElement, scrollerRect, updateData);\r\n        }\r\n    }\r\n    /** When reach start index but may not reach scroll start, reset scroll top. */\r\n    async updateWhenReachStartIndex(lastVisibleElement, updateData) {\r\n        let visibleIndex = this.endIndex - 1 - this.startIndex;\r\n        let oldTop = lastVisibleElement.getBoundingClientRect().top;\r\n        this.updateSliderPosition('top', 0);\r\n        // Render to locate first item.\r\n        updateData();\r\n        await queue_1.untilRenderComplete();\r\n        // Should keep the visible element stable.\r\n        let newVisibleElement = this.sliderChildren.childAt(visibleIndex);\r\n        let newTop = newVisibleElement.getBoundingClientRect().top;\r\n        let translate = newTop - oldTop;\r\n        // Set scroll top to restore it's translate, `scrollTop` property is opposite with translation, so here it's `+`.\r\n        this.scroller.scrollTop = this.scroller.scrollTop + translate;\r\n    }\r\n    /** When reach end index but may not reach scroll end, reset scroll top. */\r\n    async updateWhenReachEndIndex(firstVisibleElement, updateData) {\r\n        let visibleIndex = 0;\r\n        let oldBottom = firstVisibleElement.getBoundingClientRect().bottom;\r\n        // Render to locate last item.\r\n        updateData();\r\n        await queue_1.untilRenderComplete();\r\n        // Get element translated.\r\n        let newVisibleElement = this.sliderChildren.childAt(visibleIndex);\r\n        let newBottom = newVisibleElement.getBoundingClientRect().bottom;\r\n        let translate = newBottom - oldBottom;\r\n        // Get new position.\r\n        let scrollerRect = this.getScrollerClientRect();\r\n        let sliderRect = this.slider.getBoundingClientRect();\r\n        // should minus translate normally, but bottom property is opposite with translation, so here it's `+`.\r\n        let position = scrollerRect.bottom - sliderRect.bottom + translate;\r\n        position -= this.scroller.scrollTop;\r\n        this.updateSliderPosition('bottom', position);\r\n    }\r\n    /** When reach scroll start but not reach start index, provide more scroll space. */\r\n    async updateWhenReachScrollStart(lastVisibleElement, scrollerRect, updateData) {\r\n        // Provide more spaces at start.\r\n        let extendedScrollSpace = this.averageItemHeight * this.startIndex;\r\n        // Translate position from the spaces.\r\n        let position = scrollerRect.bottom - lastVisibleElement.getBoundingClientRect().bottom;\r\n        position -= extendedScrollSpace;\r\n        this.updateSliderPosition('bottom', position);\r\n        updateData();\r\n        this.scroller.scrollTop = extendedScrollSpace;\r\n        await queue_1.untilRenderComplete();\r\n    }\r\n    /** When reach scroll end but not reach end index, provide more scroll space. */\r\n    async updateWhenReachScrollEnd(firstVisibleElement, scrollerRect, updateData) {\r\n        // Update normally.\r\n        let position = firstVisibleElement.getBoundingClientRect().top - scrollerRect.top;\r\n        position += this.scroller.scrollTop;\r\n        this.updateSliderPosition('top', position);\r\n        updateData();\r\n        await queue_1.untilRenderComplete();\r\n    }\r\n    /** Render more items when scrolling down, not reset scroll position. */\r\n    async updateNormallyWhenScrollingDown(firstVisibleElement, scrollerRect, updateData) {\r\n        let position = firstVisibleElement.getBoundingClientRect().top - scrollerRect.top;\r\n        position += this.scroller.scrollTop;\r\n        this.updateSliderPosition('top', position);\r\n        updateData();\r\n        await queue_1.untilRenderComplete();\r\n    }\r\n    /** Render more items when scrolling up, not reset scroll position. */\r\n    async updateNormallyWhenScrollingUp(lastVisibleElement, scrollerRect, updateData) {\r\n        let position = scrollerRect.bottom - lastVisibleElement.getBoundingClientRect().bottom;\r\n        position -= this.scroller.scrollTop;\r\n        this.updateSliderPosition('bottom', position);\r\n        updateData();\r\n        await queue_1.untilRenderComplete();\r\n    }\r\n}\r\nexports.PartialRenderingProcessor = PartialRenderingProcessor;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RepetitiveTemplate = void 0;\r\nconst template_1 = require(\"../../template\");\r\nconst watchers_1 = require(\"../../watchers\");\r\n/**\r\n * A `repeat` directive can only watches top level data changes,\r\n * can't watch property changes of each `item`.\r\n * So this class is used to watch and update template result that generated from `templateFn` and one `item`.\r\n */\r\nclass RepetitiveTemplate {\r\n    constructor(source, item, index) {\r\n        this.source = source;\r\n        this.item = item;\r\n        this.index = index;\r\n        let context = source.getContext();\r\n        // Update after components and top level watchers update completed,\r\n        // and also after directive updated, or it will cause useless updating.\r\n        this.watcher = new watchers_1.LazyWatcher(this.getTemplateResult.bind(this), this.onUpdateTemplateResult.bind(this), context);\r\n        this.template = new template_1.Template(this.watcher.value, context);\r\n        this.getWatcherGroup().add(this.watcher);\r\n    }\r\n    /** Get watcher group to add or delete watcher. */\r\n    getWatcherGroup() {\r\n        let context = this.source.getContext();\r\n        return (context === null || context === void 0 ? void 0 : context.__getWatcherGroup()) || watchers_1.GlobalWatcherGroup;\r\n    }\r\n    /** To get current template result for watching. */\r\n    getTemplateResult() {\r\n        let templateFn = this.source.getTemplateFn();\r\n        return templateFn(this.item, this.index);\r\n    }\r\n    /** After template result changed. */\r\n    onUpdateTemplateResult(result) {\r\n        if (this.template.canMergeWith(result)) {\r\n            this.template.merge(result);\r\n        }\r\n        else {\r\n            let context = this.source.getContext();\r\n            let newTemplate = new template_1.Template(result, context);\r\n            this.template.replaceWith(newTemplate);\r\n            this.template = newTemplate;\r\n        }\r\n    }\r\n    /** Update item and indices. */\r\n    update(item, index) {\r\n        this.item = item;\r\n        this.index = index;\r\n        this.watcher.update();\r\n    }\r\n    /** Remove elements and disconnect. Can connect again later. */\r\n    remove() {\r\n        this.disconnect();\r\n        this.template.remove();\r\n    }\r\n    /** Just disconnect. */\r\n    disconnect() {\r\n        this.getWatcherGroup().delete(this.watcher);\r\n    }\r\n    /** Connect after disconnected. */\r\n    connect() {\r\n        this.getWatcherGroup().add(this.watcher);\r\n    }\r\n}\r\nexports.RepetitiveTemplate = RepetitiveTemplate;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar define_1 = require(\"./define\");\r\nObject.defineProperty(exports, \"defineDirective\", { enumerable: true, get: function () { return define_1.defineDirective; } });\r\nObject.defineProperty(exports, \"refDirective\", { enumerable: true, get: function () { return define_1.refDirective; } });\r\nObject.defineProperty(exports, \"DirectiveResult\", { enumerable: true, get: function () { return define_1.DirectiveResult; } });\r\nObject.defineProperty(exports, \"DirectiveReferences\", { enumerable: true, get: function () { return define_1.DirectiveReferences; } });\r\nvar cache_1 = require(\"./cache\");\r\nObject.defineProperty(exports, \"cache\", { enumerable: true, get: function () { return cache_1.cache; } });\r\nObject.defineProperty(exports, \"CacheDirective\", { enumerable: true, get: function () { return cache_1.CacheDirective; } });\r\nvar toggle_1 = require(\"./toggle\");\r\nObject.defineProperty(exports, \"toggle\", { enumerable: true, get: function () { return toggle_1.toggle; } });\r\nObject.defineProperty(exports, \"ToggleDirective\", { enumerable: true, get: function () { return toggle_1.ToggleDirective; } });\r\nvar repeat_1 = require(\"./repeat\");\r\nObject.defineProperty(exports, \"repeat\", { enumerable: true, get: function () { return repeat_1.repeat; } });\r\nObject.defineProperty(exports, \"RepeatDirective\", { enumerable: true, get: function () { return repeat_1.RepeatDirective; } });\r\nvar live_repeat_1 = require(\"./live-repeat\");\r\nObject.defineProperty(exports, \"liveRepeat\", { enumerable: true, get: function () { return live_repeat_1.liveRepeat; } });\r\nObject.defineProperty(exports, \"LiveRepeatDirective\", { enumerable: true, get: function () { return live_repeat_1.LiveRepeatDirective; } });\r\nvar live_async_repeat_1 = require(\"./live-async-repeat\");\r\nObject.defineProperty(exports, \"liveAsyncRepeat\", { enumerable: true, get: function () { return live_async_repeat_1.liveAsyncRepeat; } });\r\nObject.defineProperty(exports, \"LiveAsyncRepeatDirective\", { enumerable: true, get: function () { return live_async_repeat_1.LiveAsyncRepeatDirective; } });\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.liveAsyncRepeat = exports.LiveAsyncRepeatDirective = void 0;\r\nconst define_1 = require(\"./define\");\r\nconst live_repeat_1 = require(\"./live-repeat\");\r\nconst observer_1 = require(\"../observer\");\r\nconst queue_1 = require(\"../queue\");\r\nconst page_data_getter_1 = require(\"./helpers/page-data-getter\");\r\n// One issue that is not solved:\r\n// If data changed in backend and cause data duplicating or missing, it's hard to handle handle it.\r\n// Right now we can trigger totally or partially updating from API, if we can detected it.\r\n// Otherwise it's possible to detect data duplicating in frontend by a configuration `key`.\r\n// So we don't show duplicate items for current rendering result.\r\n// What we may do in future?\r\n// When we detected duplicated items, we use them to update old items with same keys, and remove them from current page.\r\n// This will cause we may can't cover current page and need to load more data, but should not frequently.\r\n// And it also cause cached paged data doesn't have fixed size,\r\n// such that we must count size of cached data of each page to fetch the data from `startIndex` to `endIndex`.\r\nclass LiveAsyncRepeatDirective extends live_repeat_1.LiveRepeatDirective {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** If specified, we can avoid duplicate items with same key shown in same time. */\r\n        this.key = null;\r\n        /** Need to call `updateSliderPosition` after got `knownDataCount`. */\r\n        this.needToUpdateSliderPositionAfterDataCountKnown = false;\r\n        /** Whether will update later. */\r\n        this.willUpdateLater = false;\r\n        /** Whether will update data count later. */\r\n        this.willUpdateDataCountLater = false;\r\n        /** Update version. */\r\n        this.version = 0;\r\n    }\r\n    merge(dataOptions, templateFn, liveRepeatOptions, transitionOptions) {\r\n        this.dataCount = dataOptions.dataCount;\r\n        this.templateFn = templateFn;\r\n        this.options.update(liveRepeatOptions);\r\n        this.transition.updateOptions(transitionOptions);\r\n        this.updatePreRendered();\r\n        if (liveRepeatOptions === null || liveRepeatOptions === void 0 ? void 0 : liveRepeatOptions.renderCount) {\r\n            this.processor.updateRenderCount(liveRepeatOptions.renderCount);\r\n        }\r\n        let firstTimeUpdate = !this.dataGetter;\r\n        if (firstTimeUpdate) {\r\n            this.dataGetter = new page_data_getter_1.PageDataGetter(dataOptions.asyncDataGetter, dataOptions.immediateDataGetter);\r\n            this.getDataCountThenUpdate();\r\n        }\r\n        else if (!this.willUpdateLater) {\r\n            this.update();\r\n        }\r\n    }\r\n    __updateImmediately() {\r\n        if (!this.willUpdateLater) {\r\n            this.processor.updateRendering(this.updateFromIndices.bind(this));\r\n        }\r\n    }\r\n    checkCoverage() {\r\n        if (!this.willUpdateLater) {\r\n            super.checkCoverage();\r\n        }\r\n    }\r\n    async getDataCountThenUpdate() {\r\n        let dataCountConfig = this.dataCount;\r\n        if (!dataCountConfig) {\r\n            return;\r\n        }\r\n        if (this.willUpdateDataCountLater) {\r\n            return;\r\n        }\r\n        this.willUpdateDataCountLater = true;\r\n        this.willUpdateLater = true;\r\n        // Wait a little while to see if more update data count requests come.\r\n        await Promise.resolve();\r\n        // If more requests comes when updating it, accept new.\r\n        this.willUpdateDataCountLater = false;\r\n        let version = ++this.version;\r\n        let dataCount;\r\n        let knownDataCount = 0;\r\n        if (typeof dataCountConfig === 'function') {\r\n            dataCount = dataCountConfig();\r\n        }\r\n        else {\r\n            dataCount = dataCountConfig;\r\n        }\r\n        if (dataCount instanceof Promise) {\r\n            knownDataCount = await dataCount;\r\n        }\r\n        else {\r\n            knownDataCount = dataCount;\r\n        }\r\n        if (version === this.version) {\r\n            this.processor.updateDataCount(knownDataCount);\r\n            this.update();\r\n            this.willUpdateLater = false;\r\n        }\r\n    }\r\n    updateFromIndices(startIndex, endIndex, scrollDirection) {\r\n        this.startIndex = startIndex;\r\n        this.endIndex = endIndex;\r\n        let items = this.dataGetter.getImmediateData(startIndex, endIndex);\r\n        let fresh = !items.some(item => item === null || item === undefined);\r\n        this.updateLiveData(items, scrollDirection);\r\n        this.triggerLiveAsyncDataEvents(scrollDirection, fresh);\r\n        if (!fresh) {\r\n            let updateVersion = ++this.updateVersion;\r\n            this.dataGetter.getFreshData(startIndex, endIndex).then((data) => {\r\n                if (updateVersion === this.updateVersion) {\r\n                    this.updateLiveData(data, scrollDirection);\r\n                    this.triggerLiveAsyncDataEvents(scrollDirection, true);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    updateLiveData(data, scrollDirection) {\r\n        if (this.key) {\r\n            data = this.uniqueDataByKey(data);\r\n        }\r\n        data = data.map(observer_1.observe);\r\n        super.updateLiveData(data, scrollDirection);\r\n    }\r\n    uniqueDataByKey(data) {\r\n        let set = new Set();\r\n        return data.filter(item => {\r\n            if (item) {\r\n                let id = item[this.key];\r\n                if (set.has(id)) {\r\n                    return false;\r\n                }\r\n                else {\r\n                    set.add(id);\r\n                }\r\n            }\r\n            return true;\r\n        });\r\n    }\r\n    triggerLiveAsyncDataEvents(scrollDirection, fresh) {\r\n        this.emit('liveDataUpdated', this.liveData, this.startIndex, scrollDirection, fresh);\r\n        queue_1.onRenderComplete(() => {\r\n            this.emit('liveDataRendered', this.liveData, this.startIndex, scrollDirection, fresh);\r\n        });\r\n    }\r\n    /**\r\n     * Reload data count and refresh to get all needed data.\r\n     * Call this when data order column changed and you want to keep scroll position, e.g., after sorting. */\r\n    reload() {\r\n        this.getDataCountThenUpdate();\r\n    }\r\n    /** Resolved until `liveDataUpdated` triggered. */\r\n    untilUpdated() {\r\n        return new Promise(resolve => {\r\n            this.once('liveDataUpdated', () => resolve());\r\n        });\r\n    }\r\n    /** Resolved until `liveDataUpdated` triggered with fresh data. */\r\n    untilFreshUpdated() {\r\n        return new Promise(resolve => {\r\n            let listener = (_liveData, _startIndex, _scrollDirection, fresh) => {\r\n                if (fresh) {\r\n                    this.off('liveDataUpdated', listener);\r\n                    resolve();\r\n                }\r\n            };\r\n            this.once('liveDataUpdated', listener);\r\n        });\r\n    }\r\n    /** Resolved until `liveDataRendered` triggered. */\r\n    untilRendered() {\r\n        return new Promise(resolve => {\r\n            this.once('liveDataRendered', () => resolve());\r\n        });\r\n    }\r\n    /** Resolved until `liveDataRendered` triggered with fresh data. */\r\n    untilFreshRendered() {\r\n        return new Promise(resolve => {\r\n            let listener = (_liveData, _startIndex, _scrollDirection, fresh) => {\r\n                if (fresh) {\r\n                    this.off('liveDataRendered', listener);\r\n                    resolve();\r\n                }\r\n            };\r\n            this.once('liveDataRendered', listener);\r\n        });\r\n    }\r\n}\r\nexports.LiveAsyncRepeatDirective = LiveAsyncRepeatDirective;\r\n/**\r\n * Gerenate live repeat elements, reuse elements as much as possible when data changed.\r\n * Compare to `repeat` directive, it will only show partial elements in viewport when you scroll it.\r\n * @param options Options for live rendering.\r\n * @param templateFn The fucntion which will return a template from one iterable data and index position.\r\n * @param transitionOptions The transition options, it can be a transition name, property or properties, or {transition, enterAtStart}.\r\n */\r\nexports.liveAsyncRepeat = define_1.defineDirective(LiveAsyncRepeatDirective);\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.liveRepeat = exports.LiveRepeatDirective = void 0;\r\nconst define_1 = require(\"./define\");\r\nconst contextual_transition_1 = require(\"../internals/contextual-transition\");\r\nconst repetitive_template_1 = require(\"./helpers/repetitive-template\");\r\nconst dom_event_1 = require(\"../internals/dom-event\");\r\nconst updatable_options_1 = require(\"../internals/updatable-options\");\r\nconst partial_rendering_processor_1 = require(\"./helpers/partial-rendering-processor\");\r\nconst internal_event_emitter_1 = require(\"../internals/internal-event-emitter\");\r\nconst watchers_1 = require(\"../watchers\");\r\nconst edit_1 = require(\"../helpers/edit\");\r\nconst utils_1 = require(\"../helpers/utils\");\r\nconst queue_1 = require(\"../queue\");\r\nconst offset_children_1 = require(\"./helpers/offset-children\");\r\nconst updatable_queue_1 = require(\"../queue/helpers/updatable-queue\");\r\n/** Default `liveRepeat` options. */\r\nconst DefaultLiveRepeatOptions = {\r\n    renderCount: 50,\r\n    preRendering: false,\r\n};\r\nclass LiveRepeatDirective extends internal_event_emitter_1.InternalEventEmitter {\r\n    constructor(anchor, context) {\r\n        super();\r\n        this.options = new updatable_options_1.UpdatableOptions(DefaultLiveRepeatOptions);\r\n        /** Cached last data that comes from outside, before been processed. */\r\n        this.rawData = null;\r\n        /** Full data. */\r\n        this.fullData = [];\r\n        /** Current rendered part of data. */\r\n        this.liveData = [];\r\n        /** Current rendered templates, maps with `lastData` one by one. */\r\n        this.repTems = [];\r\n        /** Watcher to watch data changes. */\r\n        this.lastWatcher = null;\r\n        /** The start index of first item in the whole data. */\r\n        this.startIndex = 0;\r\n        /** The end index of next position of last item in the whole data. */\r\n        this.endIndex = 0;\r\n        /** All current items and pre-prendered items. */\r\n        this.preRendered = null;\r\n        /** Indicates current updating. */\r\n        this.updateVersion = 0;\r\n        this.anchor = anchor;\r\n        this.context = context;\r\n        let slider = this.anchor.el.parentElement;\r\n        let scroller = slider.parentElement;\r\n        if (!slider || !scroller || scroller.children.length !== 1) {\r\n            throw new Error(`\"liveRepeat\" must be contained in the HTML struct like \\`\n\t\t\t\t<div title=\"as a scroll parent\" style=\"overflow: auto | scroll; position: relative;\">\n\t\t\t\t\t<div title=\"as a scroll slider\" style=\"position: absolute;\">\n\t\t\t\t\t\t\\${liveRepeat(...)}\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\\`!`);\r\n        }\r\n        this.transition = new contextual_transition_1.ContextualTransition(context);\r\n        this.sliderChildren = new offset_children_1.OffsetChildren(slider, utils_1.getElementCountBefore(anchor.el));\r\n        this.processor = new partial_rendering_processor_1.PartialRenderingProcessor(scroller, slider, this.sliderChildren);\r\n        this.scroller = scroller;\r\n        this.slider = slider;\r\n        dom_event_1.on(scroller, 'scroll.passive', this.checkCoverage, this);\r\n        let ResizeObserver = window.ResizeObserver;\r\n        if (ResizeObserver) {\r\n            this.observer = new ResizeObserver(this.checkCoverage.bind(this));\r\n            this.observer.observe(this.scroller);\r\n        }\r\n        else {\r\n            dom_event_1.on(window, 'resize', this.checkCoverage, this);\r\n        }\r\n    }\r\n    canMergeWith(_data, templateFn) {\r\n        return templateFn === this.templateFn || templateFn.toString() === this.templateFn.toString();\r\n    }\r\n    merge(data, templateFn, liveRepeatOptions, transitionOptions) {\r\n        this.templateFn = templateFn;\r\n        this.options.update(liveRepeatOptions);\r\n        this.transition.updateOptions(transitionOptions);\r\n        this.updatePreRendered();\r\n        if (liveRepeatOptions === null || liveRepeatOptions === void 0 ? void 0 : liveRepeatOptions.renderCount) {\r\n            this.processor.updateRenderCount(liveRepeatOptions.renderCount);\r\n        }\r\n        if (data !== this.rawData) {\r\n            this.watchAndUpdateData(data);\r\n            this.rawData = data;\r\n        }\r\n        else if (this.lastWatcher) {\r\n            this.update();\r\n        }\r\n    }\r\n    updatePreRendered() {\r\n        if (this.options.get('preRendering') && !this.preRendered) {\r\n            this.preRendered = new Map();\r\n        }\r\n        else if (!this.options.get('preRendering') && this.preRendered) {\r\n            this.preRendered = null;\r\n        }\r\n    }\r\n    watchAndUpdateData(data) {\r\n        this.tryDeleteLastWatcher();\r\n        if (!data) {\r\n            this.fullData = [];\r\n            return;\r\n        }\r\n        let watchFn = () => {\r\n            return [...data];\r\n        };\r\n        let onUpdate = (data) => {\r\n            this.fullData = data;\r\n            this.update();\r\n        };\r\n        this.lastWatcher = new watchers_1.LazyWatcher(watchFn, onUpdate, this.context);\r\n        this.getWatcherGroup().add(this.lastWatcher);\r\n        onUpdate(this.lastWatcher.value);\r\n    }\r\n    /** Get watcher group to add or delete watcher. */\r\n    getWatcherGroup() {\r\n        var _a;\r\n        return ((_a = this.context) === null || _a === void 0 ? void 0 : _a.__getWatcherGroup()) || watchers_1.GlobalWatcherGroup;\r\n    }\r\n    /** If have, delete last registered watcher. */\r\n    tryDeleteLastWatcher() {\r\n        if (this.lastWatcher) {\r\n            this.getWatcherGroup().delete(this.lastWatcher);\r\n            this.lastWatcher = null;\r\n        }\r\n    }\r\n    /** Serveral update entry: normal update; from `setStartIndex`, from `reload`. */\r\n    update() {\r\n        // Update after watchers and components.\r\n        queue_1.enqueueUpdatableInOrder(this, this.context, updatable_queue_1.UpdatableUpdateOrder.Directive);\r\n    }\r\n    __updateImmediately() {\r\n        this.processor.updateDataCount(this.fullData.length);\r\n        this.processor.updateRendering(this.updateFromIndices.bind(this));\r\n    }\r\n    /** Returns a promise which will be resolved after data updated and renderer. */\r\n    untilDataUpdatedAndRendered() {\r\n        return new Promise(resolve => {\r\n            this.once('liveDataRendered', resolve);\r\n        });\r\n    }\r\n    checkCoverage() {\r\n        this.processor.updateRenderingSmoothlyIfNeeded(this.updateFromIndices.bind(this));\r\n    }\r\n    updateFromIndices(startIndex, endIndex, scrollDirection) {\r\n        this.startIndex = startIndex;\r\n        this.endIndex = endIndex;\r\n        this.updateLiveData(this.fullData.slice(startIndex, endIndex), scrollDirection);\r\n        this.triggerLiveDataEvents(scrollDirection);\r\n    }\r\n    updateLiveData(newData, scrollDirection) {\r\n        this.updateVersion++;\r\n        let shouldPaly = this.transition.canPlay();\r\n        let shouldReuse = !shouldPaly && !this.options.get('preRendering');\r\n        let oldData = this.liveData;\r\n        let oldRepTems = this.repTems;\r\n        let editRecord = edit_1.getEditRecord(oldData, newData, shouldReuse);\r\n        this.liveData = newData;\r\n        this.repTems = [];\r\n        for (let record of editRecord) {\r\n            let { type, fromIndex, toIndex, moveFromIndex } = record;\r\n            let oldRepTem = fromIndex < oldRepTems.length && fromIndex !== -1 ? oldRepTems[fromIndex] : null;\r\n            if (type === edit_1.EditType.Delete) {\r\n                this.removeRepTemAndMayPlayLeave(oldRepTem, shouldPaly);\r\n            }\r\n            else {\r\n                let newItem = newData[toIndex];\r\n                if (type === edit_1.EditType.Leave) {\r\n                    this.useMatchedRepTem(oldRepTem, newItem, toIndex);\r\n                }\r\n                else if (type === edit_1.EditType.Move) {\r\n                    this.moveRepTemBefore(oldRepTems[moveFromIndex], oldRepTem);\r\n                    this.useMatchedRepTem(oldRepTems[moveFromIndex], newItem, toIndex);\r\n                }\r\n                else if (type === edit_1.EditType.MoveModify) {\r\n                    this.moveRepTemBefore(oldRepTems[moveFromIndex], oldRepTem);\r\n                    this.reuseRepTem(oldRepTems[moveFromIndex], newItem, toIndex);\r\n                }\r\n                else if (type === edit_1.EditType.Insert) {\r\n                    let newRepTem = this.createRepTem(newItem, toIndex);\r\n                    this.moveRepTemBefore(newRepTem, oldRepTem);\r\n                    if (shouldPaly) {\r\n                        this.mayPlayEnter(newRepTem);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (this.options.get('preRendering')) {\r\n            utils_1.untilIdle().then(() => {\r\n                this.doPreRendering(scrollDirection);\r\n            });\r\n        }\r\n    }\r\n    triggerLiveDataEvents(scrollDirection) {\r\n        this.emit('liveDataUpdated', this.liveData, this.startIndex, scrollDirection);\r\n        queue_1.untilRenderComplete().then(async () => {\r\n            // Wait for another micro task, so can be called after even scrollTop updated.\r\n            await Promise.resolve();\r\n            this.emit('liveDataRendered', this.liveData, this.startIndex, scrollDirection);\r\n        });\r\n    }\r\n    moveRepTemBefore(repTem, nextOldRepTem) {\r\n        if (nextOldRepTem) {\r\n            nextOldRepTem.template.before(repTem.template);\r\n        }\r\n        else {\r\n            this.anchor.insert(repTem.template.extractToFragment());\r\n        }\r\n    }\r\n    useMatchedRepTem(repTem, item, index) {\r\n        repTem.update(item, this.startIndex + index);\r\n        this.repTems.push(repTem);\r\n    }\r\n    reuseRepTem(repTem, item, index) {\r\n        var _a, _b;\r\n        (_a = this.preRendered) === null || _a === void 0 ? void 0 : _a.delete(repTem.item);\r\n        (_b = this.preRendered) === null || _b === void 0 ? void 0 : _b.set(item, repTem);\r\n        repTem.update(item, this.startIndex + index);\r\n        this.repTems.push(repTem);\r\n    }\r\n    createRepTem(item, index) {\r\n        var _a, _b;\r\n        if ((_a = this.preRendered) === null || _a === void 0 ? void 0 : _a.has(item)) {\r\n            let repTem = this.preRendered.get(item);\r\n            repTem.connect();\r\n            repTem.update(item, index);\r\n            this.repTems.push(repTem);\r\n            return repTem;\r\n        }\r\n        else {\r\n            let repTem = new repetitive_template_1.RepetitiveTemplate(this, item, this.startIndex + index);\r\n            this.repTems.push(repTem);\r\n            (_b = this.preRendered) === null || _b === void 0 ? void 0 : _b.set(item, repTem);\r\n            return repTem;\r\n        }\r\n    }\r\n    mayPlayEnter(repTem) {\r\n        let template = repTem.template;\r\n        let firstElement = template.getFirstElement();\r\n        if (firstElement) {\r\n            this.transition.playEnter(firstElement);\r\n        }\r\n    }\r\n    removeRepTemAndMayPlayLeave(repTem, shouldPaly) {\r\n        let template = repTem.template;\r\n        if (shouldPaly) {\r\n            let firstElement = template.getFirstElement();\r\n            if (firstElement) {\r\n                this.transition.playLeave(firstElement).then((finish) => {\r\n                    if (finish) {\r\n                        this.removeRepTem(repTem);\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                this.removeRepTem(repTem);\r\n            }\r\n        }\r\n        else {\r\n            this.removeRepTem(repTem);\r\n        }\r\n    }\r\n    removeRepTem(repTem) {\r\n        repTem.remove();\r\n    }\r\n    /** Get `startIndex` for the start index of current rendered items. */\r\n    getStartIndex() {\r\n        return this.startIndex;\r\n    }\r\n    /**\r\n     * Set `startIndex`, and the item in this index will be at the top start position of the viewport.\r\n     * If needs to update, will update firstly and then set index.\r\n     */\r\n    setStartIndex(index) {\r\n        this.processor.setStartIndex(index);\r\n        this.update();\r\n    }\r\n    /** Whether specifies a start index. */\r\n    isStartIndexSpecified() {\r\n        return this.processor.isStartIndexSpecified();\r\n    }\r\n    /**\r\n     * Get `endIndex` for the end index of current rendered items.\r\n     * The returned value equals index of last index of rendered item +1.\r\n     */\r\n    getEndIndex() {\r\n        return this.startIndex;\r\n    }\r\n    /**\r\n     * Get the index of the first visible element, which can be used to restore scrolling position by `setFirstVisibleIndex`.\r\n     * May cause page reflow.\r\n     */\r\n    getFirstVisibleIndex() {\r\n        return Math.max(0, utils_1.locateFirstVisibleIndex(this.scroller, this.sliderChildren.getChildren())) + this.startIndex;\r\n    }\r\n    /**\r\n     * Get the index of the last visible element.\r\n     * May cause page reflow.\r\n     */\r\n    getLastVisibleIndex() {\r\n        return Math.max(0, utils_1.locateLastVisibleIndex(this.scroller, this.sliderChildren.getChildren()));\r\n    }\r\n    /**\r\n     * Make item in the specified index becomes visible by scrolling minimum pixels.\r\n     * Try to adjust immediately, so you will need to ensure elements rendered.\r\n     * Will re-render if the element in specified index is not rendered.\r\n     */\r\n    async makeIndexVisible(index) {\r\n        if (this.isIndexRendered(index)) {\r\n            return this.scrollToViewRenderedIndex(index);\r\n        }\r\n        else {\r\n            this.setStartIndex(index);\r\n            await this.untilDataUpdatedAndRendered();\r\n            return this.scrollToViewRenderedIndex(index);\r\n        }\r\n    }\r\n    /** Get if item with specified index is rendered. */\r\n    isIndexRendered(index) {\r\n        return index >= this.startIndex && index < this.startIndex + this.liveData.length;\r\n    }\r\n    /** After item in index rendered, make it visible. */\r\n    scrollToViewRenderedIndex(index) {\r\n        let el = this.sliderChildren.childAt(index - this.startIndex);\r\n        if (!el) {\r\n            return false;\r\n        }\r\n        let scrollerRect = this.scroller.getBoundingClientRect();\r\n        let elRect = el.getBoundingClientRect();\r\n        // Below it, need to scroll up.\r\n        if (elRect.bottom > scrollerRect.bottom) {\r\n            this.scroller.scrollTop = this.scroller.scrollTop + (elRect.bottom - scrollerRect.bottom);\r\n        }\r\n        // Above it, need to scroll down.\r\n        else if (elRect.top < scrollerRect.top) {\r\n            this.scroller.scrollTop = this.scroller.scrollTop + (scrollerRect.top - elRect.top);\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Make item in the specified index visible at the top edge of scroller.\r\n     * Try to adjust immediately, so you will need to ensure elements rendered.\r\n     * Will re-render if the element in specified index is not rendered.\r\n     */\r\n    async makeIndexVisibleAtTop(index) {\r\n        if (this.isIndexRendered(index)) {\r\n            return this.scrollToMakeRenderedIndexAtTop(index);\r\n        }\r\n        else {\r\n            this.setStartIndex(index);\r\n            await this.untilDataUpdatedAndRendered();\r\n            return this.scrollToMakeRenderedIndexAtTop(index);\r\n        }\r\n    }\r\n    /**\r\n     * Make item in the specified index becomes visible at the top scroll position.\r\n     * If needs to update, will update firstly and then set index.\r\n     */\r\n    async setFirstVisibleIndex(index) {\r\n        this.setStartIndex(index);\r\n        await this.untilDataUpdatedAndRendered();\r\n        return this.scrollToMakeRenderedIndexAtTop(index);\r\n    }\r\n    /** After item in index rendered, make it becomes visible at the top scroll position. */\r\n    scrollToMakeRenderedIndexAtTop(index) {\r\n        let el = this.sliderChildren.childAt(index - this.startIndex);\r\n        if (!el) {\r\n            return false;\r\n        }\r\n        let scrollerRect = this.scroller.getBoundingClientRect();\r\n        let elRect = el.getBoundingClientRect();\r\n        this.scroller.scrollTop = this.scroller.scrollTop + (elRect.top - scrollerRect.top);\r\n        return true;\r\n    }\r\n    /** Handle pre-rendering */\r\n    async doPreRendering(scrollDirection) {\r\n        let version = this.updateVersion;\r\n        let preRendered = this.preRendered;\r\n        // Determine the maximum range that need to pre-render, must include current range.\r\n        let renderCount = this.options.get('renderCount') * this.processor.getRenderGroupCount();\r\n        let startIndex = Math.max(0, this.startIndex - renderCount);\r\n        let endIndex = Math.min(this.fullData.length, this.endIndex + renderCount);\r\n        // The data and global indices that should be pre-rendered.\r\n        let data = this.fullData.slice(startIndex, endIndex);\r\n        let dataSet = new Set(data);\r\n        let indices = [];\r\n        let restRepTems = [];\r\n        // Rlease items out of maximun range.\r\n        for (let item of preRendered.keys()) {\r\n            if (!dataSet.has(item)) {\r\n                let repTem = preRendered.get(item);\r\n                repTem.disconnect();\r\n                restRepTems.push(repTem);\r\n                preRendered.delete(item);\r\n            }\r\n        }\r\n        // If scrolling down, only pre-render items below.\r\n        if (scrollDirection === 'down' || scrollDirection === null) {\r\n            for (let i = this.endIndex; i < endIndex; i++) {\r\n                indices.push(i);\r\n            }\r\n        }\r\n        else {\r\n            for (let i = startIndex; i < this.startIndex; i++) {\r\n                indices.push(i);\r\n            }\r\n        }\r\n        let createCount = 0;\r\n        for (let index of indices) {\r\n            let item = this.fullData[index];\r\n            if (preRendered.has(item)) {\r\n                continue;\r\n            }\r\n            if (restRepTems.length > 0) {\r\n                let repTem = restRepTems.pop();\r\n                repTem.update(item, index);\r\n                preRendered.set(item, repTem);\r\n            }\r\n            else {\r\n                // Keep it disconnect, so it will not affect rendering performance and still have a rough render results.\r\n                let repTem = new repetitive_template_1.RepetitiveTemplate(this, item, index);\r\n                repTem.disconnect();\r\n                repTem.template.preRender();\r\n                preRendered.set(item, repTem);\r\n                createCount++;\r\n            }\r\n            if (createCount % 15 === 0) {\r\n                await utils_1.untilIdle();\r\n                if (this.updateVersion !== version) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    getContext() {\r\n        return this.context;\r\n    }\r\n    getTemplateFn() {\r\n        return this.templateFn;\r\n    }\r\n    remove() {\r\n        this.tryDeleteLastWatcher();\r\n        dom_event_1.off(this.scroller, 'scroll.passive', this.checkCoverage, this);\r\n        if (this.observer) {\r\n            this.observer.disconnect();\r\n        }\r\n        else {\r\n            dom_event_1.off(window, 'resize', this.checkCoverage, this);\r\n        }\r\n        // Pre-rendering items are not connected, no need to remove them.\r\n        for (let repTem of this.repTems) {\r\n            repTem.remove();\r\n        }\r\n    }\r\n}\r\nexports.LiveRepeatDirective = LiveRepeatDirective;\r\n/**\r\n * `liveRepeat(items, () => html`...`, ?liveRepeatOptions, ?transitionOptions)` gerenates partial elements only in current viewport,\r\n * and keeps re-rendering to cover current viewport after you scrolled.\r\n *\r\n * Note the `liveRepeat` directive must be contained in the html struct like `\r\n *\t <div title=\"as a scroll parent\" style=\"overflow: auto | scroll; position: relative;\">\r\n *\t    <div title=\"as a scroll slider\" style=\"position: absolute;\">\r\n *\t\t  ${liveRepeat(...)}\r\n *\t    </div>\r\n *   </div>`\r\n *\r\n * @param items The iterable data, each item in it will pass to `templateFn`.\r\n * @param templateFn The fucntion which will return a template result from data item and index position. Rendered nodes must be contained in a container element.\r\n * @param liveRepeatOptions Options for live rendering.\r\n * @param transitionOptions The transition options, it can be a transition name, property or properties, or {transition, enterAtStart}.\r\n */\r\nexports.liveRepeat = define_1.defineDirective(LiveRepeatDirective);\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.repeat = exports.RepeatDirective = void 0;\r\nconst define_1 = require(\"./define\");\r\nconst contextual_transition_1 = require(\"../internals/contextual-transition\");\r\nconst repetitive_template_1 = require(\"./helpers/repetitive-template\");\r\nconst watchers_1 = require(\"../watchers\");\r\nconst edit_1 = require(\"../helpers/edit\");\r\nconst utils_1 = require(\"../helpers/utils\");\r\nconst queue_1 = require(\"../queue\");\r\n/**\r\n * `repeat` directive doesn't watches the dependencies when updating a component,\r\n * instead, it watches dependencies when updating each item,\r\n * and update each item indenpent after it's dependencies changed.\r\n */\r\nclass RepeatDirective {\r\n    constructor(anchor, context) {\r\n        /** Cached last data that comes from outside, before been processed. */\r\n        this.rawData = null;\r\n        /** Current rendered data. */\r\n        this.data = [];\r\n        /** Current rendered templates, maps with `lastData` one by one. */\r\n        this.repTems = [];\r\n        /** Watcher to watch data changes. */\r\n        this.lastWatcher = null;\r\n        this.anchor = anchor;\r\n        this.context = context;\r\n        this.transition = new contextual_transition_1.ContextualTransition(context);\r\n    }\r\n    canMergeWith(_data, templateFn) {\r\n        // Compare string of two functions should be fast:\r\n        // string  of function represent as a fixed sring,\r\n        // and strings will compare by hash, not per character.\r\n        return templateFn === this.templateFn || templateFn.toString() === this.templateFn.toString();\r\n    }\r\n    merge(data, templateFn, options) {\r\n        this.templateFn = templateFn;\r\n        this.transition.updateOptions(options);\r\n        // Outer components update frequently,\r\n        // Data has a high rate that not been updated.\r\n        // So here we don't rerender except really found data changes from a inner watcher.\r\n        if (data !== this.rawData) {\r\n            this.watchAndUpdateData(data);\r\n            this.rawData = data;\r\n        }\r\n        else if (this.lastWatcher) {\r\n            this.updateData(this.data);\r\n        }\r\n    }\r\n    watchAndUpdateData(data) {\r\n        this.tryDeleteLastWatcher();\r\n        if (!data) {\r\n            this.updateData([]);\r\n            return;\r\n        }\r\n        // Here read each item of the `Iterable<T>` so we can observe changes like `a[i] = xxx`.\r\n        // Other, here will observe each item of data.\r\n        let watchFn = () => {\r\n            return [...data];\r\n        };\r\n        // Uses lazy watcher to watch each item of data changes,\r\n        // So each item can be updated indepent,\r\n        // and can also avoid unnecessary updating after total directive data updated.\r\n        this.lastWatcher = new watchers_1.LazyWatcher(watchFn, this.updateData.bind(this), this.context);\r\n        this.getWatcherGroup().add(this.lastWatcher);\r\n        this.updateData(this.lastWatcher.value);\r\n    }\r\n    /** Get watcher group to add watcher. */\r\n    getWatcherGroup() {\r\n        var _a;\r\n        return ((_a = this.context) === null || _a === void 0 ? void 0 : _a.__getWatcherGroup()) || watchers_1.GlobalWatcherGroup;\r\n    }\r\n    /** If have, delete last registered watcher. */\r\n    tryDeleteLastWatcher() {\r\n        if (this.lastWatcher) {\r\n            this.getWatcherGroup().delete(this.lastWatcher);\r\n            this.lastWatcher = null;\r\n        }\r\n    }\r\n    updateData(newData) {\r\n        let shouldPaly = this.transition.canPlay();\r\n        let shouldReuse = !shouldPaly;\r\n        let oldData = this.data;\r\n        let oldRepTems = this.repTems;\r\n        let editRecord = edit_1.getEditRecord(oldData, newData, shouldReuse);\r\n        this.data = newData;\r\n        this.repTems = [];\r\n        for (let record of editRecord) {\r\n            let { type, fromIndex, toIndex, moveFromIndex } = record;\r\n            let oldRepTem = fromIndex < oldRepTems.length && fromIndex !== -1 ? oldRepTems[fromIndex] : null;\r\n            let newItem = newData[toIndex];\r\n            if (type === edit_1.EditType.Leave) {\r\n                this.useMatchedRepTem(oldRepTem, newItem, toIndex);\r\n            }\r\n            else if (type === edit_1.EditType.Move) {\r\n                this.moveRepTemBefore(oldRepTems[moveFromIndex], oldRepTem);\r\n                this.useMatchedRepTem(oldRepTems[moveFromIndex], newItem, toIndex);\r\n            }\r\n            else if (type === edit_1.EditType.MoveModify) {\r\n                this.moveRepTemBefore(oldRepTems[moveFromIndex], oldRepTem);\r\n                this.reuseRepTem(oldRepTems[moveFromIndex], newItem, toIndex);\r\n            }\r\n            else if (type === edit_1.EditType.Insert) {\r\n                let newRepTem = this.createRepTem(newItem, toIndex);\r\n                this.moveRepTemBefore(newRepTem, oldRepTem);\r\n                if (shouldPaly) {\r\n                    this.mayPlayEnter(newRepTem);\r\n                }\r\n            }\r\n            else if (type === edit_1.EditType.Delete) {\r\n                this.removeRepTemAndMayPlayLeave(oldRepTem, shouldPaly);\r\n            }\r\n        }\r\n    }\r\n    moveRepTemBefore(repTem, nextOldRepTem) {\r\n        if (nextOldRepTem) {\r\n            nextOldRepTem.template.before(repTem.template);\r\n        }\r\n        else {\r\n            this.anchor.insert(repTem.template.extractToFragment());\r\n        }\r\n    }\r\n    useMatchedRepTem(repTem, item, index) {\r\n        // Must update even reuse matched item,\r\n        // Because scoped variables may changed.\r\n        repTem.update(item, index);\r\n        this.repTems.push(repTem);\r\n    }\r\n    reuseRepTem(repTem, item, index) {\r\n        repTem.update(item, index);\r\n        this.repTems.push(repTem);\r\n    }\r\n    createRepTem(item, index) {\r\n        let repTem = new repetitive_template_1.RepetitiveTemplate(this, item, index);\r\n        this.repTems.push(repTem);\r\n        return repTem;\r\n    }\r\n    mayPlayEnter(repTem) {\r\n        let template = repTem.template;\r\n        let firstElement = template.getFirstElement();\r\n        if (firstElement) {\r\n            this.transition.playEnter(firstElement);\r\n        }\r\n    }\r\n    removeRepTemAndMayPlayLeave(repTem, shouldPaly) {\r\n        let template = repTem.template;\r\n        if (shouldPaly) {\r\n            let firstElement = template.getFirstElement();\r\n            if (firstElement) {\r\n                this.transition.playLeave(firstElement).then((finish) => {\r\n                    if (finish) {\r\n                        this.removeRepTem(repTem);\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                this.removeRepTem(repTem);\r\n            }\r\n        }\r\n        else {\r\n            this.removeRepTem(repTem);\r\n        }\r\n    }\r\n    removeRepTem(repTem) {\r\n        repTem.remove();\r\n    }\r\n    /**\r\n     * Make item in the specified index becomes visible by scrolling minimum pixels in Y direction.\r\n     * Try to adjust immediately, so you will need to ensure elements rendered.\r\n     */\r\n    makeIndexVisible(index) {\r\n        var _a;\r\n        let el = (_a = this.repTems[index]) === null || _a === void 0 ? void 0 : _a.template.getFirstElement();\r\n        if (!el) {\r\n            return false;\r\n        }\r\n        let scroller = utils_1.getClosestScrollWrapper(el);\r\n        if (!scroller) {\r\n            return false;\r\n        }\r\n        let scrollerRect = scroller.getBoundingClientRect();\r\n        let elRect = el.getBoundingClientRect();\r\n        // Below it, need to scroll up.\r\n        if (elRect.bottom > scrollerRect.bottom) {\r\n            scroller.scrollTop = scroller.scrollTop + (elRect.bottom - scrollerRect.bottom);\r\n        }\r\n        // Above it, need to scroll down.\r\n        else if (elRect.top < scrollerRect.top) {\r\n            scroller.scrollTop = scroller.scrollTop + (scrollerRect.top - elRect.top);\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Make item in the specified index visible at the top edge of scroller.\r\n     * Try to adjust immediately, so you will need to ensure elements rendered.\r\n     */\r\n    makeIndexVisibleAtTop(index) {\r\n        var _a;\r\n        let el = (_a = this.repTems[index]) === null || _a === void 0 ? void 0 : _a.template.getFirstElement();\r\n        if (!el) {\r\n            return false;\r\n        }\r\n        let scroller = utils_1.getClosestScrollWrapper(el);\r\n        if (!scroller) {\r\n            return false;\r\n        }\r\n        let scrollerRect = scroller.getBoundingClientRect();\r\n        let elRect = el.getBoundingClientRect();\r\n        scroller.scrollTop = scroller.scrollTop + (elRect.top - scrollerRect.top);\r\n        return true;\r\n    }\r\n    /**\r\n     * Make item in the specified index becomes visible at the top scroll position.\r\n     * If needs to update, will update firstly and then set index.\r\n     */\r\n    async setFirstVisibleIndex(index) {\r\n        var _a;\r\n        await queue_1.untilRenderComplete();\r\n        let el = (_a = this.repTems[index]) === null || _a === void 0 ? void 0 : _a.template.getFirstElement();\r\n        if (!el) {\r\n            return false;\r\n        }\r\n        let scroller = utils_1.getClosestScrollWrapper(el);\r\n        if (!scroller) {\r\n            return false;\r\n        }\r\n        let scrollerRect = scroller.getBoundingClientRect();\r\n        let elRect = el.getBoundingClientRect();\r\n        scroller.scrollTop = scroller.scrollTop + (elRect.top - scrollerRect.top);\r\n        return true;\r\n    }\r\n    getContext() {\r\n        return this.context;\r\n    }\r\n    getTemplateFn() {\r\n        return this.templateFn;\r\n    }\r\n    remove() {\r\n        this.tryDeleteLastWatcher();\r\n        for (let repTem of this.repTems) {\r\n            repTem.remove();\r\n        }\r\n    }\r\n}\r\nexports.RepeatDirective = RepeatDirective;\r\n/**\r\n * `repeat(items, () => html`...`, ?options)` gerenates repeated elements,\r\n * and will reuse elements as much as possible when data changed.\r\n * Currently the repeat directive reuses rendered elements by data objects, no `key` can be specified.\r\n * If you do need to reuse elements by a `key`, try repeat the `key` values.\r\n *\r\n * @param items The iterable data, each item in it will pass to `templateFn`.\r\n * @param templateFn The fucntion which will return a template from one iterable data item and index position.\r\n * @param options The transition options, it can be a transition name, property or properties, or {transition, enterAtStart}.\r\n */\r\nexports.repeat = define_1.defineDirective(RepeatDirective);\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.toggle = exports.ToggleDirective = void 0;\r\nconst define_1 = require(\"./define\");\r\nconst template_1 = require(\"../template\");\r\nconst contextual_transition_1 = require(\"../internals/contextual-transition\");\r\n/**\r\n * Compare to `cache`, if we just want to toggle and play enter and leave transition,\r\n * and don't want to cache elements, we will need this directive.\r\n */\r\nclass ToggleDirective {\r\n    constructor(anchor, context) {\r\n        this.currentTemplate = null;\r\n        this.anchor = anchor;\r\n        this.context = context;\r\n        this.transition = new contextual_transition_1.ContextualTransition(context);\r\n    }\r\n    canMergeWith() {\r\n        return true;\r\n    }\r\n    merge(result, options) {\r\n        this.transition.updateOptions(options);\r\n        if (result) {\r\n            // Matches, merge them. will not play transition.\r\n            if (this.currentTemplate && this.currentTemplate.canMergeWith(result)) {\r\n                this.currentTemplate.merge(result);\r\n            }\r\n            else {\r\n                // Moves out current.\r\n                if (this.currentTemplate) {\r\n                    this.movesOutCurrentTemplate();\r\n                }\r\n                this.makeNewTemplate(result);\r\n            }\r\n        }\r\n        else {\r\n            // Moves out current.\r\n            if (this.currentTemplate) {\r\n                this.movesOutCurrentTemplate();\r\n            }\r\n        }\r\n    }\r\n    async playEnterTransition(template) {\r\n        let firstElement = template.getFirstElement();\r\n        if (firstElement) {\r\n            await this.transition.playEnter(firstElement);\r\n        }\r\n    }\r\n    async movesOutCurrentTemplate() {\r\n        let template = this.currentTemplate;\r\n        let playing = false;\r\n        if (this.transition.shouldPlayLeave()) {\r\n            let firstElement = template.getFirstElement();\r\n            if (firstElement) {\r\n                let finish = await this.transition.playLeave(firstElement);\r\n                if (finish) {\r\n                    template.remove();\r\n                }\r\n            }\r\n            playing = true;\r\n        }\r\n        if (!playing) {\r\n            template.movesOut();\r\n        }\r\n        this.currentTemplate = null;\r\n    }\r\n    makeNewTemplate(result) {\r\n        let template = new template_1.Template(result, this.context);\r\n        this.anchor.insert(template.extractToFragment());\r\n        this.tryPlayEnterTransition(template);\r\n        this.currentTemplate = template;\r\n    }\r\n    async tryPlayEnterTransition(template) {\r\n        if (this.transition.shouldPlayEnter()) {\r\n            let firstElement = template.getFirstElement();\r\n            if (firstElement) {\r\n                await this.transition.playEnter(firstElement);\r\n            }\r\n        }\r\n    }\r\n    remove() {\r\n        if (this.currentTemplate) {\r\n            this.currentTemplate.remove();\r\n        }\r\n    }\r\n}\r\nexports.ToggleDirective = ToggleDirective;\r\n/**\r\n * `toggle(changableContent, ?options)` toggles rendering content and can play enter or leave transition easily.\r\n *\r\n * @param result The html`...` result, can be `null` or empty string.\r\n * @param options Options for transition.\r\n */\r\nexports.toggle = define_1.defineDirective(ToggleDirective);\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getRenderedAsComponent = exports.renderUpdatable = exports.render = void 0;\r\nconst template_1 = require(\"../template\");\r\nconst component_1 = require(\"../component\");\r\nconst directives_1 = require(\"../directives\");\r\nconst watchers_1 = require(\"../watchers\");\r\n/**\r\n * Render html codes or a template result like html`...` within a `context`.\r\n * Returns the rendered template, you may append it to another element,\r\n * or extract to a fragment and insert into any place.\r\n * Otherwise you can also patch it with another template result.\r\n *\r\n * @param codes The html code piece or html`...` template result, or a directive result.\r\n * @param context The context to use when rendering.\r\n * @return A `Template` instance.\r\n */\r\nfunction render(codes, context = null) {\r\n    if (codes instanceof directives_1.DirectiveResult) {\r\n        codes = template_1.html `${codes}`;\r\n    }\r\n    let template = new template_1.Template(codes, context);\r\n    return template;\r\n}\r\nexports.render = render;\r\n/**\r\n * Render template result like html`...` that returned from `renderFn`.\r\n * Returns the rendered template, you may append it to another element,\r\n * or extract to a fragment and insert into any place.\r\n * Otherwise returns a `unwatch` function, call which will stop watching `renderFn`.\r\n *\r\n * Will watch `renderFn`, If it's dependent datas changed, will automaticaly updated and call `onUpdate`.\r\n *\r\n * @param renderFn Returns template like html`...`\r\n * @param context The context you used when rendering.\r\n * @param onUpdate Called when update after referenced data changed. if new result can't merge with old, will pass a new fragment as parameter.\r\n * @return A `{template, unwatch}` object, calls `unwatch` will stop watching `renderFn`. If `context` specifed, will unwatch automatically after context revoked.\r\n */\r\nfunction renderUpdatable(renderFn, context = null, onUpdate) {\r\n    let template;\r\n    let unwatch = (context || watchers_1.GlobalWatcherGroup).watchImmediately(renderFn, (result) => {\r\n        if (result instanceof directives_1.DirectiveResult) {\r\n            result = template_1.html `${result}`;\r\n        }\r\n        if (template) {\r\n            template.merge(result);\r\n            if (onUpdate) {\r\n                onUpdate();\r\n            }\r\n        }\r\n        else {\r\n            template = new template_1.Template(result, context);\r\n        }\r\n    });\r\n    return {\r\n        template: template,\r\n        unwatch,\r\n    };\r\n}\r\nexports.renderUpdatable = renderUpdatable;\r\n/**\r\n * Get a component immediately from a just rendered template.\r\n * @param template The just rendered template from `render` or `renderUpdatable`.\r\n * @returns A component if first element has a component registered, otherwise be `null`.\r\n */\r\nfunction getRenderedAsComponent(template) {\r\n    let firstElement = template.getFirstElement();\r\n    if (firstElement && firstElement.localName.includes('-')) {\r\n        return component_1.createComponent(firstElement);\r\n    }\r\n    return null;\r\n}\r\nexports.getRenderedAsComponent = getRenderedAsComponent;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar component_1 = require(\"../component\");\r\nObject.defineProperty(exports, \"updateAllComponents\", { enumerable: true, get: function () { return component_1.updateAllComponents; } });\r\nObject.defineProperty(exports, \"updateAllStyles\", { enumerable: true, get: function () { return component_1.updateAllStyles; } });\r\nvar watchers_1 = require(\"../watchers\");\r\nObject.defineProperty(exports, \"updateAllGlobalWatchers\", { enumerable: true, get: function () { return watchers_1.updateAllGlobalWatchers; } });\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getEditRecord = exports.EditType = void 0;\r\nconst two_way_map_1 = require(\"./two-way-map\");\r\nvar EditType;\r\n(function (EditType) {\r\n    /**\r\n     * Ignores, will be used later as a matched item or reuse it.\r\n     * Used internal, no need to handle it in your code.\r\n     */\r\n    EditType[EditType[\"Skip\"] = 0] = \"Skip\";\r\n    /** Leaves because of match. */\r\n    EditType[EditType[\"Leave\"] = 1] = \"Leave\";\r\n    /** Moves same item from it's old index to current index. */\r\n    EditType[EditType[\"Move\"] = 2] = \"Move\";\r\n    // /** Modify item and not move it, not supported because we don't validate position of reuseable element. */\r\n    // Modify,\r\n    /** Move + Modify. */\r\n    EditType[EditType[\"MoveModify\"] = 3] = \"MoveModify\";\r\n    /** Insert a new one. */\r\n    EditType[EditType[\"Insert\"] = 4] = \"Insert\";\r\n    /** Delete. */\r\n    EditType[EditType[\"Delete\"] = 5] = \"Delete\";\r\n})(EditType = exports.EditType || (exports.EditType = {}));\r\n/** Get a edit record from an old indices graph to a new one. */\r\nfunction getEditRecord(oldItems, newItems, willReuse) {\r\n    if (newItems.length === 0) {\r\n        return oldItems.map((_item, index) => {\r\n            return {\r\n                type: EditType.Delete,\r\n                fromIndex: index,\r\n                toIndex: -1,\r\n                moveFromIndex: -1,\r\n            };\r\n        });\r\n    }\r\n    else if (oldItems.length === 0) {\r\n        return newItems.map((_item, index) => {\r\n            return {\r\n                type: EditType.Insert,\r\n                fromIndex: 0,\r\n                toIndex: index,\r\n                moveFromIndex: -1,\r\n            };\r\n        });\r\n    }\r\n    else {\r\n        return getNormalEditRecord(oldItems, newItems, willReuse);\r\n    }\r\n}\r\nexports.getEditRecord = getEditRecord;\r\n/**\r\n * When `oldItems` and `newItems` are both not empty.\r\n * When `willReuse` is `false`, will never reuse items.\r\n */\r\nfunction getNormalEditRecord(oldItems, newItems, willReuse) {\r\n    // indexMap: old index <-> new index.\r\n    let { indexMap, restOldIndices } = makeTwoWayIndexMap(oldItems, newItems);\r\n    // All the new index that have an old index map, and order by their order in the `oldItems`.\r\n    let indicesInNew = [];\r\n    for (let oldIndex of indexMap.getAllLeft()) {\r\n        let indexInNew = indexMap.getFromLeft(oldIndex);\r\n        indicesInNew.push(indexInNew);\r\n    }\r\n    // Get a increased sequence from new indices that have an old index map, so no need move this part.\r\n    let stableNewIndexStack = new ReadonlyStack(findLongestIncreasedSequence(indicesInNew));\r\n    // Count of items that will be reused.\r\n    let restOldIndicesStack = new ReadonlyStack(restOldIndices);\r\n    // Another optimization:\r\n    // After get stable items, some reuseable items between two stable items can be reused without moving.\r\n    // This is good when data is absolutely random, but not help much for normal data.\r\n    let edit = [];\r\n    let oldIndex = 0;\r\n    let newIndex = 0;\r\n    let nextStableNewIndex = stableNewIndexStack.getNext();\r\n    let nextStableOldIndex = indexMap.getFromRight(nextStableNewIndex);\r\n    while (oldIndex < oldItems.length || newIndex < newItems.length) {\r\n        let type;\r\n        let moveFromIndex = -1;\r\n        let fromIndex = oldIndex;\r\n        let toIndex = newIndex;\r\n        // New ended, delete old.\r\n        if (newIndex === newItems.length) {\r\n            type = EditType.Skip;\r\n            oldIndex++;\r\n        }\r\n        // Old not matches, leaves old to be reused or deletes it.\r\n        else if (oldIndex !== nextStableOldIndex && oldIndex < oldItems.length) {\r\n            type = EditType.Skip;\r\n            oldIndex++;\r\n        }\r\n        // Old and new matches, skip them all.\r\n        else if (newIndex === nextStableNewIndex) {\r\n            type = EditType.Leave;\r\n            oldIndex++;\r\n            newIndex++;\r\n            nextStableNewIndex = stableNewIndexStack.isEnded() ? -1 : stableNewIndexStack.getNext();\r\n            nextStableOldIndex = nextStableNewIndex === -1 ? -1 : indexMap.getFromRight(nextStableNewIndex);\r\n        }\r\n        // Moves old to new position.\r\n        else if (indexMap.hasRight(newIndex)) {\r\n            type = EditType.Move;\r\n            moveFromIndex = indexMap.getFromRight(newIndex);\r\n            newIndex++;\r\n        }\r\n        // Reuses old.\r\n        else if (willReuse && !restOldIndicesStack.isEnded()) {\r\n            type = EditType.MoveModify;\r\n            moveFromIndex = restOldIndicesStack.getNext();\r\n            newIndex++;\r\n        }\r\n        // Creates new.\r\n        else {\r\n            type = EditType.Insert;\r\n            moveFromIndex = -1;\r\n            newIndex++;\r\n        }\r\n        if (type !== EditType.Skip) {\r\n            edit.push({\r\n                type,\r\n                fromIndex,\r\n                toIndex,\r\n                moveFromIndex,\r\n            });\r\n        }\r\n    }\r\n    // Removes not used items.\r\n    while (!restOldIndicesStack.isEnded()) {\r\n        let fromIndex = restOldIndicesStack.getNext();\r\n        edit.push({\r\n            type: EditType.Delete,\r\n            fromIndex,\r\n            toIndex: -1,\r\n            moveFromIndex: -1,\r\n        });\r\n    }\r\n    return edit;\r\n}\r\n/** Create a 2 way index map: old index <-> new index, just like a sql inner join. */\r\nfunction makeTwoWayIndexMap(oldItems, newItems) {\r\n    // Have a little problem, will find last match when repeated items exist.\r\n    let newItemIndexMap = new Map(newItems.map((item, index) => [item, index]));\r\n    // old index <-> new index.\r\n    let indexMap = new two_way_map_1.TwoWayMap();\r\n    let restOldIndices = [];\r\n    for (let i = 0; i < oldItems.length; i++) {\r\n        let oldItem = oldItems[i];\r\n        if (newItemIndexMap.has(oldItem)) {\r\n            indexMap.add(i, newItemIndexMap.get(oldItem));\r\n            // Must delete, or will cause error when same item exist.\r\n            newItemIndexMap.delete(oldItem);\r\n        }\r\n        else {\r\n            restOldIndices.push(i);\r\n        }\r\n    }\r\n    return { indexMap, restOldIndices };\r\n}\r\n/**\r\n * A simple stack can get next one from start.\r\n * Can avoid shift or pop operation from an array.\r\n */\r\nclass ReadonlyStack {\r\n    constructor(items) {\r\n        this.offset = 0;\r\n        this.items = items;\r\n    }\r\n    isEnded() {\r\n        return this.offset >= this.items.length;\r\n    }\r\n    getNext() {\r\n        return this.items[this.offset++];\r\n    }\r\n}\r\n/** 237456 -> 23456 */\r\nfunction findLongestIncreasedSequence(items) {\r\n    // In the first loop, we try to find each increased sequence.\r\n    // 237456 -> [23, 7, 456]\r\n    let startIndex = 0;\r\n    let increasedSequenceIndices = [];\r\n    for (let i = 1; i < items.length; i++) {\r\n        if (items[i] < items[i - 1]) {\r\n            increasedSequenceIndices.push([startIndex, i]);\r\n            startIndex = i;\r\n        }\r\n    }\r\n    if (startIndex < items.length) {\r\n        increasedSequenceIndices.push([startIndex, items.length]);\r\n    }\r\n    // In the second loop, we try to find the longest discreate increased sequence.\r\n    // [23, 7, 456]\r\n    // 23 -> 7 excluded -> 456\r\n    // [2, 78, 456]\r\n    // 2 -> 78 replaced -> 456 replaced\r\n    let longest = [];\r\n    let currentValue = -1;\r\n    for (let i = 0; i < increasedSequenceIndices.length; i++) {\r\n        let [start, end] = increasedSequenceIndices[i];\r\n        if (items[start] > currentValue) {\r\n            longest = [...longest, ...items.slice(start, end)];\r\n            currentValue = longest[longest.length - 1];\r\n        }\r\n        else if (end - start > longest.length) {\r\n            longest = items.slice(start, end);\r\n            currentValue = longest[longest.length - 1];\r\n        }\r\n    }\r\n    return longest;\r\n}\r\n","\"use strict\";\r\n// Reference to: Book <<Algorithms Design Techniques and Analysis>> - M.H.Alsuwaiyel, Chapter 4.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MiniHeap = void 0;\r\n/**\r\n * Minimum heap construct, can easily add or remove new items, and get minimum item.\r\n * Otherwise, it allocates very few memory when each time adding or removing.\r\n */\r\nclass MiniHeap {\r\n    constructor(comparer) {\r\n        /** Data array, caches the complete binary tree. */\r\n        this.array = [];\r\n        this.comparer = comparer;\r\n    }\r\n    /** Whether heap is empty. */\r\n    isEmpty() {\r\n        return this.array.length === 0;\r\n    }\r\n    /** Add new `value` to heap. */\r\n    add(value) {\r\n        this.array.push(value);\r\n        this.shiftUp(this.array.length - 1);\r\n    }\r\n    /** Removes minimum value, returns it. */\r\n    removeHead() {\r\n        if (this.array.length === 0) {\r\n            return undefined;\r\n        }\r\n        if (this.array.length === 1) {\r\n            return this.array.pop();\r\n        }\r\n        let firstValue = this.array[0];\r\n        this.array[0] = this.array.pop();\r\n        this.shiftDown(0);\r\n        return firstValue;\r\n    }\r\n    /** Swap value with parent if needed. */\r\n    shiftUp(index) {\r\n        if (index === 0) {\r\n            return;\r\n        }\r\n        // If index is 1-based, this value is `index >> 1`.\r\n        let parentIndex = ((index + 1) >> 1) - 1;\r\n        // value in index is smaller, should moves up.\r\n        if (this.comparer(this.array[index], this.array[parentIndex]) < 0) {\r\n            this.swap(index, parentIndex);\r\n            // May still need to swap if here it swapped.\r\n            this.shiftUp(parentIndex);\r\n        }\r\n    }\r\n    /** Swap value with one child if needed. */\r\n    shiftDown(index) {\r\n        // If index is 1-based, `leftIndex` is `index << 1`.\r\n        let rightIndex = (index + 1) << 1;\r\n        let leftIndex = rightIndex - 1;\r\n        let childIndex = leftIndex;\r\n        // If right value is smaller, moves it up.\r\n        if (rightIndex < this.array.length && this.comparer(this.array[leftIndex], this.array[rightIndex]) > 0) {\r\n            childIndex = rightIndex;\r\n        }\r\n        if (childIndex >= this.array.length) {\r\n            return;\r\n        }\r\n        // value in child index is smaller, should moves up.\r\n        if (this.comparer(this.array[childIndex], this.array[index]) < 0) {\r\n            this.swap(childIndex, index);\r\n            // May still need to swap if here it swapped.\r\n            this.shiftDown(childIndex);\r\n        }\r\n    }\r\n    /** Swap values of two indices. */\r\n    swap(i, j) {\r\n        let vi = this.array[i];\r\n        this.array[i] = this.array[j];\r\n        this.array[j] = vi;\r\n    }\r\n    /** Clear all heap data. */\r\n    clear() {\r\n        this.array = [];\r\n    }\r\n}\r\nexports.MiniHeap = MiniHeap;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ResultReferences = void 0;\r\nclass ResultReferences {\r\n    constructor() {\r\n        /** Caches reference binding callback. */\r\n        this.referenceMap = new WeakMap();\r\n        /** Caches un-reference callback. */\r\n        this.unReferenceMap = new WeakMap();\r\n        /** Caches un-reference callback. */\r\n        this.bindingUnReferenceMap = new WeakMap();\r\n    }\r\n    /** Add a reference which will be called after instance created. */\r\n    addReference(result, ref) {\r\n        this.referenceMap.set(result, ref);\r\n    }\r\n    /** Add a reference which will be called after instance removed. */\r\n    addUnReference(result, unRef) {\r\n        this.unReferenceMap.set(result, unRef);\r\n    }\r\n    /** Create a reference after instance created. */\r\n    createReference(result, binding) {\r\n        if (this.referenceMap.has(result)) {\r\n            this.referenceMap.get(result)(binding);\r\n        }\r\n        if (this.unReferenceMap.has(result)) {\r\n            let unRef = this.unReferenceMap.get(result);\r\n            this.bindingUnReferenceMap.set(binding, unRef);\r\n        }\r\n    }\r\n    /** Calls after instance removed. */\r\n    removeReference(binding) {\r\n        if (this.bindingUnReferenceMap.has(binding)) {\r\n            this.bindingUnReferenceMap.get(binding)(binding);\r\n        }\r\n    }\r\n}\r\nexports.ResultReferences = ResultReferences;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TwoWayMap = void 0;\r\n/**\r\n * L -> R\r\n * R -> L\r\n */\r\nclass TwoWayMap {\r\n    constructor() {\r\n        this.lm = new Map();\r\n        this.rm = new Map();\r\n    }\r\n    getSize() {\r\n        return this.lm.size;\r\n    }\r\n    /**\r\n     * Both `l` and `r` must not been added before.\r\n     * You may need to calls `deleteFromLeft` and `deleteFromRight` if you can't ensure this.\r\n     */\r\n    add(l, r) {\r\n        this.lm.set(l, r);\r\n        this.rm.set(r, l);\r\n    }\r\n    hasLeft(l) {\r\n        return this.lm.has(l);\r\n    }\r\n    hasRight(r) {\r\n        return this.rm.has(r);\r\n    }\r\n    getFromLeft(l) {\r\n        return this.lm.get(l);\r\n    }\r\n    getFromRight(r) {\r\n        return this.rm.get(r);\r\n    }\r\n    deleteFromLeft(l) {\r\n        if (this.hasLeft(l)) {\r\n            this.rm.delete(this.lm.get(l));\r\n            this.lm.delete(l);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    deleteFromRight(r) {\r\n        if (this.hasRight(r)) {\r\n            this.lm.delete(this.rm.get(r));\r\n            this.rm.delete(r);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    getAllLeft() {\r\n        return this.lm.keys();\r\n    }\r\n    getAllRight() {\r\n        return this.rm.keys();\r\n    }\r\n}\r\nexports.TwoWayMap = TwoWayMap;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getClosestScrollWrapper = exports.getRect = exports.getElementCountBefore = exports.locateLastVisibleIndex = exports.locateFirstVisibleIndex = exports.untilIdle = exports.untilNextFrame = exports.repeatForTimes = exports.binaryFindIndexToInsert = exports.trim = void 0;\r\n/** Trim text by removing `\\r\\n\\t`. */\r\nfunction trim(text) {\r\n    return text.replace(/^[\\r\\n\\t]+|[\\r\\n\\t]+$/g, '');\r\n}\r\nexports.trim = trim;\r\n/**\r\n * Find the closest index in a sorted array in where to insert new item.\r\n * Returned index betweens `0 - array.length`, and if `array[index]` exist, `fn(array[index]) >= 0`.\r\n * @param array The sorted array.\r\n * @param fn The function to accept item in array as argument and returns `-1` to move left, `1` to move right.\r\n */\r\nfunction binaryFindIndexToInsert(array, fn) {\r\n    if (array.length === 0) {\r\n        return 0;\r\n    }\r\n    let result = fn(array[0]);\r\n    if (result === 0 || result === -1) {\r\n        return 0;\r\n    }\r\n    if (array.length === 1) {\r\n        return 1;\r\n    }\r\n    result = fn(array[array.length - 1]);\r\n    if (result === 0) {\r\n        return array.length - 1;\r\n    }\r\n    if (result === 1) {\r\n        return array.length;\r\n    }\r\n    let start = 0;\r\n    let end = array.length - 1;\r\n    while (end - start > 1) {\r\n        let center = Math.floor((end + start) / 2);\r\n        let result = fn(array[center]);\r\n        if (result === 0) {\r\n            return center;\r\n        }\r\n        else if (result === -1) {\r\n            end = center;\r\n        }\r\n        else {\r\n            start = center;\r\n        }\r\n    }\r\n    return end;\r\n}\r\nexports.binaryFindIndexToInsert = binaryFindIndexToInsert;\r\n/** Repeat value for count times. */\r\nfunction repeatForTimes(value, count) {\r\n    let values = [];\r\n    for (let i = 0; i < count; i++) {\r\n        values.push(value);\r\n    }\r\n    return values;\r\n}\r\nexports.repeatForTimes = repeatForTimes;\r\n/** Resolves until next frame. */\r\nfunction untilNextFrame() {\r\n    return new Promise(resolve => {\r\n        requestAnimationFrame(resolve);\r\n    });\r\n}\r\nexports.untilNextFrame = untilNextFrame;\r\n/** Resolves until CPU is idle or next frame. */\r\nfunction untilIdle() {\r\n    return new Promise(resolve => {\r\n        if (requestIdleCallback) {\r\n            requestIdleCallback(resolve);\r\n        }\r\n        else {\r\n            setTimeout(resolve, 0);\r\n        }\r\n    });\r\n}\r\nexports.untilIdle = untilIdle;\r\n/**\r\n * Locate the first element in els that is is visible inside container.\r\n * @container Container to check visible inside.\r\n * @param els Element list to check.\r\n */\r\nfunction locateFirstVisibleIndex(container, els, minimumVisibleRate = 0.5) {\r\n    return locateVisibleIndex(container, els, minimumVisibleRate, false);\r\n}\r\nexports.locateFirstVisibleIndex = locateFirstVisibleIndex;\r\n/**\r\n * Locate the last element in els that is is visible inside container.\r\n * @container Container to check visible inside.\r\n * @param els Element list to check.\r\n */\r\nfunction locateLastVisibleIndex(container, els, minimumVisibleRate = 0.5) {\r\n    return locateVisibleIndex(container, els, minimumVisibleRate, true);\r\n}\r\nexports.locateLastVisibleIndex = locateLastVisibleIndex;\r\nfunction locateVisibleIndex(container, els, minimumVisibleRate, locateLast) {\r\n    let containerRect = container.getBoundingClientRect();\r\n    let index = binaryFindIndexToInsert(els, (el) => {\r\n        let rect = el.getBoundingClientRect();\r\n        let yIntersect = Math.min(containerRect.bottom, rect.bottom) - Math.max(containerRect.top, rect.top);\r\n        let intersectRate = yIntersect / Math.min(containerRect.height, rect.height);\r\n        // Fully above.\r\n        if (rect.bottom < containerRect.top) {\r\n            return 1;\r\n        }\r\n        // Fully behind.\r\n        else if (rect.top > containerRect.bottom) {\r\n            return -1;\r\n        }\r\n        // Partly cross in top position.\r\n        else if (rect.top < containerRect.top && intersectRate < minimumVisibleRate) {\r\n            return 1;\r\n        }\r\n        // Partly cross in bottom position.\r\n        else if (rect.bottom < containerRect.bottom && intersectRate < minimumVisibleRate) {\r\n            return -1;\r\n        }\r\n        // Enough percentage that intersect with.\r\n        // If `preferLast` is true, prefer moving to right.\r\n        else {\r\n            return locateLast ? 1 : -1;\r\n        }\r\n    });\r\n    if (locateLast) {\r\n        if (index > 0) {\r\n            index -= 1;\r\n        }\r\n    }\r\n    return index;\r\n}\r\n/** Get count of elements before current node. */\r\nfunction getElementCountBefore(node) {\r\n    let offset = 0;\r\n    while (node.previousElementSibling) {\r\n        node = node.previousElementSibling;\r\n        offset += 1;\r\n    }\r\n    return offset;\r\n}\r\nexports.getElementCountBefore = getElementCountBefore;\r\n/** Get an rect object just like `getBoundingClientRect`, but writtable. */\r\nfunction getRect(el) {\r\n    let rect = el.getBoundingClientRect();\r\n    return {\r\n        top: rect.top,\r\n        right: rect.right,\r\n        bottom: rect.bottom,\r\n        left: rect.left,\r\n        width: rect.width,\r\n        height: rect.height,\r\n    };\r\n}\r\nexports.getRect = getRect;\r\n/**\r\n * Find the closest scroll wrapper, which has `overflow: auto / scroll` set.\r\n * Note that this method may cause reflow.\r\n */\r\nfunction getClosestScrollWrapper(el) {\r\n    while (el\r\n        && el.scrollWidth <= el.clientWidth\r\n        && el.scrollHeight <= el.clientHeight) {\r\n        el = el.parentElement;\r\n    }\r\n    return el;\r\n}\r\nexports.getClosestScrollWrapper = getClosestScrollWrapper;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Weak2WayMap = void 0;\r\n/**\r\n * Implement data constructor for two way map:\r\n * L -> R[]\r\n * R -> L[]\r\n */\r\nclass Weak2WayMap {\r\n    constructor() {\r\n        /** L -> R[] */\r\n        this.lm = new WeakMap();\r\n        /** R -> L[] */\r\n        this.rm = new WeakMap();\r\n    }\r\n    /** Update `L -> R[]` and `R[] -> L` maps. */\r\n    updateFromLeft(l, rs) {\r\n        let oldRs = this.lm.get(l);\r\n        if (!oldRs) {\r\n            for (let r of rs) {\r\n                this.addRightLeftMap(r, l);\r\n            }\r\n        }\r\n        else {\r\n            // Very high rate no need to add or delete.\r\n            // So we test if should add or delete firstly.\r\n            for (let r of rs) {\r\n                if (!oldRs.has(r)) {\r\n                    this.addRightLeftMap(r, l);\r\n                }\r\n            }\r\n            for (let r of oldRs) {\r\n                if (!rs.has(r)) {\r\n                    this.deleteRightLeftMap(r, l);\r\n                }\r\n            }\r\n        }\r\n        this.lm.set(l, rs);\r\n    }\r\n    /** Add one `R -> L` map. */\r\n    addRightLeftMap(r, l) {\r\n        let ls = this.rm.get(r);\r\n        if (!ls) {\r\n            ls = new Set();\r\n            this.rm.set(r, ls);\r\n        }\r\n        ls.add(l);\r\n    }\r\n    /** Deletes one `R -> L` map. */\r\n    deleteRightLeftMap(r, l) {\r\n        let ls = this.rm.get(r);\r\n        if (ls) {\r\n            ls.delete(l);\r\n        }\r\n    }\r\n    /** Deletes one `L -> R` map. */\r\n    deleteLeftRightMap(l, r) {\r\n        let rs = this.lm.get(l);\r\n        if (rs) {\r\n            rs.delete(r);\r\n        }\r\n    }\r\n    /** Get all `L[]` from `R` maps. */\r\n    getFromRight(r) {\r\n        return this.rm.get(r);\r\n    }\r\n    /** Clears all `R[] -> L` and `L -> R[]`. */\r\n    clearFromLeft(l) {\r\n        let rs = this.lm.get(l);\r\n        if (rs) {\r\n            for (let r of rs) {\r\n                this.deleteRightLeftMap(r, l);\r\n                this.deleteLeftRightMap(l, r);\r\n            }\r\n            // No need to delete WeakMap key.\r\n            // this.lm.delete(l)\r\n        }\r\n    }\r\n}\r\nexports.Weak2WayMap = Weak2WayMap;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Weak2WayPropMap = void 0;\r\n/**\r\n * Implement data constructor for two way property map:\r\n * L -> {R: [prop]}\r\n * R -> {prop: [L]}\r\n */\r\nclass Weak2WayPropMap {\r\n    constructor() {\r\n        /** L -> {R: [prop]} */\r\n        this.lm = new WeakMap();\r\n        /** R -> {prop: [L]} */\r\n        this.rm = new WeakMap();\r\n    }\r\n    /** Update `L -> R[] -> props[]` and `R[] -> prop[] -> L` maps. */\r\n    updateFromLeft(l, rps) {\r\n        let oldRps = this.lm.get(l);\r\n        if (!oldRps) {\r\n            for (let [r, props] of rps) {\r\n                this.addRightLeftMap(r, props, l);\r\n            }\r\n        }\r\n        else {\r\n            for (let [r, props] of rps) {\r\n                if (oldRps.has(r)) {\r\n                    this.updateRightLeftMap(r, oldRps.get(r), props, l);\r\n                }\r\n                else {\r\n                    this.addRightLeftMap(r, props, l);\r\n                }\r\n            }\r\n            for (let [r, props] of oldRps) {\r\n                if (!rps.has(r)) {\r\n                    this.deleteRightLeftMap(r, props, l);\r\n                }\r\n            }\r\n        }\r\n        this.lm.set(l, rps);\r\n    }\r\n    /** Add `L -> R -> prop[]` and `R -> prop[] -> L` map. */\r\n    addRightLeftMap(r, props, l) {\r\n        let pls = this.rm.get(r);\r\n        if (!pls) {\r\n            pls = new Map();\r\n            this.rm.set(r, pls);\r\n        }\r\n        for (let prop of props) {\r\n            let ls = pls.get(prop);\r\n            if (!ls) {\r\n                ls = new Set();\r\n                pls.set(prop, ls);\r\n            }\r\n            ls.add(l);\r\n        }\r\n    }\r\n    /** Update `R -> prop[] -> L` map. */\r\n    updateRightLeftMap(r, oldProps, newProps, l) {\r\n        let pls = this.rm.get(r);\r\n        if (pls) {\r\n            for (let prop of newProps) {\r\n                if (!oldProps.has(prop)) {\r\n                    let ls = pls.get(prop);\r\n                    if (!ls) {\r\n                        ls = new Set();\r\n                        pls.set(prop, ls);\r\n                    }\r\n                    ls.add(l);\r\n                }\r\n            }\r\n            for (let prop of oldProps) {\r\n                if (!newProps.has(prop)) {\r\n                    let ls = pls.get(prop);\r\n                    if (ls) {\r\n                        ls.delete(l);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /** Deletes `R -> L -> prop[]` map. */\r\n    deleteRightLeftMap(r, props, l) {\r\n        let pls = this.rm.get(r);\r\n        if (pls) {\r\n            for (let prop of props) {\r\n                let ls = pls.get(prop);\r\n                if (ls) {\r\n                    ls.delete(l);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /** Deletes `L -> R -> prop[]` map. */\r\n    deleteLeftRightMap(l, r) {\r\n        let rps = this.lm.get(l);\r\n        if (rps) {\r\n            rps.delete(r);\r\n        }\r\n    }\r\n    /** Get `L[]` from `R -> prop`. */\r\n    getFromRight(r, prop) {\r\n        let pls = this.rm.get(r);\r\n        if (pls) {\r\n            return pls.get(prop);\r\n        }\r\n        return undefined;\r\n    }\r\n    /** Clear all `L -> R[] -> prop[]` and `R[] -> prop[] -> L` maps. */\r\n    clearFromLeft(l) {\r\n        let rps = this.lm.get(l);\r\n        if (rps) {\r\n            for (let [r, props] of rps) {\r\n                this.deleteRightLeftMap(r, props, l);\r\n                this.deleteLeftRightMap(l, r);\r\n            }\r\n            // No need to delete WeakMap key.\r\n            // this.lm.delete(l)\r\n        }\r\n    }\r\n}\r\nexports.Weak2WayPropMap = Weak2WayPropMap;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar template_1 = require(\"./template\");\r\nObject.defineProperty(exports, \"html\", { enumerable: true, get: function () { return template_1.html; } });\r\nObject.defineProperty(exports, \"css\", { enumerable: true, get: function () { return template_1.css; } });\r\nObject.defineProperty(exports, \"svg\", { enumerable: true, get: function () { return template_1.svg; } });\r\nObject.defineProperty(exports, \"TemplateResult\", { enumerable: true, get: function () { return template_1.TemplateResult; } });\r\nObject.defineProperty(exports, \"Template\", { enumerable: true, get: function () { return template_1.Template; } });\r\nvar component_1 = require(\"./component\");\r\nObject.defineProperty(exports, \"Component\", { enumerable: true, get: function () { return component_1.Component; } });\r\nObject.defineProperty(exports, \"define\", { enumerable: true, get: function () { return component_1.define; } });\r\nObject.defineProperty(exports, \"addGlobalStyle\", { enumerable: true, get: function () { return component_1.addGlobalStyle; } });\r\nObject.defineProperty(exports, \"getComponent\", { enumerable: true, get: function () { return component_1.getComponent; } });\r\nObject.defineProperty(exports, \"getComponentAsync\", { enumerable: true, get: function () { return component_1.getComponentAsync; } });\r\nObject.defineProperty(exports, \"getClosestComponentOfType\", { enumerable: true, get: function () { return component_1.getClosestComponentOfType; } });\r\nvar bindings_1 = require(\"./bindings\");\r\nObject.defineProperty(exports, \"defineBinding\", { enumerable: true, get: function () { return bindings_1.defineBinding; } });\r\nObject.defineProperty(exports, \"refBinding\", { enumerable: true, get: function () { return bindings_1.refBinding; } });\r\nObject.defineProperty(exports, \"BindingResult\", { enumerable: true, get: function () { return bindings_1.BindingResult; } });\r\nObject.defineProperty(exports, \"show\", { enumerable: true, get: function () { return bindings_1.show; } });\r\nObject.defineProperty(exports, \"hide\", { enumerable: true, get: function () { return bindings_1.hide; } });\r\nvar directives_1 = require(\"./directives\");\r\nObject.defineProperty(exports, \"defineDirective\", { enumerable: true, get: function () { return directives_1.defineDirective; } });\r\nObject.defineProperty(exports, \"refDirective\", { enumerable: true, get: function () { return directives_1.refDirective; } });\r\nObject.defineProperty(exports, \"RepeatDirective\", { enumerable: true, get: function () { return directives_1.RepeatDirective; } });\r\nObject.defineProperty(exports, \"ToggleDirective\", { enumerable: true, get: function () { return directives_1.ToggleDirective; } });\r\nObject.defineProperty(exports, \"CacheDirective\", { enumerable: true, get: function () { return directives_1.CacheDirective; } });\r\nObject.defineProperty(exports, \"DirectiveResult\", { enumerable: true, get: function () { return directives_1.DirectiveResult; } });\r\nObject.defineProperty(exports, \"cache\", { enumerable: true, get: function () { return directives_1.cache; } });\r\nObject.defineProperty(exports, \"toggle\", { enumerable: true, get: function () { return directives_1.toggle; } });\r\nObject.defineProperty(exports, \"repeat\", { enumerable: true, get: function () { return directives_1.repeat; } });\r\nObject.defineProperty(exports, \"liveRepeat\", { enumerable: true, get: function () { return directives_1.liveRepeat; } });\r\nObject.defineProperty(exports, \"LiveRepeatDirective\", { enumerable: true, get: function () { return directives_1.LiveRepeatDirective; } });\r\nObject.defineProperty(exports, \"liveAsyncRepeat\", { enumerable: true, get: function () { return directives_1.liveAsyncRepeat; } });\r\nObject.defineProperty(exports, \"LiveAsyncRepeatDirective\", { enumerable: true, get: function () { return directives_1.LiveAsyncRepeatDirective; } });\r\nvar dom_event_1 = require(\"./internals/dom-event\");\r\nObject.defineProperty(exports, \"on\", { enumerable: true, get: function () { return dom_event_1.on; } });\r\nObject.defineProperty(exports, \"once\", { enumerable: true, get: function () { return dom_event_1.once; } });\r\nObject.defineProperty(exports, \"off\", { enumerable: true, get: function () { return dom_event_1.off; } });\r\nvar transition_1 = require(\"./internals/transition\");\r\nObject.defineProperty(exports, \"defineTransion\", { enumerable: true, get: function () { return transition_1.defineTransion; } });\r\nObject.defineProperty(exports, \"getCSSEasingValue\", { enumerable: true, get: function () { return transition_1.getCSSEasingValue; } });\r\nObject.defineProperty(exports, \"Transition\", { enumerable: true, get: function () { return transition_1.Transition; } });\r\nObject.defineProperty(exports, \"isPlayingTransition\", { enumerable: true, get: function () { return transition_1.isPlayingTransition; } });\r\nObject.defineProperty(exports, \"clearTransition\", { enumerable: true, get: function () { return transition_1.clearTransition; } });\r\nvar updatable_options_1 = require(\"./internals/updatable-options\");\r\nObject.defineProperty(exports, \"UpdatableOptions\", { enumerable: true, get: function () { return updatable_options_1.UpdatableOptions; } });\r\nvar observer_1 = require(\"./observer\");\r\nObject.defineProperty(exports, \"observe\", { enumerable: true, get: function () { return observer_1.observe; } });\r\nObject.defineProperty(exports, \"observeGetting\", { enumerable: true, get: function () { return observer_1.observeGetting; } });\r\nvar watchers_1 = require(\"./watchers\");\r\nObject.defineProperty(exports, \"watch\", { enumerable: true, get: function () { return watchers_1.watch; } });\r\nObject.defineProperty(exports, \"watchOnce\", { enumerable: true, get: function () { return watchers_1.watchOnce; } });\r\nObject.defineProperty(exports, \"watchUntil\", { enumerable: true, get: function () { return watchers_1.watchUntil; } });\r\nObject.defineProperty(exports, \"watchImmediately\", { enumerable: true, get: function () { return watchers_1.watchImmediately; } });\r\nvar queue_1 = require(\"./queue\");\r\nObject.defineProperty(exports, \"onRenderComplete\", { enumerable: true, get: function () { return queue_1.onRenderComplete; } });\r\nObject.defineProperty(exports, \"untilRenderComplete\", { enumerable: true, get: function () { return queue_1.untilRenderComplete; } });\r\nObject.defineProperty(exports, \"enqueueUpdatableInOrder\", { enumerable: true, get: function () { return queue_1.enqueueUpdatableInOrder; } });\r\nObject.defineProperty(exports, \"UpdatableUpdateOrder\", { enumerable: true, get: function () { return queue_1.UpdatableUpdateOrder; } });\r\nvar update_1 = require(\"./globals/update\");\r\nObject.defineProperty(exports, \"updateAllComponents\", { enumerable: true, get: function () { return update_1.updateAllComponents; } });\r\nObject.defineProperty(exports, \"updateAllGlobalWatchers\", { enumerable: true, get: function () { return update_1.updateAllGlobalWatchers; } });\r\nObject.defineProperty(exports, \"updateAllStyles\", { enumerable: true, get: function () { return update_1.updateAllStyles; } });\r\nvar render_1 = require(\"./globals/render\");\r\nObject.defineProperty(exports, \"render\", { enumerable: true, get: function () { return render_1.render; } });\r\nObject.defineProperty(exports, \"renderUpdatable\", { enumerable: true, get: function () { return render_1.renderUpdatable; } });\r\nObject.defineProperty(exports, \"getRenderedAsComponent\", { enumerable: true, get: function () { return render_1.getRenderedAsComponent; } });\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ContextualTransition = void 0;\r\nconst transition_1 = require(\"./transition\");\r\nconst updatable_options_1 = require(\"./updatable-options\");\r\n/** Class to manage transition options, expecially to know should play transition when at start. */\r\nclass ContextualTransition {\r\n    constructor(context) {\r\n        this.options = new updatable_options_1.UpdatableOptions({});\r\n        /** Be `true` only after firstly updated. */\r\n        this.firstTimeUpdated = null;\r\n        this.context = context;\r\n    }\r\n    /** Sometimes you may just leaves `name` and `properties` to be `undefined` if you want to control playing dynamically. */\r\n    canPlay() {\r\n        return this.options.has('name') || this.options.has('properties');\r\n    }\r\n    /** Update options data. */\r\n    updateOptions(options) {\r\n        this.options.update(options);\r\n        this.firstTimeUpdated = this.firstTimeUpdated === null ? true : false;\r\n    }\r\n    /** Whether should play enter transition. */\r\n    shouldPlayEnter() {\r\n        if (!this.canPlay() || this.firstTimeUpdated && !this.options.get('enterAtStart')) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /** Whether should play leave transition. */\r\n    shouldPlayLeave() {\r\n        if (!this.canPlay() || this.firstTimeUpdated && !this.options.get('leaveAtStart')) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /** Plays enter transition, must validate `shouldPlayEnter` before. */\r\n    async playEnter(el) {\r\n        let onend = this.options.get('onend');\r\n        let finish = await new transition_1.Transition(el, this.options.getOptions()).enter();\r\n        if (onend) {\r\n            onend.call(this.context, 'enter', finish);\r\n        }\r\n        return finish;\r\n    }\r\n    /** Plays leave transition, must validate `shouldPlayLeave` before. */\r\n    async playLeave(el) {\r\n        let onend = this.options.get('onend');\r\n        let finish = await new transition_1.Transition(el, this.options.getOptions()).leave();\r\n        if (onend) {\r\n            onend.call(this.context, 'leave', finish);\r\n        }\r\n        return finish;\r\n    }\r\n}\r\nexports.ContextualTransition = ContextualTransition;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.off = exports.once = exports.on = void 0;\r\n/** Modefiers to limit event triggering or do some actions. */\r\nconst GlobalEventModifiers = ['capture', 'self', 'once', 'prevent', 'stop', 'passive'];\r\nconst ControlKeyModefiers = ['ctrl', 'shift', 'alt'];\r\nconst ChangeEventModifiers = ['check', 'uncheck'];\r\nconst WheelEventModifiers = ['up', 'down'];\r\nconst ButtonNameModifiers = {\r\n    left: 0,\r\n    middle: 1,\r\n    right: 2,\r\n    main: 0,\r\n    auxiliary: 1,\r\n    secondary: 2\r\n};\r\n/** Event filters to limit event triggering. */\r\nconst EventFilters = {\r\n    keydown: keyEventFilter,\r\n    keyup: keyEventFilter,\r\n    keypress: keyEventFilter,\r\n    mousedown: mouseEventFilter,\r\n    mousemove: mouseEventFilter,\r\n    mouseup: mouseEventFilter,\r\n    click: mouseEventFilter,\r\n    dblclick: mouseEventFilter,\r\n    change: changeEventFilter,\r\n    wheel: wheelEventFilter,\r\n};\r\n/** To cache all event listeners for element. */\r\nconst ElementEventListenerCache = new WeakMap();\r\n/** Limit key event triggering. */\r\nfunction keyEventFilter(e, modifiers) {\r\n    // Full key list: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\r\n    // Capture key at: https://keycode.info/\r\n    let codeModifiers = [];\r\n    // Control keys must match.\r\n    for (let modifier of modifiers) {\r\n        if (ControlKeyModefiers.includes(modifier)) {\r\n            if (!isControlKeyMatchModifier(e, modifier)) {\r\n                return false;\r\n            }\r\n            continue;\r\n        }\r\n        codeModifiers.push(modifier);\r\n    }\r\n    return codeModifiers.length === 0\r\n        || codeModifiers.includes(e.code.toLowerCase());\r\n}\r\n/** Limit mouse event triggering. */\r\nfunction mouseEventFilter(e, modifiers) {\r\n    let buttonModifiers = [];\r\n    // Control keys must match.\r\n    for (let modifier of modifiers) {\r\n        if (ControlKeyModefiers.includes(modifier)) {\r\n            if (!isControlKeyMatchModifier(e, modifier)) {\r\n                return false;\r\n            }\r\n            continue;\r\n        }\r\n        buttonModifiers.push(modifier);\r\n    }\r\n    if (buttonModifiers.length === 0) {\r\n        return true;\r\n    }\r\n    if (buttonModifiers.find(f => ButtonNameModifiers[f] === e.button)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n/** Limit key event triggering from control keys. */\r\nfunction isControlKeyMatchModifier(e, modifier) {\r\n    if (modifier === 'ctrl' && !e.ctrlKey\r\n        || modifier === 'shift' && !e.shiftKey\r\n        || modifier === 'alt' && !e.altKey) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n/** Limit change event triggering. */\r\nfunction changeEventFilter(e, [modifier]) {\r\n    let checked = e.target.checked;\r\n    return checked && modifier === 'check'\r\n        || checked && modifier === 'uncheck';\r\n}\r\n/** Limit wheel event triggering. */\r\nfunction wheelEventFilter(e, [modifier]) {\r\n    return (e.deltaY < 0) && modifier === 'up'\r\n        || (e.deltaY > 0) && modifier === 'down';\r\n}\r\n/** Valdiate event modifiers. */\r\nfunction validateModifiers(propertyName, name, modifiers) {\r\n    // Exclude global modifiers.\r\n    modifiers = modifiers.filter(m => !GlobalEventModifiers.includes(m));\r\n    if (modifiers.length === 0) {\r\n        return true;\r\n    }\r\n    if (name === 'change') {\r\n        if (modifiers.length > 1 || !ChangeEventModifiers.includes(modifiers[0])) {\r\n            throw new Error(`\"${propertyName}\" is valid, change event modifier must be only one of \"${ChangeEventModifiers.join(',')}\"!`);\r\n        }\r\n    }\r\n    else if (name === 'wheel') {\r\n        if (modifiers.length > 1 || !WheelEventModifiers.includes(modifiers[0])) {\r\n            throw new Error(`\"${propertyName}\" is valid, wheel event modifier must be only one of \"${WheelEventModifiers.join(',')}\"!`);\r\n        }\r\n    }\r\n    else if (name === 'mousedown' || name === 'mousemove' || name === 'mouseup' || name === 'click') {\r\n        modifiers = modifiers.filter(m => !ControlKeyModefiers.includes(m));\r\n        if (!ButtonNameModifiers.hasOwnProperty(modifiers[0])) {\r\n            throw new Error(`\"${propertyName}\" is valid, button filter for mouse event must be one of \"${Object.keys(ButtonNameModifiers).join(',')}\"!`);\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Register an event listener on element.\r\n * @param el The element to register listener on.\r\n * @param name The event name, it can be `click:left` or `keydown:enter`.\r\n * @param handler The event handler.\r\n * @param scope The event context used to call handler. You can remove it easily by specify the same scope.\r\n */\r\nfunction on(el, name, handler, scope) {\r\n    bindEvent(false, el, name, handler, scope);\r\n}\r\nexports.on = on;\r\n/**\r\n * Register an event listener on element, and will be triggered only for once.\r\n * @param el The element to register listener on.\r\n * @param name The event name, it can be `click:left` or `keydown:enter`.\r\n * @param handler The event handler.\r\n * @param scope The event context used to call handler. You can remove it easily by specify the same scope.\r\n */\r\nfunction once(el, name, handler, scope) {\r\n    bindEvent(true, el, name, handler, scope);\r\n}\r\nexports.once = once;\r\nfunction bindEvent(once, el, rawName, handler, scope) {\r\n    let name = rawName;\r\n    let modifiers = null;\r\n    if (rawName.includes('.')) {\r\n        [name, ...modifiers] = rawName.split('.');\r\n        validateModifiers(rawName, name, modifiers);\r\n    }\r\n    let wrappedHandler = wrapHandler(once, modifiers, el, name, handler, scope);\r\n    let capture = !!modifiers && modifiers.includes('capture');\r\n    let passive = !!modifiers && modifiers.includes('passive');\r\n    // Wheel event use passive mode by default and can't be prevented.\r\n    let options = passive || name === 'wheel' ? { capture, passive } : capture;\r\n    let eventMap = ElementEventListenerCache.get(el);\r\n    if (!eventMap) {\r\n        eventMap = {};\r\n        ElementEventListenerCache.set(el, eventMap);\r\n    }\r\n    let events = eventMap[name] || (eventMap[name] = []);\r\n    events.push({\r\n        name: rawName,\r\n        handler,\r\n        wrappedHandler,\r\n        scope,\r\n        capture\r\n    });\r\n    el.addEventListener(name, wrappedHandler, options);\r\n}\r\n/**\r\n * Unregister an event listener on element.\r\n * @param el The element to unregister listener on.\r\n * @param name The event name with or without modifiers.\r\n * @param handler The event handler.\r\n * @param scope The event context used to call handler. If specified, it must be match too.\r\n */\r\nfunction off(el, name, handler, scope) {\r\n    let eventMap = ElementEventListenerCache.get(el);\r\n    if (!eventMap) {\r\n        return;\r\n    }\r\n    name = name.replace(/\\..+/, '');\r\n    let events = eventMap[name];\r\n    if (!events) {\r\n        return;\r\n    }\r\n    for (let i = events.length - 1; i >= 0; i--) {\r\n        let event = events[i];\r\n        let isHandlerMatch = !handler\r\n            || event.handler === handler\r\n            || event.handler.hasOwnProperty('__original') && event.handler.__original === handler;\r\n        if (isHandlerMatch && (!scope || event.scope === scope)) {\r\n            el.removeEventListener(name, event.wrappedHandler, event.capture);\r\n            events.splice(i, 1);\r\n        }\r\n    }\r\n}\r\nexports.off = off;\r\n/** Wrap handler according to global modifiers. */\r\nfunction wrapHandler(once, modifiers, el, name, handler, scope) {\r\n    let filterModifiers = modifiers === null || modifiers === void 0 ? void 0 : modifiers.filter(m => !GlobalEventModifiers.includes(m));\r\n    return function wrappedHandler(e) {\r\n        if (filterModifiers && filterModifiers.length > 0) {\r\n            let filterFn = EventFilters[name];\r\n            if (!filterFn(e, filterModifiers)) {\r\n                return;\r\n            }\r\n        }\r\n        if (modifiers && modifiers.includes('self') && e.target !== el) {\r\n            return;\r\n        }\r\n        if (modifiers && modifiers.includes('prevent')) {\r\n            e.preventDefault();\r\n        }\r\n        if (modifiers && modifiers.includes('stop')) {\r\n            e.stopPropagation();\r\n        }\r\n        if (once || modifiers && modifiers.includes('once')) {\r\n            off(el, name, handler, scope);\r\n        }\r\n        if (scope) {\r\n            handler.call(scope, e);\r\n        }\r\n        else {\r\n            handler(e);\r\n        }\r\n    };\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.joinHTMLAttributes = void 0;\r\n/**\r\n * Join two attribute strings into one.\r\n * `class=\"...\"` will be merged.\r\n * normal `attr=\"...\"` will be replaced.\r\n * bindings like `:class=\"...\"` will kept both.\r\n */\r\nfunction joinHTMLAttributes(superAttributes, assignAttributes) {\r\n    let superAttributeList = parseToHTMLAttributes(superAttributes);\r\n    let assignAttributeList = parseToHTMLAttributes(assignAttributes);\r\n    let joind = joinParsedHTMLAttributes(superAttributeList, assignAttributeList);\r\n    return joind.map(attr => outputParsedAttribute(attr)).join('');\r\n}\r\nexports.joinHTMLAttributes = joinHTMLAttributes;\r\n/** Parse a html attributes to a attribute list. */\r\nfunction parseToHTMLAttributes(attributes) {\r\n    const attrRE = /([.:?@\\w-]+)\\s*=(\\s*(?:\".*?\"|'.*?'|\\S+)?)|\\S+/g;\r\n    let results = [];\r\n    let match;\r\n    while (match = attrRE.exec(attributes)) {\r\n        // Name is only available for normal standardlize html attributes.\r\n        let name = /[\\w-]/.test(match[1]) ? match[1] : null;\r\n        let value = name && match[2] ? match[2] : null;\r\n        results.push({\r\n            text: match[0],\r\n            name,\r\n            value,\r\n        });\r\n    }\r\n    return results;\r\n}\r\n/** Parse a html attributes to a list. */\r\nfunction joinParsedHTMLAttributes(superAttributeList, assignAttributeList) {\r\n    for (let item of assignAttributeList) {\r\n        if (item.name === 'class' || item.name === 'style') {\r\n            let exist = superAttributeList.find(superAttr => superAttr.name === item.name);\r\n            if (exist) {\r\n                exist.value = joinAttributeValues(exist.value, item.value);\r\n            }\r\n            else {\r\n                superAttributeList.push(item);\r\n            }\r\n        }\r\n        else if (item.name) {\r\n            let exist = superAttributeList.find(superAttr => superAttr.name === item.name);\r\n            if (exist) {\r\n                exist.value = item.value;\r\n            }\r\n            else {\r\n                superAttributeList.push(item);\r\n            }\r\n        }\r\n        else {\r\n            superAttributeList.push(item);\r\n        }\r\n    }\r\n    return superAttributeList;\r\n}\r\n/** Join two attribute values. */\r\nfunction joinAttributeValues(superValue, assignValue) {\r\n    if (!assignValue) {\r\n        return '';\r\n    }\r\n    if (!superValue) {\r\n        superValue = '';\r\n    }\r\n    if (!/['\"]$/.test(superValue)) {\r\n        superValue = '\"' + superValue + '\"';\r\n    }\r\n    assignValue = assignValue.replace(/^['\"]|['\"]$/g, '');\r\n    return superValue.slice(0, -1) + ' ' + assignValue + superValue.slice(-1);\r\n}\r\n/** Output one parsed attribute to an attribute string. */\r\nfunction outputParsedAttribute(attr) {\r\n    if (attr.name) {\r\n        if (attr.value) {\r\n            return ' ' + attr.name + '=' + attr.value;\r\n        }\r\n        else {\r\n            return ' ' + attr.name;\r\n        }\r\n    }\r\n    else {\r\n        return ' ' + attr.text;\r\n    }\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.joinHTMLTokens = exports.parseToHTMLTokens = exports.HTMLTokenType = void 0;\r\nconst utils_1 = require(\"../helpers/utils\");\r\n/** HTML token type. */\r\nvar HTMLTokenType;\r\n(function (HTMLTokenType) {\r\n    HTMLTokenType[HTMLTokenType[\"StartTag\"] = 0] = \"StartTag\";\r\n    HTMLTokenType[HTMLTokenType[\"EndTag\"] = 1] = \"EndTag\";\r\n    HTMLTokenType[HTMLTokenType[\"Text\"] = 2] = \"Text\";\r\n})(HTMLTokenType = exports.HTMLTokenType || (exports.HTMLTokenType = {}));\r\n/** Tags that self closed. */\r\nconst SelfClosedTags = [\r\n    'area',\r\n    'base',\r\n    'br',\r\n    'col',\r\n    'embed',\r\n    'hr',\r\n    'img',\r\n    'input',\r\n    'link',\r\n    'meta',\r\n    'param',\r\n    'source',\r\n    'track',\r\n    'wbr',\r\n];\r\n/**\r\n * Parse html codes to tokens.\r\n * After parsing, all comment was removed, and `\\r\\n\\t` in text nodes was removed too.\r\n * Automatically fix `<tag />` to `<tag></tag>` for not self close tags.\r\n * attributes are not been trimmed.\r\n */\r\nfunction parseToHTMLTokens(string) {\r\n    const tagRE = /<!--[\\s\\S]*?-->|<([\\w-]+)([\\s\\S]*?)\\/?>|<\\/[\\w-]+>/g;\r\n    let lastIndex = 0;\r\n    let tokens = [];\r\n    let match;\r\n    while (match = tagRE.exec(string)) {\r\n        let piece = match[0];\r\n        if (match.index > lastIndex) {\r\n            let text = utils_1.trim(string.slice(lastIndex, match.index));\r\n            if (text) {\r\n                tokens.push({\r\n                    type: HTMLTokenType.Text,\r\n                    text,\r\n                });\r\n            }\r\n        }\r\n        lastIndex = tagRE.lastIndex;\r\n        if (piece[1] === '!') {\r\n            continue;\r\n        }\r\n        else if (piece[1] === '/') {\r\n            let tagName = piece.slice(2, -1);\r\n            if (!SelfClosedTags.includes(tagName)) {\r\n                tokens.push({\r\n                    type: HTMLTokenType.EndTag,\r\n                    tagName,\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            let tagName = match[1];\r\n            let attributes = match[2];\r\n            let selfClose = SelfClosedTags.includes(tagName);\r\n            tokens.push({\r\n                type: HTMLTokenType.StartTag,\r\n                tagName,\r\n                attributes,\r\n                selfClose,\r\n            });\r\n            //`<tag />` -> `<tag></tag>`\r\n            if (piece[piece.length - 2] === '/' && !selfClose) {\r\n                tokens.push({\r\n                    type: HTMLTokenType.EndTag,\r\n                    tagName,\r\n                });\r\n            }\r\n        }\r\n    }\r\n    if (lastIndex < string.length) {\r\n        let text = utils_1.trim(string.slice(lastIndex));\r\n        if (text) {\r\n            tokens.push({\r\n                type: HTMLTokenType.Text,\r\n                text: string.slice(lastIndex),\r\n            });\r\n        }\r\n    }\r\n    return tokens;\r\n}\r\nexports.parseToHTMLTokens = parseToHTMLTokens;\r\n/** Join tokens parsed from `parseToHTMLTokens` to HTML codes. */\r\nfunction joinHTMLTokens(tokens) {\r\n    let codes = '';\r\n    for (let token of tokens) {\r\n        switch (token.type) {\r\n            case HTMLTokenType.StartTag:\r\n                let tagName = token.tagName;\r\n                let attributes = token.attributes;\r\n                codes += '<' + tagName + attributes + '>';\r\n                break;\r\n            case HTMLTokenType.EndTag:\r\n                codes += `</${token.tagName}>`;\r\n                break;\r\n            case HTMLTokenType.Text:\r\n                codes += token.text;\r\n                break;\r\n        }\r\n    }\r\n    return codes;\r\n}\r\nexports.joinHTMLTokens = joinHTMLTokens;\r\n","\"use strict\";\r\n// At beginning, I implemented a good Emitter by inferring listener parameters and emitting parameters.\r\n// But then I meet a big problem when extending the class, described by:\r\n// https://stackoverflow.com/questions/55813041/problems-on-typescript-event-interface-extends\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.InternalEventEmitter = void 0;\r\n/**\r\n * Event emitter as super class to listen and emit custom events.\r\n * Rename as `InternalEventEmitter` to make it doesn't conflict with `EventEmitter` in `ff` framework.\r\n * @typeparam E Event interface in `{eventName: (...args) => void}` format.\r\n */\r\nclass InternalEventEmitter {\r\n    constructor() {\r\n        /** Registered events. */\r\n        this.__events = new Map();\r\n    }\r\n    /** Ensure event cache items to cache item. */\r\n    __ensureEvents(name) {\r\n        let events = this.__events.get(name);\r\n        if (!events) {\r\n            this.__events.set(name, events = []);\r\n        }\r\n        return events;\r\n    }\r\n    /**\r\n     * Registers an event `listener` to listen event with specified `name`.\r\n     * @param name The event name.\r\n     * @param listener The event listener.\r\n     * @param scope The scope will be binded to listener.\r\n     */\r\n    on(name, listener, scope) {\r\n        let events = this.__ensureEvents(name);\r\n        events.push({\r\n            listener,\r\n            scope,\r\n            once: false,\r\n        });\r\n    }\r\n    /**\r\n     * Registers an event `listener` to listen event with specified `name`, triggers for only once.\r\n     * @param name The event name.\r\n     * @param listener The event listener.\r\n     * @param scope The scope will be binded to listener.\r\n     */\r\n    once(name, listener, scope) {\r\n        let events = this.__ensureEvents(name);\r\n        events.push({\r\n            listener,\r\n            scope,\r\n            once: true\r\n        });\r\n    }\r\n    /**\r\n     * Removes the `listener` that is listening specified event `name`.\r\n     * @param name The event name.\r\n     * @param listener The event listener, only matched listener will be removed.\r\n     * @param scope The scope binded to listener. If provided, remove listener only when scope match.\r\n     */\r\n    off(name, listener, scope) {\r\n        let events = this.__events.get(name);\r\n        if (events) {\r\n            for (let i = events.length - 1; i >= 0; i--) {\r\n                let event = events[i];\r\n                if (event.listener === listener && (!scope || event.scope === scope)) {\r\n                    events.splice(i, 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Check whether `listener` is in the list for listening specified event `name`.\r\n     * @param name The event name.\r\n     * @param listener The event listener to check.\r\n     * @param scope The scope binded to listener. If provided, will additionally check whether the scope match.\r\n     */\r\n    hasListener(name, listener, scope) {\r\n        let events = this.__events.get(name);\r\n        if (events) {\r\n            for (let i = 0, len = events.length; i < len; i++) {\r\n                let event = events[i];\r\n                if (event.listener === listener && (!scope || event.scope === scope)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Check whether any `listener` is listening specified event `name`.\r\n     * @param name The event name.\r\n     */\r\n    hasListeners(name) {\r\n        let events = this.__events.get(name);\r\n        return !!events && events.length > 0;\r\n    }\r\n    /**\r\n     * Emit specified event with event `name` and parameters.\r\n     * @param name The event name.\r\n     * @param args The parameters that will be passed to event listeners.\r\n     */\r\n    emit(name, ...args) {\r\n        let events = this.__events.get(name);\r\n        if (events) {\r\n            for (let i = 0; i < events.length; i++) {\r\n                let event = events[i];\r\n                // The listener may call off, so must remove it before handling\r\n                if (event.once === true) {\r\n                    events.splice(i--, 1);\r\n                }\r\n                event.listener.apply(event.scope, args);\r\n            }\r\n        }\r\n    }\r\n    /** Removes all the event listeners. */\r\n    removeAllListeners() {\r\n        this.__events = new Map();\r\n    }\r\n}\r\nexports.InternalEventEmitter = InternalEventEmitter;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.NodeAnchor = exports.NodeAnchorType = void 0;\r\n/** Anchor type to indicate where to put the anchor at. */\r\nvar NodeAnchorType;\r\n(function (NodeAnchorType) {\r\n    /** Anchor node is next to inserted node. */\r\n    NodeAnchorType[NodeAnchorType[\"Next\"] = 0] = \"Next\";\r\n    /** Anchor node is a container element and will insert new node as it's last child. */\r\n    NodeAnchorType[NodeAnchorType[\"Container\"] = 1] = \"Container\";\r\n})(NodeAnchorType = exports.NodeAnchorType || (exports.NodeAnchorType = {}));\r\n/**\r\n * To mark position to insert nodes.\r\n * Please never move the anchor node, the whole document may be removed.\r\n */\r\nclass NodeAnchor {\r\n    constructor(el, type) {\r\n        this.el = el;\r\n        this.type = type;\r\n    }\r\n    /** Insert element to the anchor position. */\r\n    insert(node) {\r\n        if (this.type === NodeAnchorType.Next) {\r\n            this.el.before(node);\r\n        }\r\n        else {\r\n            this.el.append(node);\r\n        }\r\n    }\r\n}\r\nexports.NodeAnchor = NodeAnchor;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ContainerRange = exports.NodeRange = void 0;\r\n/**\r\n * A node range represents a range of nodes from it's start and end position,\r\n * Such that we can extract nodes in the whole range and make a fragment any time,\r\n * no matter nodes inside was moved or removed, or insert more.\r\n */\r\nclass NodeRange {\r\n    constructor(fragment) {\r\n        /** Parent to contains all the nodes. */\r\n        this.fragment = null;\r\n        this.fragment = fragment;\r\n        // Fragment hould include at least one node, so it's position can be tracked.\r\n        // Because startNode should always before any other nodes inside the template or as rest slot lement,\r\n        // So if starts with a hole - comment node, which will insert nodes before it,\r\n        // we need to prepend a comment node as `startNode`.\r\n        let startNode = fragment.firstChild;\r\n        if (!startNode || startNode.nodeType === 8) {\r\n            startNode = document.createComment('');\r\n            fragment.prepend(startNode);\r\n        }\r\n        this.startNode = startNode;\r\n        // No need to worry about the last node, it's a fixed element, even for a hole - it's a comment node.\r\n        // Because we always follows the rule in NodeAnchor: Insert more nodes before or in append postion.\r\n        this.endNode = fragment.lastChild;\r\n    }\r\n    /** Get current container, may return `null`. */\r\n    getCurrentFragment() {\r\n        return this.fragment;\r\n    }\r\n    /**\r\n     * Extract all nodes into a fragment.\r\n     * You must insert the extracted fragment into a container soon.\r\n     * Used to get just parsed fragment, or reuse template nodes.\r\n     */\r\n    extractToFragment() {\r\n        let fragment;\r\n        if (this.fragment instanceof DocumentFragment) {\r\n            fragment = this.fragment;\r\n        }\r\n        else {\r\n            fragment = document.createDocumentFragment();\r\n            fragment.append(...this.getNodes());\r\n        }\r\n        // Breaks the fragment-child relationship.\r\n        this.fragment = null;\r\n        return fragment;\r\n    }\r\n    /**\r\n     * Moves all nodes out from parent container,\r\n     * and cache into a new fragment in order to use them later.\r\n     */\r\n    movesOut() {\r\n        this.fragment = this.extractToFragment();\r\n    }\r\n    /** Get all the nodes in the range. */\r\n    getNodes() {\r\n        let nodes = [];\r\n        let node = this.startNode;\r\n        while (node) {\r\n            nodes.push(node);\r\n            if (node === this.endNode) {\r\n                break;\r\n            }\r\n            node = node.nextSibling;\r\n        }\r\n        return nodes;\r\n    }\r\n    /** Get first element in range. */\r\n    getFirstElement() {\r\n        let node = this.startNode;\r\n        while (node) {\r\n            if (node.nodeType === 1) {\r\n                return node;\r\n            }\r\n            if (node === this.endNode) {\r\n                break;\r\n            }\r\n            node = node.nextSibling;\r\n        }\r\n        return null;\r\n    }\r\n    /** Insert all the nodes of specified range before start node of current range. */\r\n    before(range) {\r\n        this.startNode.before(range.extractToFragment());\r\n    }\r\n    /** Replace all the nodes in the range with the nodes of specified range. */\r\n    replaceWith(range) {\r\n        this.startNode.before(range.extractToFragment());\r\n        this.remove();\r\n    }\r\n    /**\r\n     * Remove all the nodes in range from parent container.\r\n     * Call this means you will never reuse nodes in the range.\r\n     */\r\n    remove() {\r\n        this.getNodes().forEach(node => node.remove());\r\n    }\r\n}\r\nexports.NodeRange = NodeRange;\r\n/** Compare to `NodeRange`, it only marks end node. */\r\nclass ContainerRange {\r\n    constructor(container) {\r\n        this.container = container;\r\n        this.endNode = container.lastChild;\r\n    }\r\n    /**\r\n     * Extract all nodes into a fragment.\r\n     * You must insert the extracted fragment into a container soon.\r\n     * Used to get just parsed fragment, or reuse template nodes.\r\n     */\r\n    extractToFragment() {\r\n        let fragment = document.createDocumentFragment();\r\n        fragment.append(...this.getNodes());\r\n        return fragment;\r\n    }\r\n    /** Get all the nodes in the range. */\r\n    getNodes() {\r\n        let nodes = [];\r\n        let node = this.container.firstChild;\r\n        while (node) {\r\n            nodes.push(node);\r\n            if (node === this.endNode) {\r\n                break;\r\n            }\r\n            node = node.nextSibling;\r\n        }\r\n        return nodes;\r\n    }\r\n    /**\r\n     * Remove all the nodes in range from parent container.\r\n     * Call this means you will never reuse nodes in the range.\r\n     */\r\n    remove() {\r\n        this.getNodes().forEach(node => node.remove());\r\n    }\r\n}\r\nexports.ContainerRange = ContainerRange;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.parseStyleCodes = exports.getScopedClassNames = void 0;\r\n/** Caches `componentName` -> className[]` map. */\r\nconst scopedClassNamesMap = new Map();\r\n/** Get set of all scoped class names from defined component name. */\r\nfunction getScopedClassNames(scopeName) {\r\n    return scopedClassNamesMap.get(scopeName);\r\n}\r\nexports.getScopedClassNames = getScopedClassNames;\r\n/**\r\n * Parse result returned from `Component.style()` result to standard style codes.\r\n * And also remembers all class names inside.\r\n */\r\nfunction parseStyleCodes(text, scopeName) {\r\n    let re = /(\\s*)(?:\\/\\/.*|\\/\\*[\\s\\S]*?\\*\\/|((?:\\(.*?\\)|\".*?\"|'.*?'|[\\s\\S])*?)([;{}]))/g;\r\n    /*\r\n        \\s* - match white spaces in left\r\n        (?:\r\n            \\/\\/.* - match comment line\r\n            |\r\n            \\/\\*[\\s\\S]*?\\*\\/ - match comment seagment\r\n            |\r\n            (?:\r\n                \\(.*?\\) - (...), sass code may include @include fn(${name})\r\n                \".*?\" - double quote string\r\n                |\r\n                '.*?' - double quote string\r\n                |\r\n                [\\s\\S] - others\r\n            )*? - declaration or selector\r\n            ([;{}])\r\n        )\r\n    */\r\n    let match;\r\n    let stack = [];\r\n    let current;\r\n    let codes = '';\r\n    let classNameSet = getClassNameSet(scopeName);\r\n    let keyframesDeep = 0;\r\n    while (match = re.exec(text)) {\r\n        let spaces = match[1];\r\n        let chars = match[2];\r\n        let endChar = match[3];\r\n        if (endChar === '{' && chars) {\r\n            // Commands likes `@media` must in the out most level.\r\n            if (chars[0] === '@' || keyframesDeep > 0) {\r\n                codes += match[0];\r\n                if (chars.startsWith('@keyframes')) {\r\n                    keyframesDeep = 1;\r\n                }\r\n                else if (keyframesDeep > 0) {\r\n                    keyframesDeep++;\r\n                }\r\n            }\r\n            else {\r\n                if (current) {\r\n                    stack.push(current);\r\n                    codes += '}';\r\n                }\r\n                let names = current = splitNamesAndCombineNesting(chars, current, scopeName);\r\n                if (scopeName) {\r\n                    names = current.map(name => scopeClassName(name, scopeName, classNameSet));\r\n                }\r\n                codes += spaces + names.join(', ') + '{';\r\n            }\r\n        }\r\n        // May also be end paren `@media{...}`, but it's can't be included in any selectors.\r\n        else if (endChar === '}') {\r\n            if (keyframesDeep > 0) {\r\n                keyframesDeep--;\r\n            }\r\n            current = stack.pop();\r\n            // Not add `}` for sass like nesting.\r\n            if (!current) {\r\n                codes += match[0];\r\n            }\r\n        }\r\n        else {\r\n            // Skip `/*...*/` and `//...`\r\n            let startChar = match[0][spaces.length];\r\n            if (startChar !== '/') {\r\n                codes += match[0];\r\n            }\r\n        }\r\n    }\r\n    return codes;\r\n}\r\nexports.parseStyleCodes = parseStyleCodes;\r\n/** Get or create a set caches class names for `scopeName`. */\r\nfunction getClassNameSet(scopeName) {\r\n    if (!scopeName) {\r\n        return null;\r\n    }\r\n    // May add more scoped class name when using `render` or `renderAndUpdate`.\r\n    let classNameSet = scopedClassNamesMap.get(scopeName);\r\n    if (!classNameSet) {\r\n        classNameSet = new Set();\r\n        scopedClassNamesMap.set(scopeName, classNameSet);\r\n    }\r\n    return classNameSet;\r\n}\r\n/** `a, b` -> `[parent a, parent b]` */\r\nfunction splitNamesAndCombineNesting(selector, current, comName) {\r\n    let re = /((?:\\[.*?\\]|\\(.*?\\)|[\\s\\S])+?)(?:,|$)/g;\r\n    /*\r\n        (?:\r\n            \\[.*?\\] - match [...]\r\n            |\r\n            \\(.*?\\) - match (...)\r\n            |\r\n            . - match other characters\r\n        )\r\n        +?\r\n        (?:,|$) - if match ',' or '$', end\r\n    */\r\n    let match;\r\n    let names = [];\r\n    while (match = re.exec(selector)) {\r\n        let name = match[1].trim();\r\n        if (name) {\r\n            if (!current) {\r\n                name = scopeTagSelector(name, comName);\r\n            }\r\n            names.push(name);\r\n        }\r\n    }\r\n    if (current) {\r\n        names = combineNestingNames(names, current);\r\n    }\r\n    return names;\r\n}\r\n/**\r\n * `a{b{...}}` -> `a b{...}`\r\n * `a{&-b{...}}` -> a-b{...}`\r\n */\r\nfunction combineNestingNames(oldNames, parentNames) {\r\n    // Has sass reference `&` if match\r\n    let re = /(^|[\\s+>~])&/g; // `/(?<=^|[\\s+>~])&/g` should be better, but Firefox not support it.\r\n    let names = [];\r\n    for (let oldName of oldNames) {\r\n        if (re.test(oldName)) {\r\n            for (let parentName of parentNames) {\r\n                names.push(oldName.replace(re, '$1' + parentName));\r\n            }\r\n        }\r\n        else {\r\n            for (let parentName of parentNames) {\r\n                names.push(parentName + ' ' + oldName);\r\n            }\r\n        }\r\n    }\r\n    return names;\r\n}\r\n/** `.name` -> `.name__com-name` */\r\nfunction scopeClassName(name, comName, classNameSet) {\r\n    return name.replace(/\\.([\\w-]+)/g, (m0, name) => {\r\n        if (m0.includes('__')) {\r\n            return m0;\r\n        }\r\n        else {\r\n            classNameSet.add(name);\r\n            return m0 + '__' + comName;\r\n        }\r\n    });\r\n}\r\n/**\r\n * `p` -> `com-name p`.\r\n * `:host` -> `com-name`.\r\n * May be parsed to different style codes in different component.\r\n */\r\nfunction scopeTagSelector(name, comName) {\r\n    return name.replace(/^(?=\\w)/g, comName + ' ')\r\n        .replace(/:host/g, comName);\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.clearTransition = exports.isPlayingTransition = exports.Transition = exports.defineTransion = exports.getCSSEasingValue = void 0;\r\nconst dom_event_1 = require(\"./dom-event\");\r\nconst queue_1 = require(\"../queue\");\r\n/** Default animation duration, plays transition for millseconds according to this property by default. */\r\nconst DefaultTransitionDuration = 200;\r\n/** Default transition duration, plays transition with easing according to this property by default. */\r\nconst DefaultTransitionEasing = 'ease-out-quad';\r\n/** Cache element and their current playing Transition. */\r\nconst ElementTransitionCache = new WeakMap();\r\n/** Cache all defined JS Transitions. */\r\nconst DefinedJSTransitions = new Map();\r\n/** Specifies easing name and their bezier parameters, copied from `Bourbon` source codes. */\r\nconst CUBIC_BEZIER_EASINGS = {\r\n    // BASE\r\n    'ease': [0.250, 0.100, 0.250, 1.000],\r\n    'ease-in': [0.420, 0.000, 1.000, 1.000],\r\n    'ease-out': [0.000, 0.000, 0.580, 1.000],\r\n    'ease-in-out': [0.420, 0.000, 0.580, 1.000],\r\n    // EASE IN\r\n    'ease-in-quad': [0.550, 0.085, 0.680, 0.530],\r\n    'ease-in-cubic': [0.550, 0.055, 0.675, 0.190],\r\n    'ease-in-quart': [0.895, 0.030, 0.685, 0.220],\r\n    'ease-in-quint': [0.755, 0.050, 0.855, 0.060],\r\n    'ease-in-sine': [0.470, 0.000, 0.745, 0.715],\r\n    'ease-in-expo': [0.950, 0.050, 0.795, 0.035],\r\n    'ease-in-circ': [0.600, 0.040, 0.980, 0.335],\r\n    'ease-in-back': [0.600, -0.280, 0.735, 0.045],\r\n    // EASE OUT\r\n    'ease-out-quad': [0.250, 0.460, 0.450, 0.940],\r\n    'ease-out-cubic': [0.215, 0.610, 0.355, 1.000],\r\n    'ease-out-quart': [0.165, 0.840, 0.440, 1.000],\r\n    'ease-out-quint': [0.230, 1.000, 0.320, 1.000],\r\n    'ease-out-sine': [0.390, 0.575, 0.565, 1.000],\r\n    'ease-out-expo': [0.190, 1.000, 0.220, 1.000],\r\n    'ease-out-circ': [0.075, 0.820, 0.165, 1.000],\r\n    'ease-out-back': [0.175, 0.885, 0.320, 1.275],\r\n    // EASE IN OUT\r\n    'ease-in-out-quad': [0.455, 0.030, 0.515, 0.955],\r\n    'ease-in-out-cubic': [0.645, 0.045, 0.355, 1.000],\r\n    'ease-in-out-quart': [0.770, 0.000, 0.175, 1.000],\r\n    'ease-in-out-quint': [0.860, 0.000, 0.070, 1.000],\r\n    'ease-in-out-sine': [0.445, 0.050, 0.550, 0.950],\r\n    'ease-in-out-expo': [1.000, 0.000, 0.000, 1.000],\r\n    'ease-in-out-circ': [0.785, 0.135, 0.150, 0.860],\r\n    'ease-in-out-back': [0.680, -0.550, 0.265, 1.550],\r\n};\r\n/** All CSS properties that can play transition. */\r\nconst CSS_PROPERTIES = {\r\n    width: true,\r\n    height: true,\r\n    opacity: true,\r\n    margin: true,\r\n    marginLeft: true,\r\n    marginRght: true,\r\n    marginTop: true,\r\n    marginBottom: true,\r\n    padding: true,\r\n    paddingLeft: true,\r\n    paddingRght: true,\r\n    paddingTop: true,\r\n    paddingBottom: true,\r\n    borderWidth: true,\r\n    borderLeftWidth: true,\r\n    borderRightWidth: true,\r\n    borderTopWidth: true,\r\n    borderBottomWidth: true,\r\n    transform: true\r\n};\r\n/**\r\n * Get `cubic-bezier(...)` as CSS easing from easing name.\r\n * @param easing The extended easing name.\r\n * @returns CSS easing codes like `line` or `cubic-bezier(...)`.\r\n */\r\nfunction getCSSEasingValue(easing) {\r\n    return CUBIC_BEZIER_EASINGS.hasOwnProperty(easing)\r\n        ? 'cubic-bezier(' + CUBIC_BEZIER_EASINGS[easing].join(', ') + ')'\r\n        : 'linear';\r\n}\r\nexports.getCSSEasingValue = getCSSEasingValue;\r\n/**\r\n * Define a JS transiton and process all transition details internally.\r\n * @param name Transition name, must be unique.\r\n * @param TransitionConstructor A `Transition` class.\r\n */\r\nfunction defineTransion(name, TransitionConstructor) {\r\n    if (DefinedJSTransitions.has(name)) {\r\n        console.warn(`You are trying to overwrite transition definition \"${name}\"`);\r\n    }\r\n    if (CSS_PROPERTIES.hasOwnProperty(name)) {\r\n        console.warn(`\"${name}\" is an available CSS property, you may confuse them when using short transition`);\r\n    }\r\n    DefinedJSTransitions.set(name, TransitionConstructor);\r\n}\r\nexports.defineTransion = defineTransion;\r\n/**\r\n * Class used to play specified transition on an element.\r\n * Transition types includes class name, css properties, and registered js transition.\r\n */\r\nclass Transition {\r\n    constructor(el, options) {\r\n        this.cleaner = null;\r\n        this.el = el;\r\n        this.options = options;\r\n        clearTransition(this.el);\r\n        ElementTransitionCache.set(this.el, this);\r\n    }\r\n    /** Plays enter animation. */\r\n    enter() {\r\n        return new Promise(resolve => {\r\n            this.clean();\r\n            let direction = this.options.direction;\r\n            let willPlay = direction === 'enter' || direction === 'both' || direction === undefined;\r\n            if (!willPlay) {\r\n                resolve(true);\r\n                return;\r\n            }\r\n            let onEntered = (finish) => {\r\n                ElementTransitionCache.delete(this.el);\r\n                resolve(finish);\r\n            };\r\n            if (this.options.properties) {\r\n                this.cssEnter(onEntered);\r\n            }\r\n            else if (this.options.name && DefinedJSTransitions.has(this.options.name)) {\r\n                this.jsEnter(onEntered);\r\n            }\r\n            else {\r\n                this.classEnterOrLeave('enter', onEntered);\r\n            }\r\n        });\r\n    }\r\n    /** Plays leave animation. */\r\n    leave() {\r\n        return new Promise(resolve => {\r\n            this.clean();\r\n            let el = this.el;\r\n            let direction = this.options.direction;\r\n            let willPlay = direction === 'leave' || direction === 'both' || direction === undefined;\r\n            if (!willPlay) {\r\n                resolve(true);\r\n                return;\r\n            }\r\n            // If mouse hover trigger element, it's related popup becomes visible.\r\n            el.style.pointerEvents = 'none';\r\n            let onLeaved = (finish) => {\r\n                ElementTransitionCache.delete(this.el);\r\n                el.style.pointerEvents = '';\r\n                resolve(finish);\r\n            };\r\n            if (this.options.properties) {\r\n                this.cssLeave(onLeaved);\r\n            }\r\n            else if (this.options.name && DefinedJSTransitions.has(this.options.name)) {\r\n                this.jsLeave(onLeaved);\r\n            }\r\n            else {\r\n                this.classEnterOrLeave('leave', onLeaved);\r\n            }\r\n        });\r\n    }\r\n    cssEnter(onEntered) {\r\n        let startFrame = {};\r\n        for (let property of this.options.properties) {\r\n            startFrame[property] = property === 'transform' ? 'none' : '0';\r\n        }\r\n        let { promise, cancel } = webAnimateFrom(this.el, startFrame, this.options.duration || DefaultTransitionDuration, this.options.easing || DefaultTransitionEasing);\r\n        promise.then(onEntered);\r\n        this.cleaner = cancel;\r\n    }\r\n    cssLeave(onLeaved) {\r\n        let endFrame = {};\r\n        for (let property of this.options.properties) {\r\n            endFrame[property] = property === 'transform' ? 'none' : '0';\r\n        }\r\n        let { promise, cancel } = webAnimateTo(this.el, endFrame, this.options.duration || DefaultTransitionDuration, this.options.easing || DefaultTransitionEasing);\r\n        promise.then(onLeaved);\r\n        this.cleaner = cancel;\r\n    }\r\n    jsEnter(onEntered) {\r\n        let jsTransition = this.getJSTransitionInstance();\r\n        if (jsTransition.enter) {\r\n            jsTransition.enter.then(onEntered);\r\n            this.cleaner = jsTransition.clean.bind(jsTransition);\r\n        }\r\n        else {\r\n            onEntered(true);\r\n        }\r\n    }\r\n    jsLeave(onLeaved) {\r\n        let jsTransition = this.getJSTransitionInstance();\r\n        if (jsTransition.leave) {\r\n            jsTransition.leave.then(onLeaved);\r\n            this.cleaner = jsTransition.clean.bind(jsTransition);\r\n        }\r\n        else {\r\n            onLeaved(true);\r\n        }\r\n    }\r\n    getJSTransitionInstance() {\r\n        let JsTransition = DefinedJSTransitions.get(this.options.name);\r\n        return new JsTransition(this.el, {\r\n            duration: this.options.duration || DefaultTransitionDuration,\r\n            easing: this.options.easing || (DefaultTransitionEasing)\r\n        });\r\n    }\r\n    async classEnterOrLeave(type, callback) {\r\n        let className = this.options.name + '-' + type;\r\n        let duration = this.options.duration;\r\n        let easing = this.options.easing;\r\n        let canceled = false;\r\n        let el = this.el;\r\n        if (duration) {\r\n            el.style.transitionDuration = String(duration / 1000) + 's';\r\n        }\r\n        if (easing) {\r\n            el.style.transitionTimingFunction = getCSSEasingValue(easing);\r\n        }\r\n        el.style.transition = 'none';\r\n        el.classList.add(className, className + '-from');\r\n        this.cleaner = () => {\r\n            canceled = true;\r\n        };\r\n        // Here to makesure rendering complete for current frame,\r\n        // Then the next `requestAnimationFrame` will be called for a new frame.\r\n        // Then we can play transition betweens these 2 frames.\r\n        queue_1.onRenderComplete(() => {\r\n            requestAnimationFrame(() => {\r\n                if (canceled) {\r\n                    el.classList.remove(className, className + '-from');\r\n                    return;\r\n                }\r\n                if (duration) {\r\n                    el.style.transitionDuration = '';\r\n                }\r\n                if (easing) {\r\n                    el.style.transitionTimingFunction = '';\r\n                }\r\n                el.style.transition = '';\r\n                el.classList.remove(className + '-from');\r\n                el.classList.add(className + '-to');\r\n                this.onceTransitionEnd((finish) => {\r\n                    el.classList.remove(className, className + '-to');\r\n                    callback(finish);\r\n                });\r\n            });\r\n        });\r\n    }\r\n    onceTransitionEnd(onEnd) {\r\n        let el = this.el;\r\n        let computedStyle = getComputedStyle(el);\r\n        let transitionDuration = parseFloat(computedStyle.transitionDuration) || 0;\r\n        let animationDuration = parseFloat(computedStyle.animationDuration) || 0;\r\n        let eventName = transitionDuration > 0 ? 'transitionend' : 'animationend';\r\n        let duration = (transitionDuration || animationDuration) * 1000;\r\n        let onTransitionEnd = () => {\r\n            clearTimeout(timeoutId);\r\n            onEnd(true);\r\n        };\r\n        let onTimeout = () => {\r\n            dom_event_1.off(el, eventName, onTransitionEnd);\r\n            onEnd(true);\r\n        };\r\n        let timeoutId = setTimeout(onTimeout, duration + 50);\r\n        dom_event_1.once(el, eventName, onTransitionEnd);\r\n        this.cleaner = () => {\r\n            clearTimeout(timeoutId);\r\n            dom_event_1.off(el, eventName, onTransitionEnd);\r\n            onEnd(false);\r\n        };\r\n    }\r\n    clean() {\r\n        if (this.cleaner) {\r\n            this.cleaner();\r\n            this.cleaner = null;\r\n        }\r\n    }\r\n}\r\nexports.Transition = Transition;\r\n/**\r\n * Checks whether `el` is playing a transition.\r\n * @param el The element at which to check whether playing transition.\r\n */\r\nfunction isPlayingTransition(el) {\r\n    return ElementTransitionCache.has(el);\r\n}\r\nexports.isPlayingTransition = isPlayingTransition;\r\n/**\r\n * Clear the transition that is running in the element.\r\n * @param el The element at which to clear transition.\r\n */\r\nfunction clearTransition(el) {\r\n    if (ElementTransitionCache.has(el)) {\r\n        ElementTransitionCache.get(el).clean();\r\n    }\r\n}\r\nexports.clearTransition = clearTransition;\r\n/** The default style of element, which is not `0` */\r\nconst DefaultNotNumericStyleProperties = {\r\n    transform: 'none'\r\n};\r\n/**\r\n * Execute standard web animation on element.\r\n * After animation end, the state of element will go back to the start state.\r\n */\r\nfunction webAnimate(el, startFrame, endFrame, duration, easing) {\r\n    if (!el.animate) {\r\n        return {\r\n            promise: Promise.resolve(false),\r\n            cancel: () => { }\r\n        };\r\n    }\r\n    let cubicEasing = getCSSEasingValue(easing);\r\n    let animation = el.animate([startFrame, endFrame], {\r\n        easing: cubicEasing,\r\n        duration,\r\n    });\r\n    let promise = new Promise((resolve) => {\r\n        animation.addEventListener('finish', () => {\r\n            resolve(true);\r\n        }, false);\r\n        animation.addEventListener('cancel', () => {\r\n            resolve(false);\r\n        }, false);\r\n    });\r\n    function cancel() {\r\n        animation.cancel();\r\n    }\r\n    return {\r\n        promise,\r\n        cancel,\r\n    };\r\n}\r\n/**\r\n * Execute standard web animation on element with start frame specified.\r\n * The end frame will be set as zero or empty values.\r\n */\r\nfunction webAnimateFrom(el, startFrame, duration, easing) {\r\n    let endFrame = {};\r\n    let style = getComputedStyle(el);\r\n    for (let property in startFrame) {\r\n        endFrame[property] = style[property] || DefaultNotNumericStyleProperties[property] || '0';\r\n    }\r\n    return webAnimate(el, startFrame, endFrame, duration, easing);\r\n}\r\n/**\r\n * Execute standard web animation on element with end frame specified.\r\n * The end frame will be specified as values of current state.\r\n * After animation executed, will not apply end frame values to element.\r\n */\r\nfunction webAnimateTo(el, endFrame, duration, easing) {\r\n    let startFrame = {};\r\n    let style = getComputedStyle(el);\r\n    for (let property in endFrame) {\r\n        startFrame[property] = style[property] || DefaultNotNumericStyleProperties[property] || '0';\r\n    }\r\n    return webAnimate(el, startFrame, endFrame, duration, easing);\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.UpdatableOptions = void 0;\r\n/** Used to mange updatable options and can also quickly assign default values. */\r\nclass UpdatableOptions {\r\n    constructor(defaultOptions) {\r\n        this.updated = false;\r\n        this.options = null;\r\n        this.defaultOptions = defaultOptions;\r\n    }\r\n    /** Whether not been updated. */\r\n    isNotUpdated() {\r\n        return !this.updated;\r\n    }\r\n    /** Update options, assign `options` to current option object. */\r\n    update(options) {\r\n        this.options = options || null;\r\n        this.updated = true;\r\n    }\r\n    /**\r\n     * Get specified option value from it's key.\r\n     * May get a default value if not set.\r\n     */\r\n    get(key) {\r\n        if (this.options) {\r\n            let value = this.options[key];\r\n            return value === undefined ? this.defaultOptions[key] : value;\r\n        }\r\n        else {\r\n            return this.defaultOptions[key];\r\n        }\r\n    }\r\n    /**\r\n     * Check if have set specified option value from it's key.\r\n     * Ignores default values.\r\n     */\r\n    has(key) {\r\n        if (this.options) {\r\n            return this.options[key] !== undefined;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    /** Get all options. */\r\n    getOptions() {\r\n        return this.options || this.defaultOptions;\r\n    }\r\n}\r\nexports.UpdatableOptions = UpdatableOptions;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.notifyComPropertySet = exports.addComDependency = exports.notifyObjectSet = exports.addDependency = exports.isUpdating = exports.endUpdating = exports.startUpdating = exports.clearDependenciesOf = void 0;\r\nconst weak_2way_map_1 = require(\"../helpers/weak-2way-map\");\r\nconst weak_2way_prop_map_1 = require(\"../helpers/weak-2way-prop-map\");\r\n/**\r\n * `UpdatableProxied <-> Dependency` map.\r\n *\r\n * To know when rendering a component or update a watcher, all the dependent objects it used.\r\n * So after any of those object changed, we know which components or watchers should be updated.\r\n *\r\n * If the dependent objects were removed, the component or watchers should be updated,\r\n * and it will clear useless dependencies before.\r\n * So cached the objects will not prevent GC.\r\n */\r\nconst DepMap = new weak_2way_map_1.Weak2WayMap();\r\n/**\r\n * `UpdatableProxied <-> Dependency -> Property` map.\r\n *\r\n * To know when rendering a component or update a watcher, all dependent components and what's the properties it used.\r\n * So after any of those properties changed, we know which components or watchers should be updated.\r\n *\r\n * Why we don't observe properties for all the objects but only components?\r\n * In fact I do so at beginning, until one day I found 1M dependencies in my app.\r\n * There is no memory leak, my app just may load more than 10K data records.\r\n *\r\n * Otherwise, our implementation for updating is not 100% precise,\r\n * and update whole component part at once, not update each properties, bindings, directives.\r\n * So no need to observe all the details.\r\n */\r\nconst ComPropMap = new weak_2way_prop_map_1.Weak2WayPropMap();\r\n/** The updating component or watcher. */\r\nlet updating = null;\r\n/** May one updating is not completed and start a new one, so a stack is required. */\r\nconst updatingStack = [];\r\n/**\r\n * Called when a component or a watcher disconnected,\r\n * No need to trigger updating on the component or watcher any more.\r\n */\r\nfunction clearDependenciesOf(updating) {\r\n    DepMap.clearFromLeft(updating);\r\n    ComPropMap.clearFromLeft(updating);\r\n}\r\nexports.clearDependenciesOf = clearDependenciesOf;\r\n/** Called when start rendering a component or running a watcher function. */\r\nfunction startUpdating(source) {\r\n    if (updating) {\r\n        updatingStack.push(updating);\r\n    }\r\n    updating = {\r\n        source,\r\n        deps: new Set(),\r\n        depProps: new Map(),\r\n    };\r\n}\r\nexports.startUpdating = startUpdating;\r\n/** Called when complete rendering component or complete running watch functions. */\r\nfunction endUpdating(_source) {\r\n    // We split updating dependencies to two steps:\r\n    //   1. Collect dependencies, cache them.\r\n    //   2. Merge them into dependency tree.\r\n    // \r\n    // It's common to use one object dependency for moren than 100 times in one updating,\r\n    // no need to update dependency tree each time.\r\n    if (updating) {\r\n        DepMap.updateFromLeft(updating.source, updating.deps);\r\n        ComPropMap.updateFromLeft(updating.source, updating.depProps);\r\n        updating = updatingStack.pop() || null;\r\n    }\r\n}\r\nexports.endUpdating = endUpdating;\r\n/** Whether is updating recently. */\r\nfunction isUpdating() {\r\n    return !!updating;\r\n}\r\nexports.isUpdating = isUpdating;\r\n/** Called when uses an object or array. */\r\nfunction addDependency(dep) {\r\n    if (!updating) {\r\n        return;\r\n    }\r\n    updating.deps.add(dep);\r\n}\r\nexports.addDependency = addDependency;\r\n/** Called when changing an array or object. */\r\nfunction notifyObjectSet(obj) {\r\n    let upts = DepMap.getFromRight(obj);\r\n    if (upts) {\r\n        for (let upt of upts) {\r\n            upt.update();\r\n        }\r\n    }\r\n}\r\nexports.notifyObjectSet = notifyObjectSet;\r\n/** Called when uses one property of component. */\r\nfunction addComDependency(com, prop) {\r\n    if (!updating) {\r\n        return;\r\n    }\r\n    let propertySet = updating.depProps.get(com);\r\n    if (!propertySet) {\r\n        propertySet = new Set();\r\n        updating.depProps.set(com, propertySet);\r\n    }\r\n    propertySet.add(prop);\r\n}\r\nexports.addComDependency = addComDependency;\r\n/** Called when setting one property of component. */\r\nfunction notifyComPropertySet(com, prop) {\r\n    let upts = ComPropMap.getFromRight(com, prop);\r\n    if (upts) {\r\n        for (let upt of upts) {\r\n            upt.update();\r\n        }\r\n    }\r\n}\r\nexports.notifyComPropertySet = notifyComPropertySet;\r\n","\"use strict\";\r\n// Proxy object getting and setting are 50x-100x slower than plain object.\r\n// Proxy can't apply any compile optimizing, it equals always call a dynamic function.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar observe_1 = require(\"./observe\");\r\nObject.defineProperty(exports, \"observe\", { enumerable: true, get: function () { return observe_1.observe; } });\r\nvar observe_com_1 = require(\"./observe-com\");\r\nObject.defineProperty(exports, \"observeComTarget\", { enumerable: true, get: function () { return observe_com_1.observeComTarget; } });\r\nvar dependency_1 = require(\"./dependency\");\r\nObject.defineProperty(exports, \"startUpdating\", { enumerable: true, get: function () { return dependency_1.startUpdating; } });\r\nObject.defineProperty(exports, \"endUpdating\", { enumerable: true, get: function () { return dependency_1.endUpdating; } });\r\nObject.defineProperty(exports, \"clearDependenciesOf\", { enumerable: true, get: function () { return dependency_1.clearDependenciesOf; } });\r\nvar observe_getter_1 = require(\"./observe-getter\");\r\nObject.defineProperty(exports, \"observeGetting\", { enumerable: true, get: function () { return observe_getter_1.observeGetting; } });\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.observeArrayTarget = void 0;\r\nconst dependency_1 = require(\"./dependency\");\r\nconst observe_1 = require(\"./observe\");\r\nconst target_proxy_1 = require(\"./target-proxy\");\r\nconst WillObserveArrayMethods = ['push', 'pop', 'unshift', 'splice', 'shift', 'sort'];\r\nfunction observeArrayTarget(array) {\r\n    let proxy = new Proxy(array, proxyHandler);\r\n    target_proxy_1.addTargetAndProxy(array, proxy);\r\n    return proxy;\r\n}\r\nexports.observeArrayTarget = observeArrayTarget;\r\nconst proxyHandler = {\r\n    get(array, prop) {\r\n        let value = array[prop];\r\n        let type = typeof value;\r\n        if (array.hasOwnProperty(prop)) {\r\n            dependency_1.addDependency(array);\r\n            if (value && type === 'object') {\r\n                let observed = target_proxy_1.getObservedOf(value);\r\n                if (observed) {\r\n                    return observed;\r\n                }\r\n                else if (dependency_1.isUpdating()) {\r\n                    return observe_1.observeTarget(value);\r\n                }\r\n            }\r\n        }\r\n        else if (type === 'function') {\r\n            dependency_1.addDependency(array);\r\n            if (WillObserveArrayMethods.includes(prop)) {\r\n                dependency_1.notifyObjectSet(array);\r\n            }\r\n        }\r\n        return value;\r\n    },\r\n    set(array, prop, value) {\r\n        array[prop] = value;\r\n        dependency_1.notifyObjectSet(array);\r\n        return true;\r\n    },\r\n    has(arr, prop) {\r\n        dependency_1.addDependency(arr);\r\n        return prop in arr;\r\n    },\r\n    deleteProperty(arr, prop) {\r\n        if (arr.hasOwnProperty(prop)) {\r\n            dependency_1.addDependency(arr);\r\n            return delete arr[prop];\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }\r\n};\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.observeComTarget = void 0;\r\nconst dependency_1 = require(\"./dependency\");\r\nconst observe_1 = require(\"./observe\");\r\nconst target_proxy_1 = require(\"./target-proxy\");\r\nfunction observeComTarget(com) {\r\n    let proxy = new Proxy(com, proxyHandler);\r\n    target_proxy_1.addTargetAndProxy(com, proxy);\r\n    return proxy;\r\n}\r\nexports.observeComTarget = observeComTarget;\r\nconst proxyHandler = {\r\n    get(com, prop) {\r\n        let value = com[prop];\r\n        // Not check whether own property exist here.\r\n        // It's common that to declare `property!: Type` in Typescript,\r\n        // Which has no initialize value but still need to be observed.\r\n        dependency_1.addComDependency(com, prop);\r\n        if (value && typeof value === 'object') {\r\n            let observed = target_proxy_1.getObservedOf(value);\r\n            if (observed) {\r\n                return observed;\r\n            }\r\n            // Only observe more properties when updating.\r\n            // If we choose to always observe every value, too many proxies will be generated.\r\n            else if (dependency_1.isUpdating()) {\r\n                return observe_1.observeTarget(value);\r\n            }\r\n        }\r\n        return value;\r\n    },\r\n    set(com, prop, value) {\r\n        com[prop] = value;\r\n        dependency_1.notifyComPropertySet(com, prop);\r\n        return true;\r\n    },\r\n    has(com, prop) {\r\n        dependency_1.addComDependency(com, prop);\r\n        return prop in com;\r\n    },\r\n    deleteProperty(com, prop) {\r\n        if (com.hasOwnProperty(prop)) {\r\n            dependency_1.addComDependency(com, prop);\r\n            return delete com[prop];\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }\r\n};\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.observeGetting = void 0;\r\n/**\r\n * After consider much about getter, we decided to drop supports for observing getters automatically.\r\n * The main reason is after we observed getter calls in a proxy,\r\n * We can't determine this is a getter calls,\r\n * and we must follow prototype chains to find the descriptor,\r\n * then we can know it's a getter or normal property.\r\n * This will slow the whole observing system.\r\n *\r\n * You can still observe a getter manually according to this method:\r\n *\r\n * `o = {get p(){...}}`\r\n * Uses `observeGetting(o, 'p')` instead of `o.p`.\r\n *\r\n * @param object The source object to get property at.\r\n * @param key The property key in object.\r\n * @returns Value of `object[key]`.\r\n */\r\nfunction observeGetting(object, key) {\r\n    let descriptor = getPropertyDescriptor(object, key);\r\n    if (descriptor && descriptor.get) {\r\n        return descriptor.get.call(object);\r\n    }\r\n    else {\r\n        return object[key];\r\n    }\r\n}\r\nexports.observeGetting = observeGetting;\r\nfunction getPropertyDescriptor(object, property) {\r\n    let proto = object;\r\n    do {\r\n        let descriptor = Object.getOwnPropertyDescriptor(proto, property);\r\n        if (descriptor) {\r\n            return descriptor;\r\n        }\r\n        else {\r\n            proto = Object.getPrototypeOf(proto);\r\n        }\r\n    } while (proto);\r\n    return null;\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.observePlainObjectTarget = void 0;\r\nconst dependency_1 = require(\"./dependency\");\r\nconst observe_1 = require(\"./observe\");\r\nconst target_proxy_1 = require(\"./target-proxy\");\r\nfunction observePlainObjectTarget(object) {\r\n    let proxy = new Proxy(object, proxyHandler);\r\n    target_proxy_1.addTargetAndProxy(object, proxy);\r\n    return proxy;\r\n}\r\nexports.observePlainObjectTarget = observePlainObjectTarget;\r\nconst proxyHandler = {\r\n    get(object, prop) {\r\n        let value = object[prop];\r\n        dependency_1.addDependency(object);\r\n        if (value && typeof value === 'object') {\r\n            let observed = target_proxy_1.getObservedOf(value);\r\n            if (observed) {\r\n                return observed;\r\n            }\r\n            else if (dependency_1.isUpdating()) {\r\n                return observe_1.observeTarget(value);\r\n            }\r\n        }\r\n        return value;\r\n    },\r\n    set(obj, prop, value) {\r\n        obj[prop] = value;\r\n        dependency_1.notifyObjectSet(obj);\r\n        return true;\r\n    },\r\n    has(obj, prop) {\r\n        dependency_1.addDependency(obj);\r\n        return prop in obj;\r\n    },\r\n    deleteProperty(obj, prop) {\r\n        if (obj.hasOwnProperty(prop)) {\r\n            dependency_1.addDependency(obj);\r\n            return delete obj[prop];\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }\r\n};\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.observeMapOrSetTarget = void 0;\r\nconst dependency_1 = require(\"./dependency\");\r\nconst target_proxy_1 = require(\"./target-proxy\");\r\n/** Methods that will be observed. */\r\nconst WillObserveMapSetMethods = ['add', 'set', 'delete', 'clear'];\r\n/** Observe a map or a set. */\r\nfunction observeMapOrSetTarget(ms) {\r\n    let proxy = new Proxy(ms, proxyHandler);\r\n    target_proxy_1.addTargetAndProxy(ms, proxy);\r\n    return proxy;\r\n}\r\nexports.observeMapOrSetTarget = observeMapOrSetTarget;\r\n// A potential issue in observing map and set:\r\n// We may add an target item to a set, and then test if it's mapped proxy in set,\r\n// not exist so add proxy of item, this cause duplicate values exist in a set.\r\n// We will fix this when we indeed meet.\r\nconst proxyHandler = {\r\n    get(ms, prop) {\r\n        let value = ms[prop];\r\n        let type = typeof value;\r\n        if (!ms.hasOwnProperty(prop) && type === 'function') {\r\n            // `bind` is required, directly passs a proxy as this to native Set or Map methods will cause an error.\r\n            value = value.bind(ms);\r\n            dependency_1.addDependency(ms);\r\n            if (WillObserveMapSetMethods.includes(prop)) {\r\n                dependency_1.notifyObjectSet(ms);\r\n            }\r\n        }\r\n        return value;\r\n    }\r\n};\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.observeTarget = exports.observe = void 0;\r\nconst observe_object_1 = require(\"./observe-object\");\r\nconst observe_array_1 = require(\"./observe-array\");\r\nconst observe_set_or_map_1 = require(\"./observe-set-or-map\");\r\nconst target_proxy_1 = require(\"./target-proxy\");\r\n/** Original `toString` method of object. */\r\nconst originalToString = Object.prototype.toString;\r\n/**\r\n * Begin to track property changes of `value`, if use `value` during a updating of a component or watcher,\r\n * Then the property changes of returned observed object will trigger the component or watcher to be updated.\r\n *\r\n * Note that it returns a proxy, it can be used just like original object,\r\n * but it's not absolutly equals with original value, and comparing with `===` will return `false`.\r\n * So it may cause some issues if you cached the original object and compare it with observed one.\r\n *\r\n * Normally you don't need to call this method, properties of components will be observed automatically.\r\n * But once an object was observed, it can't be revoked.\r\n *\r\n * @param value The object to be observed, it can also an observed object, will not observe it for twice.\r\n * @returns The observed object, it's properties changes will be watched.\r\n */\r\nfunction observe(value) {\r\n    if (value && typeof value === 'object') {\r\n        let proxy = target_proxy_1.getObservedOf(value);\r\n        if (proxy) {\r\n            return proxy;\r\n        }\r\n        return observeTarget(value);\r\n    }\r\n    else {\r\n        return value;\r\n    }\r\n}\r\nexports.observe = observe;\r\n/** Observe an unobserved target object. */\r\nfunction observeTarget(obj) {\r\n    let str = originalToString.call(obj);\r\n    if (str === '[object Array]') {\r\n        return observe_array_1.observeArrayTarget(obj);\r\n    }\r\n    if (str === '[object Object]') {\r\n        return observe_object_1.observePlainObjectTarget(obj);\r\n    }\r\n    if (str === '[object Set]' || str === '[object Map]') {\r\n        return observe_set_or_map_1.observeMapOrSetTarget(obj);\r\n    }\r\n    return obj;\r\n}\r\nexports.observeTarget = observeTarget;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.addTargetAndProxy = exports.getObservedOf = exports.ToProxyMap = void 0;\r\n/** Caches `target -> proxy` and `proxy -> proxy` */\r\nexports.ToProxyMap = new WeakMap();\r\n/** Returns observed object from target, or returns itself if is an observed object already. */\r\nfunction getObservedOf(target) {\r\n    return exports.ToProxyMap.get(target);\r\n}\r\nexports.getObservedOf = getObservedOf;\r\n/** Add one target-proxy map. */\r\nfunction addTargetAndProxy(target, proxy) {\r\n    exports.ToProxyMap.set(target, proxy);\r\n    exports.ToProxyMap.set(proxy, proxy);\r\n}\r\nexports.addTargetAndProxy = addTargetAndProxy;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.UpdatableQueue = exports.UpdatableUpdateOrder = void 0;\r\nconst mini_heap_1 = require(\"../../helpers/mini-heap\");\r\nvar UpdatableUpdateOrder;\r\n(function (UpdatableUpdateOrder) {\r\n    /** Update firstly. */\r\n    UpdatableUpdateOrder[UpdatableUpdateOrder[\"Watcher\"] = 0] = \"Watcher\";\r\n    /** Update in second order. */\r\n    UpdatableUpdateOrder[UpdatableUpdateOrder[\"Component\"] = 1] = \"Component\";\r\n    /** Update directive like `repeat` or `liveRepeat`. */\r\n    UpdatableUpdateOrder[UpdatableUpdateOrder[\"Directive\"] = 2] = \"Directive\";\r\n    /** Update at last. */\r\n    UpdatableUpdateOrder[UpdatableUpdateOrder[\"Otherwise\"] = 3] = \"Otherwise\";\r\n})(UpdatableUpdateOrder = exports.UpdatableUpdateOrder || (exports.UpdatableUpdateOrder = {}));\r\n/** Caches updatable items, get then in the order of `context, order`. */\r\nclass UpdatableQueue {\r\n    constructor() {\r\n        this.set = new Set();\r\n        this.heap = new mini_heap_1.MiniHeap((a, b) => {\r\n            if (!a.context) {\r\n                return -1;\r\n            }\r\n            else if (!b.context) {\r\n                return 1;\r\n            }\r\n            else if (a.context !== b.context) {\r\n                return a.context.el.compareDocumentPosition(b.context.el) & a.context.el.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;\r\n            }\r\n            else {\r\n                return a.order - b.order;\r\n            }\r\n        });\r\n    }\r\n    isEmpty() {\r\n        return this.heap.isEmpty();\r\n    }\r\n    has(upt) {\r\n        return this.set.has(upt);\r\n    }\r\n    add(updatable, context, order) {\r\n        this.heap.add({\r\n            updatable,\r\n            context,\r\n            order,\r\n        });\r\n        this.set.add(updatable);\r\n    }\r\n    shift() {\r\n        let o = this.heap.removeHead();\r\n        let upt = o.updatable;\r\n        this.set.delete(upt);\r\n        return o === null || o === void 0 ? void 0 : o.updatable;\r\n    }\r\n    clear() {\r\n        this.set = new Set();\r\n        this.heap.clear();\r\n    }\r\n}\r\nexports.UpdatableQueue = UpdatableQueue;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.UpdatableValidator = void 0;\r\nconst component_1 = require(\"../../component\");\r\nconst watcher_1 = require(\"../../watchers/watcher\");\r\n/** Validate update times for updatable. */\r\nclass UpdatableValidator {\r\n    constructor() {\r\n        /** Cache the updated time of watchers and components. */\r\n        this.map = new Map();\r\n    }\r\n    /** Warn if component updated for many times. */\r\n    validate(upt) {\r\n        // We currently just check the count of updating times, if exceed 3 then warn.\r\n        // \r\n        // A better way should be analysising dependency tree:\r\n        //     Get current watcher referenced objects,\r\n        //     then get their referenced watchers,\r\n        //     then check if current watcher in it.\r\n        let updatedTimes = this.map.get(upt) || 0;\r\n        this.map.set(upt, updatedTimes + 1);\r\n        if (updatedTimes > 3) {\r\n            if (upt instanceof component_1.Component) {\r\n                console.warn(upt, `may change values in the render function and cause infinite updating!`);\r\n            }\r\n            else if (upt instanceof watcher_1.Watcher) {\r\n                console.warn(upt, `may change values in the watcher callback and cause infinite updating!`);\r\n            }\r\n            else {\r\n                console.warn(upt, `may change values in callback and cause infinite updating!`);\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    clear() {\r\n        this.map = new Map();\r\n    }\r\n}\r\nexports.UpdatableValidator = UpdatableValidator;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar queue_1 = require(\"./queue\");\r\nObject.defineProperty(exports, \"enqueueUpdatableInOrder\", { enumerable: true, get: function () { return queue_1.enqueueUpdatableInOrder; } });\r\nObject.defineProperty(exports, \"onRenderComplete\", { enumerable: true, get: function () { return queue_1.onRenderComplete; } });\r\nObject.defineProperty(exports, \"untilRenderComplete\", { enumerable: true, get: function () { return queue_1.untilRenderComplete; } });\r\nvar updatable_queue_1 = require(\"./helpers/updatable-queue\");\r\nObject.defineProperty(exports, \"UpdatableUpdateOrder\", { enumerable: true, get: function () { return updatable_queue_1.UpdatableUpdateOrder; } });\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.untilRenderComplete = exports.onRenderComplete = exports.enqueueUpdatableInOrder = void 0;\r\nconst updatable_queue_1 = require(\"./helpers/updatable-queue\");\r\nconst updatable_validator_1 = require(\"./helpers/updatable-validator\");\r\n/*\r\nThere is a hard problem must be considered in advance:\r\nWhether we should update watchers or components firstly?\r\n\r\nWe may found update parent component,\r\nwill cause child watchers get changes, and get update.\r\n\r\nSo the best way is:\r\n  Update parent watchers.\r\n  Update parent components.\r\n  Update parent miscs, like directives inner watchers.\r\n  Update child watchers.\r\n  Update child components.\r\n  ...\r\n*/\r\n/**\r\n * Indicates what we are updating.\r\n * Updating at a stage may cause new items added into following stages.\r\n */\r\nvar UpdatingStage;\r\n(function (UpdatingStage) {\r\n    /** No updata tasks. */\r\n    UpdatingStage[UpdatingStage[\"NotStarted\"] = 0] = \"NotStarted\";\r\n    /** Will update in next animation frame. */\r\n    UpdatingStage[UpdatingStage[\"Prepended\"] = 1] = \"Prepended\";\r\n    /** Are updating. */\r\n    UpdatingStage[UpdatingStage[\"Updating\"] = 2] = \"Updating\";\r\n})(UpdatingStage || (UpdatingStage = {}));\r\n/** Caches any updatable. */\r\nconst queue = new updatable_queue_1.UpdatableQueue();\r\n/** To validate updatable. */\r\nconst validator = new updatable_validator_1.UpdatableValidator();\r\n/** Callbacks wait to be called after all the things update. */\r\nlet renderCompleteCallbacks = [];\r\n/** What's updating right now. */\r\nlet updatingStage = UpdatingStage.NotStarted;\r\n/**\r\n * When a component, a watcher, or any other updatable things should enqueue to update.\r\n * Updatable wil be sort by `context, order`, and then called `__updateImmediately` one by one.\r\n */\r\nfunction enqueueUpdatableInOrder(upt, context, order) {\r\n    if (queue.has(upt)) {\r\n        return;\r\n    }\r\n    if (!validator.validate(upt)) {\r\n        return;\r\n    }\r\n    queue.add(upt, context, order);\r\n    enqueueUpdateIfNot();\r\n}\r\nexports.enqueueUpdatableInOrder = enqueueUpdatableInOrder;\r\n/**\r\n * Calls `callback` after all the components and watchers updated and rendered in next animation frame.\r\n * Called before `untilRenderComplete` but normally there is no difference.\r\n * Compare to `untilRenderComplete`, `onRenderComplete` is normally used in internal implementations.\r\n * @param callback callback to be called after render completed.\r\n */\r\nfunction onRenderComplete(callback) {\r\n    renderCompleteCallbacks.push(callback);\r\n    enqueueUpdateIfNot();\r\n}\r\nexports.onRenderComplete = onRenderComplete;\r\n/**\r\n * Returns a promise which will be resolved after all the components and watchers updated and rendered in next animation frame.\r\n * Called after `onRenderComplete` but normally there is no difference.\r\n * Compare to `onRenderComplete`, `untilRenderComplete` is normally used in app implementations.\r\n * @return A promise to be resolved after render completed.\r\n */\r\nfunction untilRenderComplete() {\r\n    return new Promise(resolve => {\r\n        onRenderComplete(resolve);\r\n    });\r\n}\r\nexports.untilRenderComplete = untilRenderComplete;\r\n/** Enqueue a update task if not have. */\r\nfunction enqueueUpdateIfNot() {\r\n    // Why doesn't use `Promise.resolve().then` to start a micro stask normally:\r\n    // When initialize a component from `connectedCallback`,\r\n    // it's child nodes especially elements of child components are not ready,\r\n    // even in the following micro task queue.\r\n    // Wait for `requestAnimationFrame` will make child nodes prepared.\r\n    // Otherwise it's very frequently to trigger updating since data are always in changing,\r\n    // Uses `requestAnimationFrame` can handle less data channing and callbaks.\r\n    // But sill need to wait for a micro tick,\r\n    // because more components will be connected in next micro task.\r\n    if (updatingStage === UpdatingStage.NotStarted) {\r\n        requestAnimationFrame(update);\r\n        updatingStage = UpdatingStage.Prepended;\r\n    }\r\n}\r\n/** Do updating. */\r\nasync function update() {\r\n    updatingStage = UpdatingStage.Updating;\r\n    while (!queue.isEmpty() || renderCompleteCallbacks.length > 0) {\r\n        // Update watchers, components and other updatable, may cause more components or watchers to be enqueued.\r\n        while (!queue.isEmpty()) {\r\n            do {\r\n                let upt = queue.shift();\r\n                try {\r\n                    upt.__updateImmediately();\r\n                }\r\n                catch (err) {\r\n                    console.error(err);\r\n                }\r\n                // Wait for more components connect.\r\n                // Otherwise it wait for removed elements got disconnected.\r\n                await Promise.resolve();\r\n            } while (!queue.isEmpty());\r\n        }\r\n        let callbackList = renderCompleteCallbacks;\r\n        renderCompleteCallbacks = [];\r\n        // Calls callbacks, all components and watchers become stable now.\r\n        for (let callback of callbackList) {\r\n            try {\r\n                callback();\r\n            }\r\n            catch (err) {\r\n                console.error(err);\r\n            }\r\n        }\r\n        await Promise.resolve();\r\n    }\r\n    // Back to start stage.\r\n    validator.clear();\r\n    updatingStage = UpdatingStage.NotStarted;\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar node_part_1 = require(\"./parts/node-part\");\r\nObject.defineProperty(exports, \"NodePart\", { enumerable: true, get: function () { return node_part_1.NodePart; } });\r\nvar template_1 = require(\"./template\");\r\nObject.defineProperty(exports, \"Template\", { enumerable: true, get: function () { return template_1.Template; } });\r\nvar template_result_1 = require(\"./template-result\");\r\nObject.defineProperty(exports, \"TemplateResult\", { enumerable: true, get: function () { return template_result_1.TemplateResult; } });\r\nObject.defineProperty(exports, \"html\", { enumerable: true, get: function () { return template_result_1.html; } });\r\nObject.defineProperty(exports, \"css\", { enumerable: true, get: function () { return template_result_1.css; } });\r\nObject.defineProperty(exports, \"svg\", { enumerable: true, get: function () { return template_result_1.svg; } });\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AttrPart = void 0;\r\n/**\r\n * To set attribute value.\r\n * `attr=${...}`\r\n */\r\nclass AttrPart {\r\n    constructor(el, name) {\r\n        this.el = el;\r\n        this.name = name;\r\n    }\r\n    update(value) {\r\n        this.setValue(value);\r\n    }\r\n    setValue(value) {\r\n        value = value === null || value === undefined ? '' : String(value);\r\n        this.el.setAttribute(this.name, value);\r\n    }\r\n}\r\nexports.AttrPart = AttrPart;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DynamicBindingPart = exports.FixedBindingPart = void 0;\r\nconst bindings_1 = require(\"../../bindings\");\r\n/**\r\n * Passes value to a specified named Binding class:\r\n *\r\n * `:class=${...}`\r\n * `:style=${...}`\r\n * `:ref=\"...\"`\r\n */\r\nclass FixedBindingPart {\r\n    constructor(el, name, context) {\r\n        this.binding = null;\r\n        this.el = el;\r\n        this.context = context;\r\n        let dotIndex = name.indexOf('.');\r\n        this.bindingName = dotIndex > -1 ? name.slice(0, dotIndex) : name;\r\n        this.bindingModifiers = dotIndex > -1 ? name.slice(dotIndex + 1).split('.') : undefined;\r\n    }\r\n    update(value) {\r\n        if (!this.binding) {\r\n            let result = new bindings_1.BindingResult(this.bindingName, value);\r\n            this.binding = bindings_1.BindingReferences.createFromResult(this.el, this.context, result, this.bindingModifiers);\r\n        }\r\n        else {\r\n            this.binding.update(value);\r\n        }\r\n    }\r\n    remove() { }\r\n}\r\nexports.FixedBindingPart = FixedBindingPart;\r\n/**\r\n * Passes a binding result to a binding module, used in:\r\n * `<tag show(...)>`, `<tag hide(...)>`, `<tag cache(...)>`.\r\n */\r\nclass DynamicBindingPart {\r\n    constructor(el, context) {\r\n        this.name = null;\r\n        this.binding = null;\r\n        this.el = el;\r\n        this.context = context;\r\n    }\r\n    update(value) {\r\n        if (value instanceof bindings_1.BindingResult) {\r\n            if (value.name === this.name) {\r\n                this.binding.update(...value.args);\r\n            }\r\n            else {\r\n                if (this.binding) {\r\n                    this.removeCurrentBinding();\r\n                }\r\n                this.name = value.name;\r\n                this.binding = bindings_1.BindingReferences.createFromResult(this.el, this.context, value);\r\n            }\r\n        }\r\n        else {\r\n            this.removeCurrentBinding();\r\n        }\r\n    }\r\n    removeCurrentBinding() {\r\n        if (this.binding) {\r\n            this.name = null;\r\n            this.binding.remove();\r\n            bindings_1.BindingReferences.removeReference(this.binding);\r\n            this.binding = null;\r\n        }\r\n    }\r\n}\r\nexports.DynamicBindingPart = DynamicBindingPart;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.EventPart = void 0;\r\nconst component_1 = require(\"../../component\");\r\nconst dom_event_1 = require(\"../../internals/dom-event\");\r\n/**\r\n * Registers a document or component event.\r\n *\r\n * `<div @click=${...}>` to register an element event.\r\n * `<com @@event=${...}>` to register a component event.\r\n */\r\nclass EventPart {\r\n    constructor(el, name, context) {\r\n        this.el = el;\r\n        this.name = name[0] === '@' ? name.slice(1) : name;\r\n        this.context = context;\r\n        this.isComEvent = el.localName.includes('-') && name[0] === '@';\r\n        this.bindListener();\r\n    }\r\n    bindListener() {\r\n        if (this.isComEvent) {\r\n            component_1.getComponentEarly(this.el, com => {\r\n                com.on(this.name, this.triggerHandler, this);\r\n            });\r\n        }\r\n        else {\r\n            dom_event_1.on(this.el, this.name, this.triggerHandler, this);\r\n        }\r\n    }\r\n    update(handler) {\r\n        // Must be a function handler, can't set as `null` to disable event.\r\n        if (typeof handler !== 'function') {\r\n            throw new Error(`Failed to register listener at \"<${this.el.localName} @${this.name}='${handler}'\">, listener is not a function!`);\r\n        }\r\n        // Doesn't update registered handler dynamically because here it may be updated frequently.\r\n        this.handler = handler;\r\n    }\r\n    triggerHandler(...args) {\r\n        // Event will be triggered with current context as scope.\r\n        this.handler.call(this.context, ...args);\r\n    }\r\n}\r\nexports.EventPart = EventPart;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MayAttrPart = void 0;\r\n/**\r\n *  Keeps the attribute if expression returns `true`, otherwise removes the attribute.\r\n *\r\n * `?checked=${...}`\r\n * `?disabled=${...}`\r\n */\r\nclass MayAttrPart {\r\n    constructor(el, name) {\r\n        this.el = el;\r\n        this.name = name;\r\n    }\r\n    update(value) {\r\n        this.setValue(value);\r\n    }\r\n    setValue(value) {\r\n        if (value) {\r\n            this.el.setAttribute(this.name, '');\r\n        }\r\n        else {\r\n            this.el.removeAttribute(this.name);\r\n        }\r\n    }\r\n}\r\nexports.MayAttrPart = MayAttrPart;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.NodePart = void 0;\r\nconst template_result_1 = require(\"../template-result\");\r\nconst template_1 = require(\"../template\");\r\nconst directives_1 = require(\"../../directives\");\r\nconst utils_1 = require(\"../../helpers/utils\");\r\n/** Contents that can be included in a `<tag>${...}<.tag>`. */\r\nvar ContentType;\r\n(function (ContentType) {\r\n    ContentType[ContentType[\"Template\"] = 0] = \"Template\";\r\n    ContentType[ContentType[\"TemplateArray\"] = 1] = \"TemplateArray\";\r\n    ContentType[ContentType[\"Directive\"] = 2] = \"Directive\";\r\n    ContentType[ContentType[\"Text\"] = 3] = \"Text\";\r\n})(ContentType || (ContentType = {}));\r\n/**\r\n * Associated with the contents betweens `<tag>${...}</tag>`.\r\n * May be a template result, text, template result array, or a directive.\r\n */\r\nclass NodePart {\r\n    constructor(anchor, context) {\r\n        this.contentType = null;\r\n        this.content = null;\r\n        this.anchor = anchor;\r\n        this.context = context;\r\n    }\r\n    update(value) {\r\n        let newContentType = this.getNewContentType(value);\r\n        if (newContentType !== this.contentType && this.contentType !== null) {\r\n            this.clearOldContent();\r\n        }\r\n        this.contentType = newContentType;\r\n        switch (newContentType) {\r\n            case ContentType.Template:\r\n                this.updateTemplate(value);\r\n                break;\r\n            case ContentType.Directive:\r\n                this.updateDirective(value);\r\n                break;\r\n            case ContentType.TemplateArray:\r\n                this.updateTemplateArray(value);\r\n                break;\r\n            case ContentType.Text:\r\n                this.updateText(value);\r\n        }\r\n    }\r\n    getNewContentType(value) {\r\n        if (value instanceof template_result_1.TemplateResult) {\r\n            return ContentType.Template;\r\n        }\r\n        else if (value instanceof directives_1.DirectiveResult) {\r\n            return ContentType.Directive;\r\n        }\r\n        else if (Array.isArray(value)) {\r\n            return ContentType.TemplateArray;\r\n        }\r\n        else {\r\n            return ContentType.Text;\r\n        }\r\n    }\r\n    clearOldContent() {\r\n        let contentType = this.contentType;\r\n        if (contentType === ContentType.Template) {\r\n            this.content.remove();\r\n        }\r\n        else if (contentType === ContentType.Directive) {\r\n            this.content.remove();\r\n            directives_1.DirectiveReferences.removeReference(this.content);\r\n        }\r\n        else if (contentType === ContentType.TemplateArray) {\r\n            for (let template of this.content) {\r\n                template.remove();\r\n            }\r\n        }\r\n        else if (contentType === ContentType.Text) {\r\n            if (this.content) {\r\n                this.content.remove();\r\n            }\r\n        }\r\n        this.content = null;\r\n    }\r\n    updateTemplate(result) {\r\n        // One issue when reusing old template - image will keep old appearance until the new image loaded.\r\n        // We can partly fix this by implementing a binding API `:src`.\r\n        let oldTemplate = this.content;\r\n        if (oldTemplate && oldTemplate.canMergeWith(result)) {\r\n            oldTemplate.merge(result);\r\n        }\r\n        else {\r\n            if (oldTemplate) {\r\n                oldTemplate.remove();\r\n            }\r\n            let newTemplate = new template_1.Template(result, this.context);\r\n            this.anchor.insert(newTemplate.extractToFragment());\r\n            this.content = newTemplate;\r\n        }\r\n    }\r\n    updateDirective(result) {\r\n        let oldDirective = this.content;\r\n        if (oldDirective && oldDirective.canMergeWith(...result.args)) {\r\n            oldDirective.merge(...result.args);\r\n        }\r\n        else {\r\n            if (oldDirective) {\r\n                oldDirective.remove();\r\n            }\r\n            this.content = directives_1.DirectiveReferences.createFromResult(this.anchor, this.context, result);\r\n        }\r\n    }\r\n    updateTemplateArray(results) {\r\n        let templates = this.content;\r\n        if (!templates) {\r\n            templates = this.content = [];\r\n        }\r\n        results = results.filter(result => result instanceof template_result_1.TemplateResult);\r\n        // Updates shared part.\r\n        for (let i = 0; i < Math.min(templates.length, results.length); i++) {\r\n            let oldTemplate = templates[i];\r\n            let result = results[i];\r\n            if (oldTemplate.canMergeWith(result)) {\r\n                oldTemplate.merge(result);\r\n            }\r\n            else {\r\n                let newTemplate = new template_1.Template(result, this.context);\r\n                oldTemplate.replaceWith(newTemplate);\r\n                templates[i] = newTemplate;\r\n            }\r\n        }\r\n        // Removes rest.\r\n        if (results.length < templates.length) {\r\n            for (let i = templates.length - 1; i >= results.length; i--) {\r\n                templates.pop().remove();\r\n            }\r\n        }\r\n        // Creates more.\r\n        else {\r\n            for (let i = templates.length; i < results.length; i++) {\r\n                let result = results[i];\r\n                let template = new template_1.Template(result, this.context);\r\n                this.anchor.insert(template.extractToFragment());\r\n                templates.push(template);\r\n            }\r\n        }\r\n    }\r\n    updateText(value) {\r\n        let textNode = this.content;\r\n        let text = value === null || value === undefined ? '' : utils_1.trim(String(value));\r\n        if (text) {\r\n            if (textNode) {\r\n                textNode.textContent = text;\r\n            }\r\n            else {\r\n                textNode = document.createTextNode(text);\r\n                this.anchor.insert(textNode);\r\n                this.content = textNode;\r\n            }\r\n        }\r\n        else {\r\n            if (textNode) {\r\n                textNode.textContent = '';\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.NodePart = NodePart;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PropertyPart = void 0;\r\nconst component_1 = require(\"../../component\");\r\n/**\r\n * Assigns property directly to current component or element.\r\n *\r\n * `<tag .property=${...}>` will assign value to normal element according to `element.property = value`.\r\n * `<custom-tag .property=${...}>` will assign value to component according to `com.property = value`.\r\n * `<custom-tag ..property=${...}>` will always assign value to element.\r\n *\r\n * But still don't suggest to assign properties to normal element using `.`, you should use element attributes.\r\n*/\r\nclass PropertyPart {\r\n    constructor(el, name, fixed) {\r\n        this.com = null;\r\n        this.el = el;\r\n        this.name = name[0] === '.' ? name.slice(1) : name;\r\n        this.isComProperty = el.localName.includes('-') && name[0] !== '.';\r\n        this.fixed = fixed;\r\n    }\r\n    update(value) {\r\n        if (this.isComProperty) {\r\n            if (this.com) {\r\n                this.updateComProperty(value);\r\n            }\r\n            else {\r\n                component_1.getComponentEarly(this.el, com => {\r\n                    this.bindCom(com);\r\n                    this.updateComProperty(value);\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            this.updateElementProperty(value);\r\n        }\r\n    }\r\n    bindCom(com) {\r\n        this.com = com;\r\n    }\r\n    updateComProperty(value) {\r\n        if (this.fixed) {\r\n            this.updateFixedComProperty(value);\r\n        }\r\n        else {\r\n            this.com[this.name] = value;\r\n        }\r\n    }\r\n    updateFixedComProperty(value) {\r\n        let com = this.com;\r\n        let type = typeof com[this.name];\r\n        if (type === 'object' && !/^\\s*(?:\\{.+?\\}|\\[.+?\\])\\s*$/.test(value)) {\r\n            type = 'string';\r\n        }\r\n        switch (type) {\r\n            case 'boolean':\r\n                com[this.name] = value === 'false' ? false : true;\r\n                break;\r\n            case 'number':\r\n                com[this.name] = Number(value);\r\n                break;\r\n            case 'object':\r\n                com[this.name] = JSON.parse(value);\r\n                break;\r\n            default:\r\n                if (type !== 'undefined') {\r\n                    com[this.name] = value;\r\n                }\r\n                else {\r\n                    console.warn(`Please makesure value of property \"${this.name}\" exist on \"<${com.el.localName} />\" when assigning fixed property!`);\r\n                }\r\n        }\r\n    }\r\n    updateElementProperty(value) {\r\n        // Required, set same value for `<input type=\"text\">` may cause cursor position reset.\r\n        if (this.el[this.name] !== value) {\r\n            this.el[this.name] = value;\r\n        }\r\n    }\r\n}\r\nexports.PropertyPart = PropertyPart;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SlotPart = void 0;\r\n/**\r\n * To fill slot tag with slot contents.\r\n * `<slot>`\r\n * `<slot name=\"...\">`\r\n */\r\nclass SlotPart {\r\n    constructor(el, name, context) {\r\n        if (!context) {\r\n            throw new ReferenceError(`A context must be provided when using \"<slot>\"!`);\r\n        }\r\n        this.el = el;\r\n        this.name = name;\r\n        this.context = context;\r\n    }\r\n    update() {\r\n        if (this.name) {\r\n            if (this.context.slots.hasOwnProperty(this.name)) {\r\n                this.el.append(...this.context.slots[this.name]);\r\n            }\r\n        }\r\n        else {\r\n            // Why not just append child nodes?\r\n            // Because the `<slot>` may be created dynamically:\r\n            //   booleanValue ? html`<div class=\"class1\"><slot /></div>` : html`<div class=\"class2\"><slot /></div>`\r\n            this.el.append(this.context.__restNodeRange.extractToFragment());\r\n        }\r\n    }\r\n}\r\nexports.SlotPart = SlotPart;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.extendsTemplateResult = void 0;\r\nconst html_attributes_parser_1 = require(\"../internals/html-attributes-parser\");\r\nconst html_token_parser_1 = require(\"../internals/html-token-parser\");\r\nconst template_result_1 = require(\"./template-result\");\r\nconst utils_1 = require(\"./utils\");\r\n/**\r\n * Caches template extends result.\r\n * Next time extending of two same shaped template will capture a cached result.\r\n */\r\nconst TemplateExtendsCache = new Map();\r\n/**\r\n * Merge root attributes and slot elements from current result to super one.\r\n * This is used for `currentResult.extends(superResult)`.\r\n *\r\n * What happens when multiple slot element `<slot name=\"...\">` with same name exists:\r\n * \t The outside most slot elements will exist, others will be removed.\r\n *\r\n * What happens when multiple rest slot anchor elements `<slot />` exists in different template:\r\n *   The outside most rest slot elements will exist too, others will be removed.\r\n */\r\nfunction extendsTemplateResult(result, superResult) {\r\n    let totalValues = [...result.values, ...superResult.values];\r\n    let string = utils_1.joinWithOrderMarkers(result.strings);\r\n    let superString = utils_1.joinWithOrderMarkers(superResult.strings, result.values.length);\r\n    let stringsAndValueIndices;\r\n    let cacheForSuper = TemplateExtendsCache.get(string);\r\n    if (cacheForSuper) {\r\n        stringsAndValueIndices = cacheForSuper.get(superString);\r\n    }\r\n    if (!stringsAndValueIndices) {\r\n        stringsAndValueIndices = parseTemplateResultForExtending(string, superString);\r\n    }\r\n    let { strings, valueIndices } = stringsAndValueIndices;\r\n    let reOrderedValues = valueIndices.map(index => totalValues[index]);\r\n    return new template_result_1.TemplateResult(result.type, strings, reOrderedValues);\r\n}\r\nexports.extendsTemplateResult = extendsTemplateResult;\r\n/** Parse a template result to strings and value indices. */\r\nfunction parseTemplateResultForExtending(string, superString) {\r\n    let tokens = html_token_parser_1.parseToHTMLTokens(string);\r\n    let { attributes, slots, restTokens } = parseToRootAttributesAndSlots(tokens);\r\n    let superTokens = wrapWithTemplateTokens(superString);\r\n    assignRootAttributes(superTokens, attributes);\r\n    assignRootSlots(superTokens, slots, restTokens);\r\n    let stringsAndValueIndices = utils_1.splitByOrderMarkers(html_token_parser_1.joinHTMLTokens(superTokens));\r\n    let cacheForSuper = TemplateExtendsCache.get(string);\r\n    if (!cacheForSuper) {\r\n        cacheForSuper = new Map();\r\n        TemplateExtendsCache.set(string, cacheForSuper);\r\n    }\r\n    cacheForSuper.set(superString, stringsAndValueIndices);\r\n    return stringsAndValueIndices;\r\n}\r\n/** Parse html token list to get attributes from root element, and get all slots. */\r\nfunction parseToRootAttributesAndSlots(tokens) {\r\n    let firstTagStartIndex = tokens.findIndex(token => token.type === html_token_parser_1.HTMLTokenType.StartTag);\r\n    let firstTagEndIndex = tokens.length - 1;\r\n    let tabCount = 0;\r\n    let firstTag = tokens[firstTagStartIndex];\r\n    let attributes = firstTag.attributes;\r\n    let slots = {};\r\n    // Text nodes already been trimmed when parsing as tokens, no need to worry rest slot contains empty text.\r\n    let restTokens = [];\r\n    for (let i = 0; i < tokens.length; i++) {\r\n        let token = tokens[i];\r\n        switch (token.type) {\r\n            case html_token_parser_1.HTMLTokenType.StartTag:\r\n                if (/slot\\s*=\\s*['\"](\\w+)/.test(token.attributes)) {\r\n                    let name = token.attributes.match(/slot\\s*=\\s*['\"](\\w+)/)[1];\r\n                    let wholeTokensBelows = outOuterNestingTokens(tokens, i);\r\n                    slots[name] = slots[name] || [];\r\n                    slots[name].push(...wholeTokensBelows);\r\n                    i--;\r\n                }\r\n                else if (!token.selfClose) {\r\n                    tabCount++;\r\n                }\r\n                break;\r\n            case html_token_parser_1.HTMLTokenType.EndTag:\r\n                tabCount--;\r\n                if (tabCount === 0) {\r\n                    firstTagEndIndex = i + 1;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    if (firstTagEndIndex - firstTagStartIndex > 2) {\r\n        restTokens = tokens.slice(firstTagStartIndex + 1, firstTagEndIndex - 1);\r\n    }\r\n    return { attributes, slots, restTokens };\r\n}\r\n/** Add a `<template> to wrap current content if don't have. */\r\nfunction wrapWithTemplateTokens(string) {\r\n    let tokens = html_token_parser_1.parseToHTMLTokens(string);\r\n    let firstToken = tokens[0];\r\n    if (!firstToken || firstToken.type !== html_token_parser_1.HTMLTokenType.StartTag || firstToken.tagName !== 'template') {\r\n        tokens.unshift({\r\n            type: html_token_parser_1.HTMLTokenType.StartTag,\r\n            tagName: 'template',\r\n            attributes: '',\r\n        });\r\n        tokens.push({\r\n            type: html_token_parser_1.HTMLTokenType.EndTag,\r\n            tagName: 'template',\r\n        });\r\n    }\r\n    return tokens;\r\n}\r\n/** Assign attributes of root element to super tokens */\r\nfunction assignRootAttributes(superTokens, assignAttributes) {\r\n    superTokens[0].attributes = html_attributes_parser_1.joinHTMLAttributes(superTokens[0].attributes, assignAttributes);\r\n}\r\n/** Assign attributes of root element and all slots to a html token list. */\r\nfunction assignRootSlots(tokens, slots, restTokens) {\r\n    if (Object.keys(slots).length > 0 || restTokens.length > 0) {\r\n        for (let i = 0; i < tokens.length; i++) {\r\n            let token = tokens[i];\r\n            switch (token.type) {\r\n                case html_token_parser_1.HTMLTokenType.StartTag:\r\n                    if (token.tagName === 'slot') {\r\n                        let nameMatch = token.attributes.match(/name\\s*=\\s*['\"](\\w+)/);\r\n                        let name = nameMatch ? nameMatch[1] : null;\r\n                        if (name) {\r\n                            if (slots[name]) {\r\n                                let tokenPieces = slots[name];\r\n                                // Keep `<slot name=\"\">` so it may be overwrited by outers.\r\n                                outInnerNestingTokens(tokens, i);\r\n                                tokens.splice(i + 1, 0, ...tokenPieces);\r\n                                i += tokenPieces.length;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Removes `<slot />` so different levels of rest contents will be merged.\r\n                            if (restTokens.length) {\r\n                                outOuterNestingTokens(tokens, i);\r\n                                tokens.splice(i, 0, ...restTokens);\r\n                                i += restTokens.length;\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n/** Removes all inner tokens and current token in nesting pair. */\r\nfunction outOuterNestingTokens(tokens, startTagIndex) {\r\n    return tokens.splice(startTagIndex, findEndTagIndex(tokens, startTagIndex) + 1 - startTagIndex);\r\n}\r\n/** Removes all inner tokens in nesting pair. */\r\nfunction outInnerNestingTokens(tokens, startTagIndex) {\r\n    return tokens.splice(startTagIndex + 1, findEndTagIndex(tokens, startTagIndex) - 1 - startTagIndex);\r\n}\r\n/** Find the index of end tag that as end of current tag. */\r\nfunction findEndTagIndex(tokens, startTagIndex) {\r\n    let tabCount = 1;\r\n    for (let i = startTagIndex + 1; i < tokens.length; i++) {\r\n        let token = tokens[i];\r\n        switch (token.type) {\r\n            case html_token_parser_1.HTMLTokenType.StartTag:\r\n                if (!token.selfClose) {\r\n                    tabCount++;\r\n                }\r\n                break;\r\n            case html_token_parser_1.HTMLTokenType.EndTag:\r\n                tabCount--;\r\n                if (tabCount === 0) {\r\n                    return i;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    return tokens.length - 1;\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.parseTemplate = exports.SlotType = void 0;\r\nconst utils_1 = require(\"./utils\");\r\nconst utils_2 = require(\"../helpers/utils\");\r\nconst html_token_parser_1 = require(\"../internals/html-token-parser\");\r\nconst style_parser_1 = require(\"../internals/style-parser\");\r\n/** Type of each slot, respresent the type of `????=${...}`. */\r\nvar SlotType;\r\n(function (SlotType) {\r\n    /** `>${...}<` */\r\n    SlotType[SlotType[\"Node\"] = 0] = \"Node\";\r\n    /** `<slot>` */\r\n    SlotType[SlotType[\"SlotTag\"] = 1] = \"SlotTag\";\r\n    /** `<tag attr=...>` */\r\n    SlotType[SlotType[\"Attr\"] = 2] = \"Attr\";\r\n    /** `<tag ?attr=...>` */\r\n    SlotType[SlotType[\"MayAttr\"] = 3] = \"MayAttr\";\r\n    /** `<tag .property=...>` */\r\n    SlotType[SlotType[\"Property\"] = 4] = \"Property\";\r\n    /** `<tag @event=...>` */\r\n    SlotType[SlotType[\"Event\"] = 5] = \"Event\";\r\n    /** `<tag :class=...>` */\r\n    SlotType[SlotType[\"FixedBinging\"] = 6] = \"FixedBinging\";\r\n    /** `<tag ...>` */\r\n    SlotType[SlotType[\"DynamicBinding\"] = 7] = \"DynamicBinding\";\r\n})(SlotType = exports.SlotType || (exports.SlotType = {}));\r\n/** Caches map of `scope name -> template string -> parsed result`. */\r\nconst ParsedResultCache = new Map();\r\n/** Caches map of `scope name -> parser`. */\r\nconst ParserCache = new Map();\r\n/**\r\n * Parses template strings to a document fragment and marks all slots and their associated nodes.\r\n * Will always prepend a comment in the front to mark current template start position.\r\n */\r\nfunction parseTemplate(type, strings, el) {\r\n    let scopeName = (el === null || el === void 0 ? void 0 : el.localName) || 'global';\r\n    // Parse it.\r\n    if (type === 'html' || type === 'svg') {\r\n        let string = utils_1.joinWithOrderMarkers(strings);\r\n        let sharedResultMap = ParsedResultCache.get(scopeName);\r\n        let sharedResult = sharedResultMap === null || sharedResultMap === void 0 ? void 0 : sharedResultMap.get(string);\r\n        if (!sharedResult) {\r\n            if (!sharedResultMap) {\r\n                sharedResultMap = new Map();\r\n                ParsedResultCache.set(scopeName, sharedResultMap);\r\n            }\r\n            let parser = ParserCache.get(scopeName);\r\n            if (!parser) {\r\n                parser = new HTMLAndSVGTemplateParser(scopeName);\r\n                ParserCache.set(scopeName, parser);\r\n            }\r\n            sharedResult = parser.parse(type, string);\r\n            sharedResultMap.set(string, sharedResult);\r\n        }\r\n        return cloneParsedResult(sharedResult, el);\r\n    }\r\n    // No slots, just create.\r\n    else if (type === 'css') {\r\n        let html = `<style>${strings[0]}</style>`;\r\n        let fragment = createTemplateFromHTML(html).content;\r\n        return {\r\n            fragment,\r\n            nodes: [],\r\n            slots: [],\r\n        };\r\n    }\r\n    // No slots too.\r\n    else {\r\n        let text = strings[0];\r\n        let fragment = document.createDocumentFragment();\r\n        fragment.append(document.createTextNode(text));\r\n        return {\r\n            fragment,\r\n            nodes: [],\r\n            slots: [],\r\n        };\r\n    }\r\n}\r\nexports.parseTemplate = parseTemplate;\r\n/** Create a template element with `html` as content. */\r\nfunction createTemplateFromHTML(html) {\r\n    let template = document.createElement('template');\r\n    template.innerHTML = html;\r\n    return template;\r\n}\r\nclass HTMLAndSVGTemplateParser {\r\n    constructor(scopeName) {\r\n        this.nodeIndexs = [];\r\n        this.slots = [];\r\n        this.currentNodeIndex = 0;\r\n        this.scopeName = scopeName;\r\n        this.scopedClassNameSet = style_parser_1.getScopedClassNames(this.scopeName);\r\n    }\r\n    parse(type, string) {\r\n        let tokens = html_token_parser_1.parseToHTMLTokens(string);\r\n        let codes = '';\r\n        for (let token of tokens) {\r\n            switch (token.type) {\r\n                case html_token_parser_1.HTMLTokenType.StartTag:\r\n                    let tagName = token.tagName;\r\n                    let attributes = token.attributes;\r\n                    if (tagName === 'slot') {\r\n                        this.parseSlotTag(attributes);\r\n                    }\r\n                    // At least contains ` {flit:0}`.\r\n                    if (attributes.length >= 9) {\r\n                        attributes = this.parseAttribute(attributes);\r\n                    }\r\n                    codes += '<' + tagName + attributes + '>';\r\n                    this.currentNodeIndex++;\r\n                    break;\r\n                case html_token_parser_1.HTMLTokenType.EndTag:\r\n                    codes += `</${token.tagName}>`;\r\n                    break;\r\n                case html_token_parser_1.HTMLTokenType.Text:\r\n                    codes += this.parseText(token.text);\r\n                    break;\r\n            }\r\n        }\r\n        let firstTag = tokens.find(token => token.type === html_token_parser_1.HTMLTokenType.StartTag);\r\n        let svgWrapped = false;\r\n        if (firstTag) {\r\n            if (type === 'svg' && firstTag.tagName !== 'svg') {\r\n                codes = '<svg>' + codes + '</svg>';\r\n                svgWrapped = true;\r\n            }\r\n        }\r\n        let template = createTemplateFromHTML(codes);\r\n        let attributes = null;\r\n        if (svgWrapped) {\r\n            let svg = template.content.firstElementChild;\r\n            template.content.append(...svg.childNodes);\r\n            svg.remove();\r\n        }\r\n        // We can define some classes or styles on the top element if renders `<template class=\"...\">`.\r\n        if (firstTag && firstTag.tagName === 'template') {\r\n            template = template.content.firstElementChild;\r\n            attributes = [...template.attributes].map(({ name, value }) => ({ name, value }));\r\n        }\r\n        let result = {\r\n            template,\r\n            slots: this.slots,\r\n            rootAttributes: attributes,\r\n        };\r\n        this.clean();\r\n        return result;\r\n    }\r\n    parseSlotTag(attr) {\r\n        var _a;\r\n        let name = ((_a = attr.match(/name=['\"](.+?)['\"]/)) === null || _a === void 0 ? void 0 : _a[1]) || null;\r\n        this.slots.push({\r\n            type: SlotType.SlotTag,\r\n            name,\r\n            strings: null,\r\n            valueIndices: null,\r\n            nodeIndex: this.currentNodeIndex,\r\n        });\r\n    }\r\n    /** Parses `???=${...}`. */\r\n    parseAttribute(attr) {\r\n        const attrRE = /([.:?@\\w-]+)\\s*(?:=\\s*(\".*?\"|'.*?'|\\{flit:\\d+\\})\\s*)?|\\{flit:(\\d+)\\}\\s*/g;\r\n        return attr.replace(attrRE, (m0, name, value = '', markerId) => {\r\n            if (markerId) {\r\n                this.slots.push({\r\n                    type: SlotType.DynamicBinding,\r\n                    name: null,\r\n                    strings: null,\r\n                    valueIndices: [Number(markerId)],\r\n                    nodeIndex: this.currentNodeIndex,\r\n                });\r\n                this.nodeIndexs.push(this.currentNodeIndex);\r\n                return '';\r\n            }\r\n            let type;\r\n            let hasMarker = utils_1.containsOrderMarker(value);\r\n            switch (name[0]) {\r\n                case '.':\r\n                    type = SlotType.Property;\r\n                    break;\r\n                case ':':\r\n                    type = SlotType.FixedBinging;\r\n                    break;\r\n                case '?':\r\n                    type = SlotType.MayAttr;\r\n                    break;\r\n                case '@':\r\n                    type = SlotType.Event;\r\n                    break;\r\n            }\r\n            if (type !== undefined) {\r\n                name = name.slice(1);\r\n            }\r\n            if (type === undefined && hasMarker) {\r\n                // `class=${...}` -> `:class=${...}`, so the class value can be scoped.\r\n                if (name === 'class') {\r\n                    type = SlotType.FixedBinging;\r\n                }\r\n                else {\r\n                    type = SlotType.Attr;\r\n                }\r\n            }\r\n            if (type !== undefined) {\r\n                if (value[0] === '\\'' || value[0] === '\"') {\r\n                    value = value.slice(1, -1);\r\n                }\r\n                if (hasMarker) {\r\n                    let { strings, valueIndices } = utils_1.parseOrderMarkers(value);\r\n                    this.slots.push({\r\n                        type,\r\n                        name,\r\n                        strings,\r\n                        valueIndices,\r\n                        nodeIndex: this.currentNodeIndex,\r\n                    });\r\n                }\r\n                else {\r\n                    this.slots.push({\r\n                        type,\r\n                        name,\r\n                        strings: [value],\r\n                        valueIndices: null,\r\n                        nodeIndex: this.currentNodeIndex,\r\n                    });\r\n                }\r\n                this.nodeIndexs.push(this.currentNodeIndex);\r\n                if (type === SlotType.Attr) {\r\n                    return name + '=\"\" ';\r\n                }\r\n                else {\r\n                    return '';\r\n                }\r\n            }\r\n            else if (name === 'class' && this.scopedClassNameSet) {\r\n                value = value.replace(/[\\w-]+/g, (m0) => {\r\n                    if (this.scopedClassNameSet.has(m0)) {\r\n                        return m0 + '__' + this.scopeName;\r\n                    }\r\n                    else {\r\n                        return m0;\r\n                    }\r\n                });\r\n                return name + '=' + value;\r\n            }\r\n            return m0;\r\n        });\r\n    }\r\n    /** Parses `<tag>${...}</tag>`. */\r\n    parseText(text) {\r\n        // `text` has already been trimmed here when parsing as tokens.\r\n        if (!text) {\r\n            return text;\r\n        }\r\n        if (utils_1.containsOrderMarker(text)) {\r\n            let { strings, valueIndices } = utils_1.splitByOrderMarkers(text);\r\n            // Each hole may be a string, or a `TemplateResult`, so must unique them, but can't join them to a string.\r\n            for (let i = 1; i < strings.length; i++) {\r\n                this.slots.push({\r\n                    type: SlotType.Node,\r\n                    name: null,\r\n                    strings: null,\r\n                    valueIndices: valueIndices.slice(i - 1, i),\r\n                    nodeIndex: this.currentNodeIndex,\r\n                });\r\n                this.nodeIndexs.push(this.currentNodeIndex);\r\n                this.currentNodeIndex += 1;\r\n            }\r\n            text = strings.map(utils_2.trim).join('<!--->');\r\n        }\r\n        return text;\r\n    }\r\n    /** Clean properties for next time parsing. */\r\n    clean() {\r\n        this.slots = [];\r\n        this.nodeIndexs = [];\r\n        this.currentNodeIndex = 0;\r\n    }\r\n}\r\n/** Clone parsed result fragment and link it with node indices from the parsed result. */\r\nfunction cloneParsedResult(sharedResult, el) {\r\n    let { template, slots, rootAttributes } = sharedResult;\r\n    let fragment = template.content.cloneNode(true);\r\n    let nodes = [];\r\n    if (rootAttributes) {\r\n        if (!el) {\r\n            throw new Error('A context must be provided when rendering `<template>...`!');\r\n        }\r\n        utils_1.extendsAttributes(el, rootAttributes);\r\n    }\r\n    if (slots.length > 0) {\r\n        let nodeIndex = 0;\r\n        let slotIndex = 0;\r\n        let walker = document.createTreeWalker(fragment, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null);\r\n        let node;\r\n        let end = false;\r\n        if (rootAttributes) {\r\n            while (slotIndex < slots.length && slots[slotIndex].nodeIndex === 0) {\r\n                nodes.push(el);\r\n                slotIndex++;\r\n            }\r\n            nodeIndex = 1;\r\n        }\r\n        if (slotIndex < slots.length) {\r\n            while (node = walker.nextNode()) {\r\n                while (slots[slotIndex].nodeIndex === nodeIndex) {\r\n                    nodes.push(node);\r\n                    slotIndex++;\r\n                    if (slotIndex === slots.length) {\r\n                        end = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (end) {\r\n                    break;\r\n                }\r\n                nodeIndex++;\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        fragment,\r\n        slots,\r\n        nodes,\r\n    };\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TemplateResult = exports.css = exports.svg = exports.html = void 0;\r\nconst template_extends_1 = require(\"./template-extends\");\r\n/**\r\n * Returns a HTML template literal, can be used to render or update a component.\r\n * Use it like:\r\n * ```ts\r\n * html`...`\r\n * ```\r\n */\r\nfunction html(strings, ...values) {\r\n    return new TemplateResult('html', strings, values);\r\n}\r\nexports.html = html;\r\n/**\r\n * Returns a SVG template literal, can be used to render or update a component.\r\n * Use it like:\r\n * ```ts\r\n * svg`...`\r\n * ```\r\n */\r\nfunction svg(strings, ...values) {\r\n    return new TemplateResult('svg', strings, values);\r\n}\r\nexports.svg = svg;\r\n/**\r\n * Returns a CSS template literal, can be used as component's static style property.\r\n * Use it like:\r\n * ```ts\r\n * css`...`\r\n * ```\r\n */\r\nfunction css(strings, ...values) {\r\n    return new TemplateResult('css', strings, values);\r\n}\r\nexports.css = css;\r\n/**\r\n * Created from each html`...` or svg`...`.\r\n * Every time call `component.update` will generate a new template result,\r\n * then we will use this result to merge or replaced old one.\r\n */\r\nclass TemplateResult {\r\n    constructor(type, strings, values) {\r\n        this.type = type;\r\n        this.strings = strings;\r\n        this.values = values;\r\n    }\r\n    /**\r\n     * Join strings and values to string.\r\n     * Just for debugging.\r\n     */\r\n    toString() {\r\n        let text = this.strings[0];\r\n        for (let i = 0; i < this.strings.length - 1; i++) {\r\n            let value = this.values[i];\r\n            if (value !== null && value !== undefined) {\r\n                if (Array.isArray(value)) {\r\n                    text += value.join('');\r\n                }\r\n                else {\r\n                    text += String(value);\r\n                }\r\n            }\r\n            text += this.strings[i + 1];\r\n        }\r\n        return text;\r\n    }\r\n    /** Clone current template result and returns a new one. */\r\n    clone() {\r\n        return new TemplateResult(this.type, [...this.strings], [...this.values]);\r\n    }\r\n    /** Concat with another template result, and returns a new one. */\r\n    concat(result) {\r\n        let strings = [...this.strings];\r\n        strings[strings.length - 1] += result.strings[0];\r\n        strings.push(...result.strings.slice(1));\r\n        let values = [...this.values];\r\n        return new TemplateResult(this.type, strings, values);\r\n    }\r\n    /**\r\n     * A template result can extend another:\r\n     * \"css`...`.extends(...)\" will join them.\r\n     * \"html`...`.extends(...)\" is different, see the comments below.\r\n     *\r\n     * For `html` or `svg` template the extends will merge root attributes and slot elements into super,\r\n     * so you can reuse super rendering result and add some classes or styles and set same slots,\r\n     */\r\n    extends(superResult) {\r\n        if (this.type === 'html' || this.type === 'svg') {\r\n            return template_extends_1.extendsTemplateResult(this, superResult);\r\n        }\r\n        else {\r\n            return new TemplateResult(this.type, [...superResult.strings, ...this.strings], [...superResult.values, '', ...this.values]);\r\n        }\r\n    }\r\n}\r\nexports.TemplateResult = TemplateResult;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Template = void 0;\r\nconst node_range_1 = require(\"../internals/node-range\");\r\nconst node_anchor_1 = require(\"../internals/node-anchor\");\r\nconst template_parser_1 = require(\"./template-parser\");\r\nconst node_part_1 = require(\"./parts/node-part\");\r\nconst may_attr_part_1 = require(\"./parts/may-attr-part\");\r\nconst event_part_1 = require(\"./parts/event-part\");\r\nconst attr_part_1 = require(\"./parts/attr-part\");\r\nconst binding_part_1 = require(\"./parts/binding-part\");\r\nconst property_part_1 = require(\"./parts/property-part\");\r\nconst component_1 = require(\"../component\");\r\nconst utils_1 = require(\"./utils\");\r\nconst slot_part_1 = require(\"./parts/slot-part\");\r\n/**\r\n * Class to parse a template result returned from html`...`,\r\n * and attach everything\r\n * And can do some patches on it according to newly rendered template result.\r\n */\r\nclass Template {\r\n    /**\r\n     * Create an template from html`...` like template result and context\r\n     * @param result The template result like html`...`.\r\n     * @param context The context passed to event handlers.\r\n     */\r\n    constructor(result, context) {\r\n        var _a;\r\n        this.parts = [];\r\n        this.currentResult = result;\r\n        this.context = context;\r\n        let { fragment, nodes, slots } = template_parser_1.parseTemplate(result.type, result.strings, ((_a = this.context) === null || _a === void 0 ? void 0 : _a.el) || null);\r\n        this.range = new node_range_1.NodeRange(fragment);\r\n        this.parseParts(nodes, slots);\r\n    }\r\n    /** Parse template result and returns a fragment. */\r\n    parseParts(nodes, slots) {\r\n        let resultValues = this.currentResult.values;\r\n        if (nodes && slots) {\r\n            for (let nodeIndex = 0; nodeIndex < nodes.length; nodeIndex++) {\r\n                let node = nodes[nodeIndex];\r\n                let slot = slots[nodeIndex];\r\n                let part;\r\n                switch (slot.type) {\r\n                    case template_parser_1.SlotType.SlotTag:\r\n                        part = new slot_part_1.SlotPart(node, slot.name, this.context);\r\n                        break;\r\n                    case template_parser_1.SlotType.Node:\r\n                        part = new node_part_1.NodePart(new node_anchor_1.NodeAnchor(node, node_anchor_1.NodeAnchorType.Next), this.context);\r\n                        break;\r\n                    case template_parser_1.SlotType.MayAttr:\r\n                        part = new may_attr_part_1.MayAttrPart(node, slot.name);\r\n                        break;\r\n                    case template_parser_1.SlotType.Event:\r\n                        part = new event_part_1.EventPart(node, slot.name, this.context);\r\n                        break;\r\n                    case template_parser_1.SlotType.Attr:\r\n                        part = new attr_part_1.AttrPart(node, slot.name);\r\n                        break;\r\n                    case template_parser_1.SlotType.Property:\r\n                        part = new property_part_1.PropertyPart(node, slot.name, !slot.valueIndices);\r\n                        break;\r\n                    case template_parser_1.SlotType.FixedBinging:\r\n                        part = new binding_part_1.FixedBindingPart(node, slot.name, this.context);\r\n                        break;\r\n                    case template_parser_1.SlotType.DynamicBinding:\r\n                        part = new binding_part_1.DynamicBindingPart(node, this.context);\r\n                        break;\r\n                }\r\n                if (slot.type === template_parser_1.SlotType.SlotTag) {\r\n                    part.update();\r\n                }\r\n                else {\r\n                    let { strings, valueIndices } = slot;\r\n                    let values = (valueIndices === null || valueIndices === void 0 ? void 0 : valueIndices.map(index => resultValues[index])) || null;\r\n                    let value = utils_1.joinStringsAndValues(strings, values);\r\n                    part.update(value);\r\n                    // Only when `valueIndices` exist then value is dynamic so this part is updatable.\r\n                    if (valueIndices) {\r\n                        this.parts.push({\r\n                            part,\r\n                            strings,\r\n                            valueIndices,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /** Compare if current template result can merge with `result`. */\r\n    canMergeWith(result) {\r\n        if (this.currentResult.type !== result.type) {\r\n            return false;\r\n        }\r\n        if (this.currentResult.strings.length !== result.strings.length) {\r\n            return false;\r\n        }\r\n        for (let i = 0; i < this.currentResult.strings.length; i++) {\r\n            if (this.currentResult.strings[i] !== result.strings[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /** Merge current result with `result`. */\r\n    merge(result) {\r\n        for (let { part, strings, valueIndices } of this.parts) {\r\n            let changed = valueIndices.some(index => this.currentResult.values[index] !== result.values[index]);\r\n            if (changed) {\r\n                let values = valueIndices.map(index => result.values[index]);\r\n                let value = utils_1.joinStringsAndValues(strings, values);\r\n                part.update(value);\r\n            }\r\n        }\r\n        this.currentResult = result;\r\n    }\r\n    /**\r\n     * Initialize components inside a template and update it immediately.\r\n     * Elements are not connected but will be pre rendered.\r\n     */\r\n    preRender() {\r\n        let fragment = this.range.getCurrentFragment();\r\n        if (!fragment || !(fragment instanceof DocumentFragment)) {\r\n            throw new Error(`Can only prerender contents in a fragment!`);\r\n        }\r\n        let walker = document.createTreeWalker(fragment, NodeFilter.SHOW_ELEMENT, null);\r\n        let el;\r\n        while (el = walker.nextNode()) {\r\n            if (el instanceof HTMLElement && el.localName.includes('-')) {\r\n                let com = component_1.createComponent(el);\r\n                // Here it doesn't emit connected or created, just to pre render all the inner nodes.\r\n                // May add more inner components and pre rendering them later.\r\n                com.__updateImmediately(true);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Append all nodes into target element or selector.\r\n     * @param fragment The fragment to append.\r\n     * @param target The target element where will append to.\r\n     */\r\n    appendTo(target) {\r\n        let fragment = this.extractToFragment();\r\n        if (typeof target === 'string') {\r\n            let targetEl = document.querySelector(target);\r\n            if (targetEl) {\r\n                targetEl.append(fragment);\r\n            }\r\n        }\r\n        else if (target) {\r\n            target.append(fragment);\r\n        }\r\n    }\r\n    /**\r\n     * Extract all nodes into a fragment.\r\n     * You must insert the extracted fragment into a container soon.\r\n     * Used to get just parsed fragment, or reuse template nodes.\r\n     */\r\n    extractToFragment() {\r\n        return this.range.extractToFragment();\r\n    }\r\n    /**\r\n     * Moves all nodes out from parent container,\r\n     * and cache into a new fragment in order to use them later.\r\n     */\r\n    movesOut() {\r\n        this.range.movesOut();\r\n    }\r\n    /** Get all the nodes in the template. */\r\n    getNodes() {\r\n        return this.range.getNodes();\r\n    }\r\n    /** Get first element in template. */\r\n    getFirstElement() {\r\n        return this.range.getFirstElement();\r\n    }\r\n    /** Insert all the nodes in specified template before start node of current template. */\r\n    before(template) {\r\n        this.range.before(template.range);\r\n    }\r\n    /** Replace all the nodes in current template with the nodes of specified template. */\r\n    replaceWith(template) {\r\n        this.range.replaceWith(template.range);\r\n    }\r\n    /**\r\n     * Removes all the nodes in the template.\r\n     * Note the child template will not call `remove`.\r\n     */\r\n    remove() {\r\n        this.range.remove();\r\n    }\r\n}\r\nexports.Template = Template;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.joinStringsAndValues = exports.extendsAttributes = exports.splitByOrderMarkers = exports.parseOrderMarkers = exports.beOrderMarker = exports.containsOrderMarker = exports.joinWithOrderMarkers = void 0;\r\n/** Join template strings with `${flit:id}`, the id is the increased index of values. */\r\nfunction joinWithOrderMarkers(strings, startIndex = 0) {\r\n    let text = strings[0];\r\n    for (let i = 0; i < strings.length - 1; i++) {\r\n        text += `{flit:${i + startIndex}}`;\r\n        text += strings[i + 1];\r\n    }\r\n    return text;\r\n}\r\nexports.joinWithOrderMarkers = joinWithOrderMarkers;\r\n/** Test if string contains `${flit:id}`. */\r\nfunction containsOrderMarker(string) {\r\n    return /\\{flit:\\d+\\}/.test(string);\r\n}\r\nexports.containsOrderMarker = containsOrderMarker;\r\n/** Test if string is exactly a `${flit:id}`. */\r\nfunction beOrderMarker(string) {\r\n    return /^\\{flit:\\d+\\}$/.test(string);\r\n}\r\nexports.beOrderMarker = beOrderMarker;\r\n/**\r\n * Split string contains `${flit:id}` into strings and valueIndices.\r\n * Returned property `strings` will be `null` if whole string is exactly a marker.\r\n */\r\nfunction parseOrderMarkers(string) {\r\n    if (beOrderMarker(string)) {\r\n        return {\r\n            strings: null,\r\n            valueIndices: [Number(string.match(/^\\{flit:(\\d+)\\}$/)[1])]\r\n        };\r\n    }\r\n    else {\r\n        return splitByOrderMarkers(string);\r\n    }\r\n}\r\nexports.parseOrderMarkers = parseOrderMarkers;\r\n/** Split string contains `${flit:id}` into strings and valueIndices. */\r\nfunction splitByOrderMarkers(string) {\r\n    let re = /\\{flit:(\\d+)\\}/g;\r\n    let match;\r\n    let strings = [];\r\n    let valueIndices = [];\r\n    let lastIndex = 0;\r\n    while (match = re.exec(string)) {\r\n        strings.push(string.slice(lastIndex, match.index));\r\n        valueIndices.push(Number(match[1]));\r\n        lastIndex = re.lastIndex;\r\n    }\r\n    strings.push(string.slice(lastIndex));\r\n    return {\r\n        strings,\r\n        valueIndices,\r\n    };\r\n}\r\nexports.splitByOrderMarkers = splitByOrderMarkers;\r\n/** Extends attributes by merging class and style attributes, and setting normal attributes.  */\r\nfunction extendsAttributes(el, attributes) {\r\n    for (let { name, value } of attributes) {\r\n        if ((name === 'class' || name === 'style') && el.hasAttribute(name)) {\r\n            if (name === 'style') {\r\n                value = el.getAttribute(name) + '; ' + value;\r\n            }\r\n            else if (name === 'class') {\r\n                value = el.getAttribute(name) + ' ' + value;\r\n            }\r\n        }\r\n        el.setAttribute(name, value);\r\n    }\r\n}\r\nexports.extendsAttributes = extendsAttributes;\r\n/** Join strings and values to a string, returns `values[0]` if `strings` is null. */\r\nfunction joinStringsAndValues(strings, values) {\r\n    if (!strings) {\r\n        return values[0];\r\n    }\r\n    let text = strings[0];\r\n    for (let i = 0; i < strings.length - 1; i++) {\r\n        let value = values[i];\r\n        text += value === null || value === undefined ? '' : String(value);\r\n        text += strings[i + 1];\r\n    }\r\n    return text;\r\n}\r\nexports.joinStringsAndValues = joinStringsAndValues;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.updateAllGlobalWatchers = exports.watchUntil = exports.watchOnce = exports.watchImmediately = exports.watch = exports.GlobalWatcherGroup = void 0;\r\nconst watcher_group_1 = require(\"./watcher-group\");\r\n/** Global watcher group to watch scattered things that not belongs to a component. */\r\nexports.GlobalWatcherGroup = new watcher_group_1.WatcherGroup(null);\r\n/**\r\n * Watchs returned value of `fn` and calls `callback` with this value as parameter if the value changed.\r\n * @param fn The watched function.\r\n * @param callback Get called after returned value of `fn` may changed.\r\n */\r\nfunction watch(fn, callback) {\r\n    return exports.GlobalWatcherGroup.watch(fn, callback);\r\n}\r\nexports.watch = watch;\r\n/**\r\n * Watchs returned value of `fn` and calls `callback` with this value as parameter if the value changed.\r\n * Will call `callback` immediately.\r\n * @param fn The watched function.\r\n * @param callback Get called after returned value of `fn` may changed.\r\n */\r\nfunction watchImmediately(fn, callback) {\r\n    return exports.GlobalWatcherGroup.watchImmediately(fn, callback);\r\n}\r\nexports.watchImmediately = watchImmediately;\r\n/**\r\n * Watchs returned value of `fn` and calls `callback` with this value as parameter if the value changed.\r\n * Only calls `callback` for once.\r\n * @param fn The watched function.\r\n * @param callback Get called after returned value of `fn` may changed.\r\n */\r\nfunction watchOnce(fn, callback) {\r\n    return exports.GlobalWatcherGroup.watchOnce(fn, callback);\r\n}\r\nexports.watchOnce = watchOnce;\r\n/**\r\n * Watchs returneded values of `fn` and calls `callback` if this value becomes true like.\r\n * @param fn The watched function.\r\n * @param callback Get called after returned value of `fn` may changed.\r\n */\r\nfunction watchUntil(fn, callback) {\r\n    return exports.GlobalWatcherGroup.watchUntil(fn, callback);\r\n}\r\nexports.watchUntil = watchUntil;\r\n/**\r\n * Updates all the global watchers registered from `watch...()`.\r\n * e.g., you may call this after language changes and not automatically detected.\r\n */\r\nfunction updateAllGlobalWatchers() {\r\n    exports.GlobalWatcherGroup.update();\r\n}\r\nexports.updateAllGlobalWatchers = updateAllGlobalWatchers;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar watcher_1 = require(\"./watcher\");\r\nObject.defineProperty(exports, \"Watcher\", { enumerable: true, get: function () { return watcher_1.Watcher; } });\r\nObject.defineProperty(exports, \"LazyWatcher\", { enumerable: true, get: function () { return watcher_1.LazyWatcher; } });\r\nvar watcher_group_1 = require(\"./watcher-group\");\r\nObject.defineProperty(exports, \"WatcherGroup\", { enumerable: true, get: function () { return watcher_group_1.WatcherGroup; } });\r\n__exportStar(require(\"./globals\"), exports);\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WatcherGroup = void 0;\r\nconst watcher_1 = require(\"./watcher\");\r\n/**\r\n * Used to manage several watchers that binded to a context or as global watchers.\r\n * From this class, you can easily connect, disconnect, update all the watchers in group.\r\n */\r\nclass WatcherGroup {\r\n    constructor(context) {\r\n        /** All watchers. */\r\n        this.watchers = new Set();\r\n        /** Whether connected. */\r\n        this.connected = true;\r\n        this.context = context;\r\n    }\r\n    /** Add a watcher to current group, and keeps it's connected state same with current group. */\r\n    add(watcher) {\r\n        if (this.connected) {\r\n            watcher.connect();\r\n        }\r\n        else {\r\n            watcher.disconnect();\r\n        }\r\n        this.watchers.add(watcher);\r\n    }\r\n    /** Deleted watcher from current group, will always disconnect the watcher. */\r\n    delete(watcher) {\r\n        if (this.connected) {\r\n            watcher.disconnect();\r\n        }\r\n        this.watchers.delete(watcher);\r\n    }\r\n    /** Connect all the watchers in current group. */\r\n    connect() {\r\n        if (!this.connected) {\r\n            for (let watcher of this.watchers) {\r\n                watcher.connect();\r\n            }\r\n            this.connected = true;\r\n        }\r\n    }\r\n    /** Disonnect all the watchers in current group. */\r\n    disconnect() {\r\n        if (this.connected) {\r\n            for (let watcher of this.watchers) {\r\n                watcher.disconnect();\r\n            }\r\n            this.connected = false;\r\n        }\r\n    }\r\n    /** Update all the watchers in current group. */\r\n    update() {\r\n        if (this.watchers) {\r\n            for (let watcher of this.watchers) {\r\n                watcher.update();\r\n            }\r\n        }\r\n    }\r\n    /** Create a new watcher and add to current group. */\r\n    watch(fn, callback) {\r\n        let watcher = new watcher_1.Watcher(fn, callback, this.context);\r\n        this.add(watcher);\r\n        return () => {\r\n            this.delete(watcher);\r\n        };\r\n    }\r\n    /** Create a new watcher and add to current group, calls `callback` immediately. */\r\n    watchImmediately(fn, callback) {\r\n        let watcher = new watcher_1.Watcher(fn, callback, this.context);\r\n        callback.call(this, watcher.value, undefined);\r\n        this.add(watcher);\r\n        return () => {\r\n            this.delete(watcher);\r\n        };\r\n    }\r\n    /** Create a new watcher and add to current group, only calls `callback` for once. */\r\n    watchOnce(fn, callback) {\r\n        let wrappedCallback = (newValue, oldValue) => {\r\n            callback(newValue, oldValue);\r\n            unwatch();\r\n        };\r\n        let watcher = new watcher_1.Watcher(fn, wrappedCallback, this.context);\r\n        this.add(watcher);\r\n        let unwatch = () => {\r\n            this.delete(watcher);\r\n        };\r\n        return unwatch;\r\n    }\r\n    /** Create a new watcher and add to current group, calls `callback` only when returned value of `fn` be true like. */\r\n    watchUntil(fn, callback) {\r\n        let wrappedCallback = (newValue) => {\r\n            if (newValue) {\r\n                callback(newValue);\r\n                unwatch();\r\n            }\r\n        };\r\n        let unwatch;\r\n        let watcher = new watcher_1.Watcher(fn, wrappedCallback, this.context);\r\n        if (watcher.value) {\r\n            watcher.disconnect();\r\n            callback.call(this, watcher.value);\r\n            unwatch = () => { };\r\n        }\r\n        else {\r\n            this.add(watcher);\r\n            unwatch = () => {\r\n                this.delete(watcher);\r\n            };\r\n        }\r\n        return unwatch;\r\n    }\r\n}\r\nexports.WatcherGroup = WatcherGroup;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LazyWatcher = exports.Watcher = void 0;\r\nconst observer_1 = require(\"../observer\");\r\nconst queue_1 = require(\"../queue\");\r\nconst updatable_queue_1 = require(\"../queue/helpers/updatable-queue\");\r\n/**\r\n * A watcher watchs a function returned value and trigger callback if the value is changed.\r\n * You need to know that when callback was called, it doesn't ensure the watched datas are truly changed,\r\n * especially the returned value is an object, so you may validate it again if needed.\r\n * You can create watcher from `context.watch...` or `globalWatcherGroup.watch...`.\r\n */\r\nclass Watcher {\r\n    constructor(fn, callback, context) {\r\n        /** Whether the watcher connected. */\r\n        this.connected = true;\r\n        this.fn = fn;\r\n        this.callback = callback;\r\n        this.context = context;\r\n        this.value = this.getNewValue();\r\n    }\r\n    /** Get a new value from `fn`. */\r\n    getNewValue() {\r\n        observer_1.startUpdating(this);\r\n        let newValue = this.fn.call(null);\r\n        observer_1.endUpdating(this);\r\n        return newValue;\r\n    }\r\n    /** When detected dependencies changed, enqueue to update later. */\r\n    update() {\r\n        if (!this.connected) {\r\n            return;\r\n        }\r\n        queue_1.enqueueUpdatableInOrder(this, this.context, updatable_queue_1.UpdatableUpdateOrder.Watcher);\r\n    }\r\n    /** Update current value immediately, also keeps consitant with the same method in `Component`. */\r\n    __updateImmediately() {\r\n        // Don't update after disconnected, or the watcher will be observed and do meaningless updating.\r\n        if (!this.connected) {\r\n            return;\r\n        }\r\n        let newValue = this.getNewValue();\r\n        // Data may change, doesn't validate object.\r\n        if (newValue !== this.value || typeof newValue === 'object') {\r\n            let oldValue = this.value;\r\n            this.callback.call(null, this.value = newValue, oldValue);\r\n        }\r\n    }\r\n    /** Gives a readable info about the watcher. */\r\n    toString() {\r\n        return this.fn.toString();\r\n    }\r\n    /** Connect and update to collect new dependencies. */\r\n    connect() {\r\n        if (!this.connected) {\r\n            this.connected = true;\r\n            this.update();\r\n        }\r\n    }\r\n    /** Disconnect current watcher with it's denpendencies. */\r\n    disconnect() {\r\n        if (this.connected) {\r\n            this.connected = false;\r\n            observer_1.clearDependenciesOf(this);\r\n        }\r\n    }\r\n}\r\nexports.Watcher = Watcher;\r\n/**\r\n * Lazy watchers update later than normal watchers and components.\r\n * So data and nodes are stabled now.\r\n */\r\nclass LazyWatcher extends Watcher {\r\n    update() {\r\n        if (!this.connected) {\r\n            return;\r\n        }\r\n        queue_1.enqueueUpdatableInOrder(this, this.context, updatable_queue_1.UpdatableUpdateOrder.Otherwise);\r\n    }\r\n}\r\nexports.LazyWatcher = LazyWatcher;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst ff = require(\"@pucelle/ff\");\r\nconst flit = require(\"@pucelle/flit\");\r\nconst flitUI = require(\"../src/index\");\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst index_1 = require(\"../src/index\");\r\nwindow.ff = ff;\r\nwindow.flit = flit;\r\nwindow.flitUI = flitUI;\r\nflit_1.define('flit-preview', class extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.checkboxValue = ['2'];\r\n        this.checkboxInterminated = true;\r\n        this.switch1On = true;\r\n        this.switch2On = false;\r\n        this.tagClosed = false;\r\n        this.leftData = flit_1.observe([1, 2, 3]);\r\n        this.rightData = flit_1.observe([4, 5, 6]);\r\n    }\r\n    render() {\r\n        let { lineHeight } = index_1.theme;\r\n        return flit_1.html `\n\t\t<div class=\"wrapper\">\n\t\t\t<section class=\"theme\">\n\t\t\t\t<h2>Theme</h2>\n\n\t\t\t\t<f-row style=\"margin: 8px 0;\">\n\t\t\t\t\t<f-col .span=\"4\">Mode</f-col>\n\t\t\t\t\t<f-col .span=\"20\">\n\t\t\t\t\t\t<f-radiogroup .value=\"light\" @@change=${(name) => index_1.theme.assignTheme(name)}>\n\t\t\t\t\t\t\t<f-radio .value=\"light\" style=\"margin-right: 20px;\">Light</f-radio>\n\t\t\t\t\t\t\t<f-radio .value=\"dark\" style=\"margin-right: 20px;\">Dark</f-radio>\n\t\t\t\t\t\t</f-radiogroup>\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\n\t\t\t\t<f-row style=\"margin: 8px 0;\">\n\t\t\t\t\t<f-col .span=\"4\">Size</f-col>\n\t\t\t\t\t<f-col .span=\"20\">\n\t\t\t\t\t\t<f-radiogroup .value=\"medium\" @@change=${(name) => index_1.theme.assignTheme(name)}>\n\t\t\t\t\t\t\t<f-radio .value=\"small\" style=\"margin-right: 20px;\">Small</f-radio>\n\t\t\t\t\t\t\t<f-radio .value=\"medium\" style=\"margin-right: 20px;\">Medium</f-radio>\n\t\t\t\t\t\t\t<f-radio .value=\"large\" style=\"margin-right: 20px;\">Large</f-radio>\n\t\t\t\t\t\t\t<f-radio .value=\"touch\" style=\"margin-right: 20px;\">Touch</f-radio>\n\t\t\t\t\t\t</f-radiogroup>\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\n\t\t\t\t<f-row style=\"margin: 8px 0;\">\n\t\t\t\t\t<f-col .span=\"4\">Main color</f-col>\n\t\t\t\t\t<f-col .span=\"20\">\n\t\t\t\t\t\t<f-main-color-select style=\"width: ${lineHeight * 5}px;\" />\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\t\t\t</section>\n\n\n\t\t\t<h2>Basic Elements</h2>\n\n\t\t\t<section class=\"basic\">\n\t\t\t\t<h3>Buttons</h3>\n\t\t\t\t<f-row style=\"margin: 8px 0;\">\n\t\t\t\t\t<f-col .span=\"4\">\n\t\t\t\t\t\t<header>Primary</header>\n\t\t\t\t\t\t<button style=\"margin: 8px 0;\" primary>Button Text</button><br>\n\t\t\t\t\t\t<button style=\"margin: 8px 0;\" primary><f-icon .type=\"love\" /><span>Button Text</span></button><br>\n\t\t\t\t\t\t<button style=\"margin: 8px 0;\" primary><f-icon .type=\"love\" /></button><br>\n\t\t\t\t\t</f-col>\n\t\t\t\t\t<f-col .span=\"4\">\n\t\t\t\t\t\t<header>Normal</header>\n\t\t\t\t\t\t<button style=\"margin: 8px 0;\">Button Text</button><br>\n\t\t\t\t\t\t<button style=\"margin: 8px 0;\"><span>Button Text</span><f-icon .type=\"right\" /></button><br>\n\t\t\t\t\t\t<button style=\"margin: 8px 0;\"><f-icon .type=\"love\" /></button><br>\n\t\t\t\t\t</f-col>\n\t\t\t\t\t<f-col .span=\"4\">\n\t\t\t\t\t\t<header>Flat</header>\n\t\t\t\t\t\t<button style=\"margin: 8px 0;\" flat>Button Text</button><br>\n\t\t\t\t\t\t<button style=\"margin: 8px 0;\" flat><f-icon .type=\"love\" /><span>Button Text</span></button><br>\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\t\t\t</section>\n\n\n\t\t\t<section>\n\t\t\t\t<h3>Links</h3>\n\t\t\t\t<f-row style=\"margin: 8px 0;\">\n\t\t\t\t\t<f-col .span=\"4\">\n\t\t\t\t\t\t<header>Primary</header>\n\t\t\t\t\t\t<a href=\"javascript:void\" primary>Link Text</a>\n\t\t\t\t\t</f-col>\n\t\t\t\t\t<f-col .span=\"4\">\n\t\t\t\t\t\t<header>Normal</header>\n\t\t\t\t\t\t<a href=\"javascript:void\">Link Text</a>\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\t\t\t</section>\n\n\n\t\t\t<section>\n\t\t\t\t<h3>Labels</h3>\n\t\t\t\t<f-row style=\"margin: 8px 0;\">\n\t\t\t\t\t<f-col .span=\"4\">\n\t\t\t\t\t\t<header>Normal</header>\n\t\t\t\t\t\t<label>First Name</label>\n\t\t\t\t\t</f-col>\n\t\t\t\t\t<f-col .span=\"4\">\n\t\t\t\t\t\t<header>Required</header>\n\t\t\t\t\t\t<label required>Email</label>\n\t\t\t\t\t</f-col>\n\t\t\t\t\t<f-col .span=\"4\">\n\t\t\t\t\t\t<header>With Info</header>\n\t\t\t\t\t\t<label>\n\t\t\t\t\t\t\tLast Name\n\t\t\t\t\t\t\t<f-icon .type=\"tips\" :tooltip=\"Tips to show guide\" />\n\t\t\t\t\t\t</label>\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\t\t\t</section>\n\n\n\t\t\t<h2>Components</h2>\n\n\t\t\t<section>\n\t\t\t\t<h3>Button Group</h3>\n\n\t\t\t\t<f-buttongroup style=\"margin: 8px 0;\">\n\t\t\t\t\t<button primary>One</button>\n\t\t\t\t\t<button>Two</button>\n\t\t\t\t\t<button>Three</button>\n\t\t\t\t</f-buttongroup><br>\n\n\t\t\t\t<f-buttongroup style=\"margin: 8px 0;\">\n\t\t\t\t\t<button primary><f-icon .type=\"love\" /></button>\n\t\t\t\t\t<button><f-icon .type=\"love\" /></button>\n\t\t\t\t\t<button><f-icon .type=\"love\" /></button>\n\t\t\t\t</f-buttongroup><br>\n\t\t\t</section>\n\n\n\t\t\t<section>\n\t\t\t\t<f-row style=\"margin: 8px 0;\" .gutter=\"24\">\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<h3>Checkboxes</h3>\n\t\t\t\t\t\t<f-checkboxgroup .value=${this.checkboxValue}>\n\t\t\t\t\t\t\t<f-checkbox .value=\"1\">${this.checkboxValue.includes('1') ? 'Checked' : 'Unchecked'}</f-checkbox><br>\n\t\t\t\t\t\t\t<f-checkbox .value=\"2\">${this.checkboxValue.includes('2') ? 'Checked' : 'Unchecked'}</f-checkbox><br>\n\t\t\t\t\t\t\t<f-checkbox .value=\"3\" .indeterminate=${this.checkboxInterminated} @@change=${() => this.checkboxInterminated = false}>${this.checkboxInterminated ? 'Indeterminate' : this.checkboxValue.includes('3') ? 'Checked' : 'Unchecked'}</f-checkbox><br>\n\t\t\t\t\t\t</f-checkboxgroup>\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<h3>Radios</h3>\n\t\t\t\t\t\t<f-radiogroup .value=\"1\">\n\t\t\t\t\t\t\t<f-radio .value=\"1\">Radio 1</f-radio><br>\n\t\t\t\t\t\t\t<f-radio .value=\"2\">Radio 2</f-radio><br>\n\t\t\t\t\t\t</f-radiogroup>\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<h3>Switchs</h3>\n\t\t\t\t\t\t<f-switch style=\"margin-right: 8px;\" :model=\"switch1On\" />Switch 1 ${this.switch1On ? 'On' : 'Off'}<br>\n\t\t\t\t\t\t<f-switch style=\"margin-right: 8px;\" :model=\"switch2On\" />Switch 2 ${this.switch2On ? 'On' : 'Off'}<br>\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<h3>Tags</h3>\n\t\t\t\t\t\t<f-tag>Normal Tag</f-tag><br>\n\t\t\t\t\t\t<f-tag .closable :hide=${this.tagClosed} @@close=${() => this.tagClosed = true}>Closable Tag</f-tag><br>\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\t\t\t</section>\n\n\n\t\t\t<section>\n\t\t\t\t<h3>Inputs</h3>\n\n\t\t\t\t<f-row style=\"margin: 8px 0 16px 0;\" .gutter=\"24\">\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<label>Text Input</label><br>\n\t\t\t\t\t\t<f-input .type=\"text\" style=\"width: 100%;\" />\n\t\t\t\t\t</f-col>\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<label>With Placeholder</label><br>\n\t\t\t\t\t\t<f-input .type=\"text\" style=\"width: 100%;\" .placeholder=\"With Placeholder\" />\n\t\t\t\t\t</f-col>\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\n\t\t\t\t<f-row style=\"margin: 8px 0 16px 0;\" .gutter=\"24\">\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<label>Valid Input</label><br>\n\t\t\t\t\t\t<f-input .type=\"text\" style=\"width: 100%;\" .touched .valid=${true} .placeholder=\"Valid Input\" />\n\t\t\t\t\t</f-col>\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<label>Invalid Input</label><br>\n\t\t\t\t\t\t<f-input .type=\"text\" style=\"width: 100%;\" .touched .valid=${false} .placeholder=\"Invalid Input\" .error=\"Error Message\" />\n\t\t\t\t\t</f-col>\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<label>Error message in tooltip</label><br>\n\t\t\t\t\t\t<f-input .type=\"text\" style=\"width: 100%;\" .errorInTooltip .touched .valid=${false} .placeholder=\"Invalid Input\" .error=\"Error Message\" />\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\t\t\t</section>\n\n\n\t\t\t<section>\n\t\t\t\t<h3>Form</h3>\n\n\t\t\t\t<f-form :ref=\"form\">\n\t\t\t\t\t<f-row style=\"margin: 8px 0 24px 0;\" .gutter=\"24\">\n\t\t\t\t\t\t<f-col .span=\"12\">\n\t\t\t\t\t\t\t<label required>Name</label><br>\n\t\t\t\t\t\t\t<f-input style=\"width: 100%;\" .validator=${(value) => {\r\n            if (value.length === 0) {\r\n                return `The name field is required!`;\r\n            }\r\n            else if (value.length < 10) {\r\n                return `The name field should have at least 10 characters!`;\r\n            }\r\n        }} />\n\t\t\t\t\t\t</f-col>\n\t\t\t\t\t</f-row>\n\n\t\t\t\t\t<f-row style=\"margin: 8px 0;\" .gutter=\"24\">\n\t\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t\t<label>Country</label><br>\n\t\t\t\t\t\t\t<f-select style=\"width: 100%;\" .searchable .data=${[{ value: '1', text: 'Country 1' }, { value: '2', text: 'Country 2' }]} />\n\t\t\t\t\t\t</f-col>\n\n\t\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t\t<label>City</label><br>\n\t\t\t\t\t\t\t<f-select style=\"width: 100%;\" .searchable .data=${[{ value: '1', text: 'City 1' }, { value: '2', text: 'City 2' }]} />\n\t\t\t\t\t\t</f-col>\n\t\t\t\t\t</f-row>\n\n\t\t\t\t\t<f-row style=\"margin: 8px 0;\" .gutter=\"24\">\n\t\t\t\t\t\t<f-col .span=\"12\">\n\t\t\t\t\t\t\t<label>Address</label><br>\n\t\t\t\t\t\t\t<f-input style=\"width: 100%;\" />\n\t\t\t\t\t\t</f-col>\n\t\t\t\t\t</f-row>\n\n\t\t\t\t\t<f-row style=\"margin: 8px 0;\" .gutter=\"24\">\n\t\t\t\t\t\t<f-col .span=\"12\">\n\t\t\t\t\t\t\t<label>About</label><br>\n\t\t\t\t\t\t\t<f-textarea style=\"width: 100%;\" />\n\t\t\t\t\t\t</f-col>\n\t\t\t\t\t</f-row>\n\n\t\t\t\t\t<f-row style=\"margin: 16px 0 10px;\" .gutter=\"24\">\n\t\t\t\t\t\t<f-col .span=\"12\" style=\"text-align: right;\">\n\t\t\t\t\t\t\t<button primary @click=${() => flit_1.getComponent(this.refs.form).validate()}>Save</button>\n\t\t\t\t\t\t</f-col>\n\t\t\t\t\t</f-row>\n\t\t\t\t</f-form>\n\t\t\t</section>\n\n\n\t\t\t<section>\n\t\t\t\t<h3>Selects</h3>\n\t\t\t\t\n\t\t\t\t<f-row style=\"margin: 8px 0;\" .gutter=\"24\">\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header>Single Select</header>\n\t\t\t\t\t\t<f-select style=\"width: 100%; margin: 8px 0;\" .data=${range(1, 11).map(value => ({ value, text: 'Option ' + value }))} .value=${1}  />\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header>Multiple Select</header>\n\t\t\t\t\t\t<f-select style=\"width: 100%; margin: 8px 0;\" .multipleSelect .data=${range(1, 11).map(value => ({ value, text: 'Option ' + value }))} .value=${[1, 2]} />\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header>Searchable Select</header>\n\t\t\t\t\t\t<f-select style=\"width: 100%; margin: 8px 0;\" .searchable .data=${range(1, 11).map(value => ({ value, text: 'Option ' + value }))} .value=${1} />\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\t\t\t</section>\n\n\n\t\t\t<section>\n\t\t\t\t<h3>Search Field</h3>\n\t\t\t\t\n\t\t\t\t<f-row style=\"margin: 16px 0 16px 0;\" .gutter=\"24\">\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<f-search style=\"width: 100%; margin-bottom: 8px;\" />\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\t\t\t</section>\n\n\n\t\t\t<section>\n\t\t\t\t<h3>Progress Bars</h3>\n\t\t\t\t\n\t\t\t\t<f-row style=\"margin: 16px 0 8px 0;\" .gutter=\"24\">\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<f-progress style=\"width: 100%;\" .value=\"0\" />\n\t\t\t\t\t\t<f-progress style=\"width: 100%;\" .value=\"0.5\" />\n\t\t\t\t\t\t<f-progress style=\"width: 100%;\" .value=\"1\" />\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\t\t\t</section>\n\n\t\t\t<section>\n\t\t\t\t<h3>Sliders</h3>\n\t\t\t\t\n\t\t\t\t<f-row style=\"margin: 16px 0 8px 0;\" .gutter=\"24\">\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<f-slider style=\"width: 100%;\" .value=\"0\" />\n\t\t\t\t\t\t<f-slider style=\"height: 100px; margin-top: 20px;\" .value=\"50\" .vertical />\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\t\t\t</section>\n\n\n\t\t\t<section>\n\t\t\t\t<h3>Loaders</h3>\n\t\t\t\t\n\t\t\t\t<f-row style=\"margin: 16px 0 8px 0;\" .gutter=\"24\">\n\t\t\t\t\t<f-col .span=\"4\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">Small</header>\n\t\t\t\t\t\t<f-loader .size=\"small\" .speed=\"0.7\" />\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"4\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">Medium</header>\n\t\t\t\t\t\t<f-loader .size=\"medium\" .speed=\"0.6\" />\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"4\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">Large</header>\n\t\t\t\t\t\t<f-loader .size=\"large\" .speed=\"0.5\" />\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\t\t\t</section>\n\n\n\t\t\t<section>\n\t\t\t\t<h3>Lists</h3>\n\t\t\t\t\n\t\t\t\t<f-row style=\"margin: 16px 0 8px 0;\" .gutter=\"24\">\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">Selection type</header>\n\t\t\t\t\t\t<f-list .data=${range(1, 6).map(value => ({ value, text: 'Option ' + value }))} />\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">Single Selection</header>\n\t\t\t\t\t\t<f-list .data=${range(1, 6).map(value => ({ value, text: 'Option ' + value }))} .selectable .selected=${[2]} />\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">Multiple Selection</header>\n\t\t\t\t\t\t<f-list .data=${range(1, 6).map(value => ({ value, text: 'Option ' + value }))} .selectable .multipleSelect .selected=${[1, 2]} />\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">Navigation Type</header>\n\t\t\t\t\t\t<f-list .data=${range(1, 6).map(value => ({ value, text: 'Option ' + value }))} .type=\"navigation\" .active=${1} />\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\n\t\t\t\t<f-row style=\"margin: 32px 0 8px 0;\" .gutter=\"24\">\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">With Icon</header>\n\t\t\t\t\t\t<f-list .data=${range(1, 6).map(value => ({ value, text: 'Option ' + value, icon: 'love' }))} />\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">With Subsection</header>\n\t\t\t\t\t\t<f-list .type=\"navigation\" .data=${[\r\n            { value: 1, text: 'User A', children: [\r\n                    { value: 11, text: 'Folder 1', children: [\r\n                            { value: 111, text: 'Item 1' },\r\n                            { value: 112, text: 'Item 2' },\r\n                        ] },\r\n                    { value: 12, text: 'Folder 2', children: [\r\n                            { value: 121, text: 'Item 1' },\r\n                            { value: 122, text: 'Item 2' },\r\n                        ] }\r\n                ]\r\n            },\r\n            { value: 2, text: 'User B', opened: true, children: [\r\n                    { value: 21, text: 'Folder 1', children: [\r\n                            { value: 211, text: 'Item 1' },\r\n                            { value: 212, text: 'Item 2' },\r\n                        ] },\r\n                    { value: 22, text: 'Folder 2', children: [\r\n                            { value: 221, text: 'Item 1' },\r\n                            { value: 222, text: 'Item 2' },\r\n                        ] }\r\n                ]\r\n            },\r\n        ]} />\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\t\t\t</section>\n\n\n\t\t\t<section>\n\t\t\t\t<h3>Navigations</h3>\n\n\t\t\t\t<f-row style=\"margin: 16px 0 8px 0;\" .gutter=\"24\">\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<f-navigation\n\t\t\t\t\t\t\t.active=${111}\n\t\t\t\t\t\t\t.title=\"Navigation Menu\"\n\t\t\t\t\t\t\t.data=${[\r\n            { value: 1, text: 'User A', children: [\r\n                    { value: 11, text: 'Folder 1', children: [\r\n                            { value: 111, text: 'Item 1' },\r\n                            { value: 112, text: 'Item 2' },\r\n                        ] },\r\n                    { value: 12, text: 'Folder 2', children: [\r\n                            { value: 121, text: 'Item 1' },\r\n                            { value: 122, text: 'Item 2' },\r\n                        ] }\r\n                ]\r\n            },\r\n            { value: 2, text: 'User B', opened: true, children: [\r\n                    { value: 21, text: 'Folder 1', children: [\r\n                            { value: 211, text: 'Item 1' },\r\n                            { value: 212, text: 'Item 2' },\r\n                        ] },\r\n                    { value: 22, text: 'Folder 2', children: [\r\n                            { value: 221, text: 'Item 1' },\r\n                            { value: 222, text: 'Item 2' },\r\n                        ] }\r\n                ]\r\n            },\r\n        ]}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</f-col>\n\n\t\t\t\t</f-row>\n\n\t\t\t</section>\n\n\n\t\t\t<section>\n\t\t\t\t<h3>Popovers</h3>\n\t\t\t\t\n\t\t\t\t<f-row style=\"margin: 16px 0 8px 0;\" .gutter=\"24\">\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">Default</header>\n\t\t\t\t\t\t<button ${index_1.popup(() => flit_1.html `\n\t\t\t\t\t\t\t\t<f-popover .title=\"Popover title\">\n\t\t\t\t\t\t\t\t\tThis is Popover content.\n\t\t\t\t\t\t\t\t</f-popover>\n\t\t\t\t\t\t\t\t`, { trigger: 'click' })}>Click to Open Popover</button>\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">With Close Button</header>\n\t\t\t\t\t\t<button ${index_1.popup(() => flit_1.html `\n\t\t\t\t\t\t\t\t<f-popover .title=\"Popover title\" .closable>\n\t\t\t\t\t\t\t\t\tThis is Popover content.\n\t\t\t\t\t\t\t\t</f-popover>\n\t\t\t\t\t\t\t\t`, { trigger: 'click' })}>Click to Open Popover</button>\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">No Title</header>\n\t\t\t\t\t\t<button ${index_1.popup(() => flit_1.html `\n\t\t\t\t\t\t\t\t<f-popover>\n\t\t\t\t\t\t\t\t\tThis is Popover content.\n\t\t\t\t\t\t\t\t</f-popover>\n\t\t\t\t\t\t\t\t`, { trigger: 'click' })}>Click to Open Popover</button>\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">With actions</header>\n\t\t\t\t\t\t<button ${index_1.popup(() => flit_1.html `\n\t\t\t\t\t\t\t\t<f-popover\n\t\t\t\t\t\t\t\t\t:ref=\"popupWithActions\"\n\t\t\t\t\t\t\t\t\t.title=\"Popover title\" \n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tThis is Popover content.\n\t\t\t\t\t\t\t\t\t<button :slot=\"action\" @click=${() => flit_1.getComponent(this.refs.popupWithActions).close()}>Cancel</button>\n\t\t\t\t\t\t\t\t\t<button :slot=\"action\" primary @click=${() => flit_1.getComponent(this.refs.popupWithActions).close()}>Save</button>\n\t\t\t\t\t\t\t\t</f-popover>\n\t\t\t\t\t\t\t\t`, { trigger: 'click' })}>Click to Open Popover</button>\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\t\t\t</section>\n\n\n\t\t\t<section>\n\t\t\t\t<h3>Menus</h3>\n\t\t\t\t\n\t\t\t\t<f-row style=\"margin: 16px 0 8px 0;\" .gutter=\"24\">\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<button ${index_1.popup(() => flit_1.html `\n\t\t\t\t\t\t\t\t<f-menu>\n\t\t\t\t\t\t\t\t\t<f-list .data=${range(1, 6).map(value => ({ value, text: 'Option ' + value }))} />\n\t\t\t\t\t\t\t\t</f-menu>\n\t\t\t\t\t\t\t\t`, { trigger: 'click' })}>\n\t\t\t\t\t\t\t<span>Click to Open Menu</span>\n\t\t\t\t\t\t\t<f-icon .type=\"down\" />\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<button ${index_1.popup(() => flit_1.html `\n\t\t\t\t\t\t\t\t<f-menu .title=\"Menu title\">\n\t\t\t\t\t\t\t\t\t<f-list .data=${range(1, 6).map(value => ({ value, text: 'Option ' + value }))} .selectable .selected=${[1]} />\n\t\t\t\t\t\t\t\t</f-menu>\n\t\t\t\t\t\t\t\t`, { trigger: 'click' })}>\n\t\t\t\t\t\t\t<span>Menu with Title</span>\n\t\t\t\t\t\t\t<f-icon .type=\"down\" />\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\t\t\t</section>\n\n\n\t\t\t<section>\n\t\t\t\t<h3>Tooltips</h3>\n\n\t\t\t\t<f-row style=\"margin: 16px 0 8px 0;\" .gutter=\"24\">\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">Default</header>\n\t\t\t\t\t\t<button ${index_1.tooltip('Tooltip text', { type: 'default' })}>Hover for Tooltip</button>\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">Prompt</header>\n\t\t\t\t\t\t<button ${index_1.tooltip('Add some items to your list by clicking this button.', { type: 'prompt' })}>Add Items</button>\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\n\t\t\t\t<f-row style=\"margin: 16px 0 8px 0;\" .gutter=\"24\">\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">Error</header>\n\t\t\t\t\t\t<button primary disabled ${index_1.tooltip('You can\\'t submit, try resolve all mistakes then this tooltip will disappear.', { type: 'error' })}>Submit</button>\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\t\t\t</section>\n\n\n\t\t\t<section>\n\t\t\t\t<h3>Notifications</h3>\n\n\t\t\t\t<f-row style=\"margin: 16px 0 8px 0;\" .gutter=\"24\">\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">Info</header>\n\t\t\t\t\t\t<button @click=${() => index_1.notification.info('Info notification content', { title: 'Info Notification' })}>\n\t\t\t\t\t\t\tShow Info Notification\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">Warn</header>\n\t\t\t\t\t\t<button @click=${() => index_1.notification.warn('Warning notification content', { title: 'Warning Notification' })}>\n\t\t\t\t\t\t\tShow Warn Notification\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</f-col>\n\t\t\t\t\t\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">Error</header>\n\t\t\t\t\t\t<button @click=${() => index_1.notification.error('Error notification content', { title: 'Error Notification' })}>\n\t\t\t\t\t\t\tShow Error Notification\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">Success</header>\n\t\t\t\t\t\t<button @click=${() => index_1.notification.success('Success notification content', { title: 'Success Notification' })}>\n\t\t\t\t\t\t\tShow Success Notification\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\n\t\t\t\t<f-row style=\"margin: 32px 0 8px 0;\" .gutter=\"24\">\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">Without Title</header>\n\t\t\t\t\t\t<button @click=${() => index_1.notification.success('Success notification content', {\r\n            title: 'Success Notification',\r\n        })}>\n\t\t\t\t\t\t\tShow Notification with title\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">With List</header>\n\t\t\t\t\t\t<button @click=${() => index_1.notification.warn('Warning notification content', {\r\n            title: 'Warning Notification',\r\n            list: ['List Item 1', 'List Item 2']\r\n        })}>\n\t\t\t\t\t\t\tShow Notification with List\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">With Actions</header>\n\t\t\t\t\t\t<button @click=${() => index_1.notification.error('Error notification content', {\r\n            title: 'Error Notification',\r\n            actions: [{ text: 'Try Again' }]\r\n        })}>\n\t\t\t\t\t\t\tShow Notification with Actions\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</f-col>\n\n\t\t\t\t</f-row>\n\t\t\t</section>\n\n\n\t\t\t<section>\n\t\t\t\t<h3>Dialogs</h3>\n\n\t\t\t\t<f-row style=\"margin: 16px 0 8px 0;\" .gutter=\"24\">\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">Default</header>\n\t\t\t\t\t\t<button @click=${() => index_1.dialog.show('This is dialog message.')}>\n\t\t\t\t\t\t\tOpen Default Dialog\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">With Title</header>\n\t\t\t\t\t\t<button @click=${() => index_1.dialog.show('This is dialog message.', { title: 'Dialog Title' })}>\n\t\t\t\t\t\t\tOpen Dialog with Title\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">Confirm</header>\n\t\t\t\t\t\t<button @click=${() => index_1.dialog.confirm('Are you sure you want to delete these items?', { title: 'Dialog Title' })}>\n\t\t\t\t\t\t\tOpen Confirm Dialog\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">Prompt</header>\n\t\t\t\t\t\t<button @click=${() => index_1.dialog.prompt('Please input the name of your account:', {\r\n            title: 'Dialog Title',\r\n            placeholder: 'Name of your account',\r\n            validator: (value) => { if (!value) {\r\n                return 'Name is required';\r\n            }\r\n            else {\r\n                return null;\r\n            } }\r\n        })}>\n\t\t\t\t\t\t\tOpen Prompt Dialog\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\t\t\t\t\n\t\t\t\t<f-row style=\"margin: 32px 0 8px 0;\" .gutter=\"24\">\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">With Third action</header>\n\t\t\t\t\t\t<button @click=${() => index_1.dialog.confirm('You have unsaved data, are you sure you want to save your changes?', {\r\n            title: 'Dialog Title',\r\n            actions: [\r\n                { text: 'Don\\'t Save', third: true },\r\n                { text: 'Cancel' },\r\n                { text: 'Save', primary: true },\r\n            ]\r\n        })}>\n\t\t\t\t\t\t\tOpen Dialog with Third Action\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</f-col>\n\t\t\t\t\t\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">Customize</header>\n\t\t\t\t\t\t<button @click=${() => {\r\n            let input;\r\n            index_1.dialog.show(flit_1.html `\n\t\t\t\t\t\t\t\t\t\tPlease input the name of your account:\n\t\t\t\t\t\t\t\t\t\t<f-input style=\"margin-top: 8px; width: 100%;\"\n\t\t\t\t\t\t\t\t\t\t\t.placeholder=\"Name of your account\"\n\t\t\t\t\t\t\t\t\t\t\t.validator=${(v) => v ? '' : 'Name field is required'}\n\t\t\t\t\t\t\t\t\t\t\t.errorInTooltip\n\t\t\t\t\t\t\t\t\t\t\t:ref=${async (el) => input = await flit_1.getComponentAsync(el)}\n\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t\t<f-checkbox .checked style=\"margin-top: 8px;\">Remember Me</f-checkbox>\n\t\t\t\t\t\t\t\t\t`, {\r\n                title: 'Dialog Title',\r\n                interruptAction: () => !input.valid\r\n            });\r\n        }}>\n\t\t\t\t\t\t\tOpen Custom Dialog\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\n\t\t\t</section>\n\n\n\t\t\t<section>\n\t\t\t\t<h3>Modals</h3>\n\n\t\t\t\t<f-row style=\"margin: 16px 0 8px 0;\" .gutter=\"24\">\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">Default</header>\n\n\t\t\t\t\t\t<button @click=\"${() => {\r\n            let modal = flit_1.getRenderedAsComponent(flit_1.render(flit_1.html `\n\t\t\t\t\t\t\t\t<f-modal style=\"width: ${index_1.theme.adjust(360)}px;\" .title=\"Modal Title\">\n\t\t\t\t\t\t\t\t\tThis is modal content\n\t\t\t\t\t\t\t\t</f-modal>\n\t\t\t\t\t\t\t`));\r\n            modal.show();\r\n        }}\">\n\t\t\t\t\t\t\tOpen Modal\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</f-col>\n\n\t\t\t\t\t<f-col .span=\"6\">\n\t\t\t\t\t\t<header style=\"margin-bottom: 8px;\">With Actions</header>\n\n\t\t\t\t\t\t<button @click=\"${() => {\r\n            let modal = flit_1.getRenderedAsComponent(flit_1.render(flit_1.html `\n\t\t\t\t\t\t\t\t<f-modal style=\"width: ${index_1.theme.adjust(360)}px;\" .title=\"Modal Title\">\n\t\t\t\t\t\t\t\t\tThis is modal content\n\t\t\t\t\t\t\t\t\t<button :slot=\"action\" @click=${() => modal.hide()}>Cancel</button>\n\t\t\t\t\t\t\t\t\t<button :slot=\"action\" primary @click=${() => modal.hide()}>Save</button>\n\t\t\t\t\t\t\t\t</f-modal>\n\t\t\t\t\t\t\t`));\r\n            modal.show();\r\n        }}\">\n\t\t\t\t\t\t\tOpen Modal with Actions\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</f-col>\n\t\t\t\t</f-row>\n\n\t\t\t</section>\n\n\n\t\t\t<section>\n\t\t\t\t<h3>Table</h3>\n\n\t\t\t\t<f-table\n\t\t\t\t\t.resizable\n\t\t\t\t\t.store=${new index_1.Store({\r\n            data: range(1, 101).map(n => ({ id: n, value: Math.round(Math.random() * 100) })),\r\n            key: 'id',\r\n        })}\n\t\t\t\t\t.columns=${[\r\n            {\r\n                title: 'Index',\r\n                render: (_item, index) => {\r\n                    return index;\r\n                },\r\n            },\r\n            {\r\n                title: 'ID',\r\n                orderBy: 'id',\r\n                render: (item) => item.id,\r\n            },\r\n            {\r\n                title: 'Name',\r\n                render: (item) => `Name ${item.id}`,\r\n            },\r\n            {\r\n                title: 'Random Value',\r\n                orderBy: 'value',\r\n                render: (item) => item.value,\r\n                align: 'right',\r\n            }\r\n        ]}\n\t\t\t\t/>\n\t\t\t</section>\n\n\t\t\t\n\t\t\t<section>\n\t\t\t\t<h3>Table in Live Rendering Mode</h3>\n\n\t\t\t\t<f-table\n\t\t\t\t\tstyle=\"height: 204px;\"\n\t\t\t\t\t.resizable\n\t\t\t\t\t.live\n\t\t\t\t\t.renderCount=\"20\"\n\t\t\t\t\t.store=${new index_1.Store({\r\n            data: range(1, 1001).map(n => ({ id: n, value: Math.round(Math.random() * 100) })),\r\n            key: 'id',\r\n        })}\n\t\t\t\t\t.columns=${[\r\n            {\r\n                title: 'Index',\r\n                render: (_item, index) => {\r\n                    return index;\r\n                },\r\n            },\r\n            {\r\n                title: 'ID',\r\n                orderBy: 'id',\r\n                render: (item) => item.id,\r\n            },\r\n            {\r\n                title: 'Name',\r\n                render: (item) => `Name ${item.id}`,\r\n            },\r\n            {\r\n                title: 'Random Value',\r\n                orderBy: 'value',\r\n                render: (item) => item.value,\r\n                align: 'right',\r\n            }\r\n        ]}\n\t\t\t\t/>\n\t\t\t</section>\n\n\t\t\t\n\t\t\t<section>\n\t\t\t\t<h3>Table with Remote Data</h3>\n\n\t\t\t\t<f-table\n\t\t\t\t\t.resizable\n\t\t\t\t\t.renderCount=\"20\"\n\t\t\t\t\t.store=${new ExampleRemoteStore()}\n\t\t\t\t\t.columns=${[\r\n            {\r\n                title: 'Index',\r\n                render: (_item, index) => {\r\n                    return index;\r\n                },\r\n            },\r\n            {\r\n                title: 'ID',\r\n                orderBy: 'id',\r\n                render: (item) => { var _a; return (_a = item === null || item === void 0 ? void 0 : item.id) !== null && _a !== void 0 ? _a : '--'; },\r\n            },\r\n            {\r\n                title: 'Name',\r\n                render: (item) => item ? `Name ${item.id}` : '--',\r\n            },\r\n            {\r\n                title: 'Random Value',\r\n                orderBy: 'value',\r\n                render: (item) => { var _a; return (_a = item === null || item === void 0 ? void 0 : item.value) !== null && _a !== void 0 ? _a : '--'; },\r\n                align: 'right',\r\n            }\r\n        ]}\n\t\t\t\t/>\n\t\t\t</section>\n\n\n\t\t\t<section>\n\t\t\t\t<h3>Drag & Drop</h3>\n\n\t\t\t\t<div style=\"display: inline-flex; padding: 4px; background: ${index_1.theme.backgroundColor.toMiddle(5)}; line-height: 100px; font-size: 60px; text-align: center; height: 116px;\"\n\t\t\t\t\t${index_1.droppable((value, index) => {\r\n            ff.remove(this.leftData, value);\r\n            ff.remove(this.rightData, value);\r\n            if (index === -1) {\r\n                this.leftData.push(value);\r\n            }\r\n            else {\r\n                this.leftData.splice(index, 0, value);\r\n            }\r\n        })}\n\t\t\t\t>\n\t\t\t\t\t${flit_1.repeat(this.leftData, (data, index) => flit_1.html `\n\t\t\t\t\t\t<div style=\"width: 100px; margin: 4px;\"\n\t\t\t\t\t\t\t:style.background=${index_1.theme.backgroundColor.toMiddle(15).toString()}\n\t\t\t\t\t\t\t${index_1.draggable(data, index)}\n\t\t\t\t\t\t>${data}</div>\n\t\t\t\t\t`)}\n\t\t\t\t</div>\n\t\t\t\t<br>\n\n\t\t\t\t<div style=\"display: inline-flex; padding: 4px; margin-top: -8px; background: ${index_1.theme.backgroundColor.toMiddle(5)}; line-height: 100px; font-size: 60px; text-align: center; height: 116px;\"\n\t\t\t\t\t${index_1.droppable((value, index) => {\r\n            ff.remove(this.leftData, value);\r\n            ff.remove(this.rightData, value);\r\n            if (index === -1) {\r\n                this.rightData.push(value);\r\n            }\r\n            else {\r\n                this.rightData.splice(index, 0, value);\r\n            }\r\n        })}\n\t\t\t\t>\n\t\t\t\t\t${flit_1.repeat(this.rightData, (data, index) => flit_1.html `\n\t\t\t\t\t\t<div style=\"width: 100px; margin: 4px;\"\n\t\t\t\t\t\t\t:style.background=${index_1.theme.backgroundColor.toMiddle(15).toString()}\n\t\t\t\t\t\t\t${index_1.draggable(data, index)}\n\t\t\t\t\t\t>${data}</div>\n\t\t\t\t\t`)}\n\t\t\t\t</div>\n\t\t\t</section>\n\n\n\t\t\t<section>\n\t\t\t\t<h3>Resizer</h3>\n\n\t\t\t\t<div style=\"position: relative; display: inline-flex; justify-content: center; line-height: 100px; font-size: 14px; text-align: center; width: 200px; height: 100px;\"\n\t\t\t\t\t:style.background=${index_1.theme.backgroundColor.toMiddle(5).toString()}\n\t\t\t\t>\n\t\t\t\t\tResizer on the Right\n\t\t\t\t\t<f-resizer .position=\"right\" .min=${200} .max=${600} style=\"background: ${index_1.theme.backgroundColor.toMiddle(15)}\"></f-resizer>\n\t\t\t\t</div>\n\t\t\t\t<br>\n\t\t\t</section>\n\n\t\t</div>\n\t`;\r\n    }\r\n});\r\nflit_1.define('f-main-color-select', class extends index_1.Select {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.value = '#3a6cf6';\r\n        this.data = [\r\n            { value: '#3a6cf6', text: flit_1.html `<div style=\"color: #3a6cf6;\">Blue</div>` },\r\n            { value: '#48c7c7', text: flit_1.html `<div style=\"color: #48c7c7;\">Cyan</div>` },\r\n            { value: '#0077cf', text: flit_1.html `<div style=\"color: #0077cf;\">Darkblue</div>` },\r\n            { value: '#4eb2ea', text: flit_1.html `<div style=\"color: #4eb2ea;\">Skyblue</div>` },\r\n            { value: '#be66cc', text: flit_1.html `<div style=\"color: #be66cc;\">Purple</div>` },\r\n            { value: '#ff6666', text: flit_1.html `<div style=\"color: #ff6666;\">Red</div>` },\r\n            { value: '#ff8095', text: flit_1.html `<div style=\"color: #ff8095;\">Pink</div>` },\r\n            { value: '#d65c5c', text: flit_1.html `<div style=\"color: #d65c5c;\">Brown</div>` },\r\n            { value: '#f67d51', text: flit_1.html `<div style=\"color: #f67d51;\">Orange</div>` },\r\n            { value: '#15af78', text: flit_1.html `<div style=\"color: #15af78;\">Green</div>` },\r\n            { value: '#888888', text: flit_1.html `<div style=\"color: #888888;\">Grey</div>` },\r\n            { value: '#000000', text: flit_1.html `<div style=\"color: #000000;\">Black</div>` },\r\n        ];\r\n    }\r\n    onReady() {\r\n        super.onReady();\r\n        this.on('change', (value) => {\r\n            index_1.theme.set('mainColor', value);\r\n        });\r\n    }\r\n});\r\nfunction range(start, end) {\r\n    let data = [];\r\n    for (let i = start; i < end; i++) {\r\n        data.push(i);\r\n    }\r\n    return data;\r\n}\r\nclass ExampleRemoteStore extends index_1.RemoteStore {\r\n    constructor() {\r\n        super({\r\n            pageSize: 20,\r\n            preloadPageCount: 0,\r\n        });\r\n        this.key = 'id';\r\n    }\r\n    dataCount() {\r\n        return 1000;\r\n    }\r\n    async dataGetter(start, end) {\r\n        await ff.sleep(500);\r\n        return range(start, end).map(v => ({ id: v + 1, value: Math.round(Math.random() * 100) }));\r\n    }\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.contextmenu = exports.ContextMenuBinding = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst ff_1 = require(\"@pucelle/ff\");\r\n/**\r\n * `:contextmenu` binding pops-up a contextmenu when right click binded element.\r\n *\r\n * `:contextmenu=${() => contextmenuComponent}`\r\n */\r\nclass ContextMenuBinding {\r\n    constructor(el, context) {\r\n        this.popup = null;\r\n        this.unwatchRect = null;\r\n        this.unlockEl = null;\r\n        this.el = el;\r\n        this.context = context;\r\n        flit_1.on(this.el, 'contextmenu.prevent', this.showContextMenu, this);\r\n    }\r\n    update(renderFn) {\r\n        this.renderFn = renderFn;\r\n    }\r\n    async showContextMenu(e) {\r\n        this.renderPopup();\r\n        let popup = this.popup;\r\n        await flit_1.untilRenderComplete();\r\n        // Align and get focus.\r\n        ff_1.alignToEvent(popup.el, e);\r\n        popup.el.focus();\r\n        // Makesure mouse enter to submenu doesn't cause current contextmenu hidden.\r\n        ff_1.MouseLeave.lock(this.el, popup.el);\r\n        // Play enter transition.\r\n        new flit_1.Transition(popup.el, { name: 'fade' }).enter();\r\n        // Register events to show or hide.\r\n        flit_1.on(document, 'mousedown', this.onDocMouseDown, this);\r\n        flit_1.once(popup.el, 'click', this.hideContextMenu, this);\r\n        // Watch layout and re-render if layout changed.\r\n        this.unwatchRect = ff_1.watchLayout(this.el, 'rect', this.onElRectChanged.bind(this));\r\n    }\r\n    renderPopup() {\r\n        if (!this.popup) {\r\n            this.popup = flit_1.getRenderedAsComponent(flit_1.renderUpdatable(this.renderFn, this.context).template);\r\n        }\r\n        this.popup.applyAppendTo();\r\n    }\r\n    onDocMouseDown(e) {\r\n        let target = e.target;\r\n        // If mouse down at document but not popup.\r\n        if (this.popup && !this.popup.el.contains(target)) {\r\n            this.hideContextMenu();\r\n        }\r\n    }\r\n    hideContextMenu() {\r\n        if (this.popup) {\r\n            ff_1.MouseLeave.unlock(this.el, this.popup.el);\r\n            flit_1.off(document, 'mousedown', this.onDocMouseDown, this);\r\n            flit_1.off(this.popup.el, 'click', this.hideContextMenu, this);\r\n            new flit_1.Transition(this.popup.el, { name: 'fade' }).leave().then((finish) => {\r\n                if (finish) {\r\n                    this.onLeaveTransitionEnd();\r\n                }\r\n            });\r\n        }\r\n        // Not keep visible, may hide immediately.\r\n        if (this.unlockEl) {\r\n            this.unlockEl();\r\n            this.unlockEl = null;\r\n        }\r\n        if (this.unwatchRect) {\r\n            this.unwatchRect();\r\n            this.unwatchRect = null;\r\n        }\r\n    }\r\n    onLeaveTransitionEnd() {\r\n        if (this.popup) {\r\n            this.popup.el.remove();\r\n            this.popup = null;\r\n        }\r\n    }\r\n    onElRectChanged() {\r\n        this.hideContextMenu();\r\n    }\r\n    remove() {\r\n        flit_1.off(this.el, 'contextmenu', this.showContextMenu, this);\r\n    }\r\n}\r\nexports.ContextMenuBinding = ContextMenuBinding;\r\n/**\r\n * Pops-up a contextmenu when right click binded element.\r\n * @param renderFn Should return a `<f-contextmenu />` type template result.\r\n */\r\nexports.contextmenu = flit_1.defineBinding('contextmenu', ContextMenuBinding);\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.droppable = exports.DroppableBinding = exports.draggable = exports.DraggableBinding = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst ff_1 = require(\"@pucelle/ff\");\r\nconst theme_1 = require(\"../style/theme\");\r\nclass DraggableBinding {\r\n    constructor(el) {\r\n        /** Can drop to droppable only when name match. */\r\n        this.name = '';\r\n        /** Data can be passed to droppable. */\r\n        this.data = null;\r\n        /** Data index. */\r\n        this.index = -1;\r\n        this.el = el;\r\n        // To avoid image dragging handled be HTML5 drag & drop\r\n        this.el.setAttribute('draggable', 'false');\r\n        this.el.style.cursor = 'grab';\r\n        flit_1.on(this.el, 'mousedown', this.onMouseDown, this);\r\n        flit_1.on(this.el, 'mouseenter', this.onMouseEnter, this);\r\n    }\r\n    update(data, index, options = {}) {\r\n        this.data = data;\r\n        this.index = index;\r\n        this.name = options.name || '';\r\n    }\r\n    onMouseDown(e) {\r\n        e.preventDefault();\r\n        let isDragging = false;\r\n        let startX = e.clientX;\r\n        let startY = e.clientY;\r\n        let onMouseMove = (e) => {\r\n            if (!isDragging && (Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5)) {\r\n                manager.startDragging(this);\r\n                isDragging = true;\r\n            }\r\n            if (isDragging) {\r\n                let moveX = e.clientX - startX;\r\n                let moveY = e.clientY - startY;\r\n                manager.translateDraggingElement(moveX, moveY);\r\n            }\r\n        };\r\n        let onMouseUp = async () => {\r\n            flit_1.off(document, 'mousemove', onMouseMove);\r\n            if (isDragging) {\r\n                manager.endDragging();\r\n            }\r\n        };\r\n        flit_1.on(document, 'mousemove', onMouseMove);\r\n        flit_1.once(document, 'mouseup', onMouseUp);\r\n    }\r\n    onMouseEnter() {\r\n        manager.enterDraggable(this);\r\n    }\r\n    remove() {\r\n        flit_1.off(this.el, 'mousedown', this.onMouseDown, this);\r\n        flit_1.off(this.el, 'mouseenter', this.onMouseEnter, this);\r\n    }\r\n}\r\nexports.DraggableBinding = DraggableBinding;\r\n/**\r\n * Make current element draggable.\r\n * @param data Data can be passed to same name droppable.\r\n * @param index Data index.\r\n * @param options Draggable options.\r\n */\r\nexports.draggable = flit_1.defineBinding('draggable', DraggableBinding);\r\nclass DroppableBinding {\r\n    constructor(el) {\r\n        /** Allows draggable drop only when name match. */\r\n        this.name = '';\r\n        this.onenter = null;\r\n        this.onleave = null;\r\n        this.el = el;\r\n        flit_1.on(this.el, 'mouseenter', this.onMouseEnter, this);\r\n    }\r\n    update(ondrop, options = {}) {\r\n        this.ondrop = ondrop;\r\n        this.name = options.name || '';\r\n        this.onenter = options.onenter || null;\r\n        this.onleave = options.onleave || null;\r\n    }\r\n    onMouseEnter() {\r\n        manager.enterDroppable(this);\r\n        flit_1.once(this.el, 'mouseleave', this.onMouseLeave, this);\r\n    }\r\n    /** Triggers dragging element enter current droppable. */\r\n    emitEnter(dragging) {\r\n        if (this.onenter) {\r\n            this.onenter(dragging.data, dragging.index);\r\n        }\r\n    }\r\n    onMouseLeave() {\r\n        manager.leaveDroppable(this);\r\n    }\r\n    /** Triggers dragging element leave current droppable. */\r\n    emitLeave(dragging) {\r\n        if (this.onleave) {\r\n            this.onleave(dragging.data, dragging.index);\r\n        }\r\n    }\r\n    /** Triggers dragging element drop to current droppable. */\r\n    emitDrop(dragging, index) {\r\n        if (this.ondrop) {\r\n            this.ondrop(dragging.data, index);\r\n        }\r\n    }\r\n    remove() {\r\n        flit_1.off(this.el, 'mouseenter', this.onMouseEnter, this);\r\n    }\r\n}\r\nexports.DroppableBinding = DroppableBinding;\r\n/**\r\n * Make current element droppable.\r\n * @param data Data can be passed to same name droppable.\r\n * @param index Data index.\r\n * @param options Droppable options.\r\n */\r\nexports.droppable = flit_1.defineBinding('droppable', DroppableBinding);\r\n/**\r\n * Global manager to relate current dragging and it's droppable.\r\n *   When start dragging, check it's related drop area.\r\n *   When dragging element enters another draggable element, relate them and adjust position using `mover`.\r\n *   When dragging element enters one drop area, give additional space for it.\r\n *   When dragging element leaves one drop area, remove space that belongs to it.\r\n */\r\nclass DragDropRelationshipManager {\r\n    constructor() {\r\n        this.dragging = null;\r\n        this.mover = null;\r\n        /**\r\n         * May mouse enter in several drop areas, and start dragging,\r\n         * then we need to check which drop area should trigger enter.\r\n         */\r\n        this.enterDrops = new Set();\r\n        /** Current drop area. */\r\n        this.activeDropArea = null;\r\n    }\r\n    /** When start dragging a draggable. */\r\n    startDragging(dragging) {\r\n        this.dragging = dragging;\r\n        let activeDropArea;\r\n        for (let drop of [...this.enterDrops]) {\r\n            // May element was removed.\r\n            if (!document.contains(drop.el)) {\r\n                this.enterDrops.delete(drop);\r\n            }\r\n            else if (drop.name === dragging.name) {\r\n                activeDropArea = drop;\r\n                break;\r\n            }\r\n        }\r\n        if (!activeDropArea) {\r\n            throw new Error(`Element with ':draggable' must be contained in a ':droppable' elemenet`);\r\n        }\r\n        activeDropArea.emitEnter(this.dragging);\r\n        this.activeDropArea = activeDropArea;\r\n        this.mover = new Mover(this.dragging, activeDropArea);\r\n    }\r\n    /** Translate dragging element to keep follows with mouse. */\r\n    translateDraggingElement(x, y) {\r\n        if (this.mover) {\r\n            this.mover.translateDraggingElement(x, y);\r\n        }\r\n    }\r\n    /** When dragging and enter a draggable. */\r\n    enterDraggable(drag) {\r\n        if (this.canSwapWith(drag) && this.mover) {\r\n            this.mover.onEnterDraggable(drag);\r\n        }\r\n    }\r\n    /** Whether dragging can swap with draggable. */\r\n    canSwapWith(drag) {\r\n        return this.dragging && this.dragging.name === drag.name && this.dragging !== drag;\r\n    }\r\n    /** When dragging and enter a droppable. */\r\n    enterDroppable(drop) {\r\n        this.enterDrops.add(drop);\r\n        if (this.canDropTo(drop)) {\r\n            drop.emitEnter(this.dragging);\r\n            this.activeDropArea = drop;\r\n            this.mover.onEnterDroppable(drop);\r\n        }\r\n    }\r\n    /** Whether dragging can drop to a droppable. */\r\n    canDropTo(droppable) {\r\n        return this.dragging && this.dragging.name === droppable.name;\r\n    }\r\n    /** When dragging and leave a droppable. */\r\n    leaveDroppable(drop) {\r\n        this.enterDrops.delete(drop);\r\n        if (this.activeDropArea === drop) {\r\n            drop.emitLeave(this.dragging);\r\n            this.activeDropArea = null;\r\n            this.mover.onLeaveDroppable(drop);\r\n        }\r\n    }\r\n    /** When release dragging. */\r\n    endDragging() {\r\n        let mover = this.mover;\r\n        let dragging = this.dragging;\r\n        let lastActiveDroppable = this.activeDropArea;\r\n        mover.playEndDraggingAnimation().then(() => {\r\n            if (mover.willSwapElements()) {\r\n                lastActiveDroppable.emitDrop(dragging, mover.getSwapIndex());\r\n            }\r\n        });\r\n        this.dragging = null;\r\n        this.mover = null;\r\n        this.activeDropArea = null;\r\n    }\r\n}\r\nconst manager = new DragDropRelationshipManager();\r\n/**\r\n * To handle dragging movements, includes:\r\n *   When moved out of the droppable it's inside: All elements below moved up\r\n *   When moved in a new droppable: Add a padding as space to contain\r\n *   When moved between silbings: Moving items betweens them up or down, include the mouse enter sibling.\r\n *   When moved into a already moved sibling: Fallback movements that not betweens them, include the mouse enter sibling.\r\n */\r\nclass Mover {\r\n    constructor(drag, drop) {\r\n        /** Dragging element translate. */\r\n        this.translate = [0, 0];\r\n        /** Keeps orignal style text for dragging element and restore it after end dragging. */\r\n        this.startStyleText = '';\r\n        /** Elements that moves to right (never moves to left) in visually, compare to their auto layout position. */\r\n        this.movedElements = new Set();\r\n        /** Elements that were actually translated, different with `movedElements` depends on `autoLayout`. */\r\n        this.translatedElements = new Set();\r\n        /** Dragging element siblings align direction. */\r\n        this.direction = 'y';\r\n        /** Currently mouse entered draggable. */\r\n        this.dragTo = null;\r\n        /** Rect of `dragTo`. */\r\n        this.dragToRect = null;\r\n        /** Indicates the index of where to insert dragging element in the current drop area if drop right now. */\r\n        this.dragToIndex = -1;\r\n        /**\r\n         * Currently mouse entered drop area.\r\n         * Term `droppable` is a little hard to understand, so use `drop area` instead.\r\n         */\r\n        this.activeDropArea = null;\r\n        this.dragging = drag;\r\n        this.el = drag.el;\r\n        this.startDropArea = this.activeDropArea = drop;\r\n        this.rect = ff_1.getRect(this.el);\r\n        this.autoLayout = ff_1.getStyleValue(this.el, 'position') !== 'absolute';\r\n        // Didn't consider about margin collapse.\r\n        this.outerWidth = ff_1.getOuterWidth(this.el);\r\n        this.outerHeight = ff_1.getOuterHeight(this.el);\r\n        this.initializeDirection();\r\n        this.initializePlaceholder();\r\n        this.insertPlaceholder(drop, false);\r\n        this.startStyleText = this.el.style.cssText;\r\n        this.setStartDraggingStyle();\r\n    }\r\n    initializeDirection() {\r\n        if (this.el.nextElementSibling || this.el.previousElementSibling) {\r\n            let nextRect = ff_1.getRect(this.el.nextElementSibling || this.el.previousElementSibling);\r\n            if (Math.abs(nextRect.left - this.rect.left) > Math.abs(nextRect.top - this.rect.top)) {\r\n                this.direction = 'x';\r\n            }\r\n            else {\r\n                this.direction = 'y';\r\n            }\r\n        }\r\n    }\r\n    /** Set dragging style for dragging element. */\r\n    setStartDraggingStyle() {\r\n        document.body.style.cursor = 'grabbing';\r\n        document.body.style.userSelect = 'none';\r\n        this.el.style.position = 'fixed';\r\n        this.el.style.zIndex = '9999';\r\n        this.el.style.width = this.rect.width + 'px';\r\n        this.el.style.height = this.rect.height + 'px';\r\n        this.el.style.left = this.rect.left + 'px';\r\n        this.el.style.top = this.rect.top + 'px';\r\n        this.el.style.boxShadow = `0 0 ${theme_1.theme.popupShadowBlurRadius}px #888`;\r\n        this.el.style.pointerEvents = 'none';\r\n        this.el.style.opacity = '1';\r\n        this.el.style.willChange = 'transform';\r\n    }\r\n    /** Create a placeholder having same size with dragging element and insert into drop element. */\r\n    initializePlaceholder() {\r\n        this.placeholder = this.dragging.el.cloneNode();\r\n        this.placeholder.style.visibility = 'hidden';\r\n        if (this.direction === 'x') {\r\n            this.placeholder.style.width = this.rect.width + 'px';\r\n        }\r\n        else {\r\n            this.placeholder.style.height = this.rect.height + 'px';\r\n        }\r\n    }\r\n    insertPlaceholder(drop, playAnimation) {\r\n        let isDraggingInStartArea = this.startDropArea === drop;\r\n        if (isDraggingInStartArea) {\r\n            for (let el of this.getSiblingsAfter(this.el)) {\r\n                this.moveElement(el, 1, playAnimation);\r\n            }\r\n        }\r\n        drop.el.append(this.placeholder);\r\n    }\r\n    /** Get sibling elements after `fromEl`. */\r\n    getSiblingsAfter(fromEl) {\r\n        let els = [];\r\n        for (let el = fromEl.nextElementSibling; el; el = el.nextElementSibling) {\r\n            els.push(el);\r\n        }\r\n        return els;\r\n    }\r\n    /**\r\n     * Moves one element based on a move direction to giver space for dragging item.\r\n     * @param moveDirection `1` to move right, `0` to keep still.\r\n     */\r\n    moveElement(el, moveDirection, playAnimation) {\r\n        if (el === this.el) {\r\n            return;\r\n        }\r\n        let movePx = this.direction === 'x' ? this.outerWidth : this.outerHeight;\r\n        let translateDirection = moveDirection;\r\n        // in not in `autoLayout` mode, element will not affect the position of it's followed sibling elements,\r\n        // So we make `moveDirection` -= 1 to keep balance.\r\n        //   0: No translate needed.\r\n        //  -1: Translate to left to fix empty after dragging element removed.\r\n        if (!this.autoLayout && this.el.compareDocumentPosition(el) === el.DOCUMENT_POSITION_FOLLOWING) {\r\n            translateDirection -= 1;\r\n        }\r\n        let transform = translateDirection !== 0\r\n            ? `translate${this.direction.toUpperCase()}(${translateDirection * movePx}px)`\r\n            : '';\r\n        if (playAnimation) {\r\n            ff_1.animateTo(el, { transform });\r\n        }\r\n        else {\r\n            el.style.transform = transform;\r\n        }\r\n        if (moveDirection) {\r\n            this.movedElements.add(el);\r\n        }\r\n        else {\r\n            this.movedElements.delete(el);\r\n        }\r\n        if (translateDirection) {\r\n            this.translatedElements.add(el);\r\n        }\r\n        else {\r\n            this.translatedElements.delete(el);\r\n        }\r\n    }\r\n    /** When mouse enter droppable. */\r\n    onEnterDroppable(drop) {\r\n        this.insertPlaceholder(drop, true);\r\n        this.activeDropArea = drop;\r\n    }\r\n    /** When mouse enter draggable. */\r\n    onEnterDraggable(dragTo) {\r\n        if (!this.activeDropArea) {\r\n            return;\r\n        }\r\n        // May cause enter or leave events triggered acciedently if is playing animation.\r\n        if (ff_1.isPlayingAnimation(dragTo.el)) {\r\n            return;\r\n        }\r\n        let willMoveElements = new Set([dragTo.el, ...this.getSiblingsAfter(dragTo.el)]);\r\n        willMoveElements.delete(this.el);\r\n        // When the dragged into element has been moved, dragged into it again means that it's movement will be restored.\r\n        if (this.movedElements.has(dragTo.el)) {\r\n            willMoveElements.delete(dragTo.el);\r\n        }\r\n        // Keeps position.\r\n        for (let el of this.movedElements) {\r\n            if (!willMoveElements.has(el)) {\r\n                this.moveElement(el, 0, true);\r\n            }\r\n        }\r\n        // Moves right.\r\n        for (let el of willMoveElements) {\r\n            if (!this.movedElements.has(el)) {\r\n                this.moveElement(el, 1, true);\r\n            }\r\n        }\r\n        this.dragTo = dragTo;\r\n        this.dragToRect = ff_1.getRect(dragTo.el);\r\n        this.dragToIndex = this.generateDraggedToIndex(dragTo, willMoveElements.has(dragTo.el));\r\n    }\r\n    generateDraggedToIndex(drag, beenMoved) {\r\n        let isInSameDropArea = this.startDropArea === this.activeDropArea;\r\n        let index = drag.index;\r\n        // Assume we have:\r\n        //\t group 1: 1 2 3\r\n        //   group 2: 4 5 6\r\n        if (isInSameDropArea) {\r\n            // Drag 1 into 3\r\n            if (index > this.dragging.index) {\r\n                if (beenMoved) {\r\n                    // 2 [1] 3, returns index 3 - 1\r\n                    return index - 1;\r\n                }\r\n                else {\r\n                    // 2 3 [1], returns index 3\r\n                    return index;\r\n                }\r\n            }\r\n            // Drag 3 into 1\r\n            else {\r\n                if (beenMoved) {\r\n                    // [3] 1 2, returns index 1\r\n                    return index;\r\n                }\r\n                else {\r\n                    // 1 [3] 2, returns index 1 + 1\r\n                    return index + 1;\r\n                }\r\n            }\r\n        }\r\n        // Drag 1 into 4\r\n        else {\r\n            if (beenMoved) {\r\n                return index; // [1] 4 5 6, returns index of 4\r\n            }\r\n            else {\r\n                return index + 1; // 4 [1] 5 6, returns index of 4 + 1\r\n            }\r\n        }\r\n    }\r\n    /** Translate dragging element. */\r\n    translateDraggingElement(x, y) {\r\n        this.translate[0] = x;\r\n        this.translate[1] = y;\r\n        this.el.style.transform = `translate(${x}px, ${y}px)`;\r\n    }\r\n    /** Whether drag & drop completed and will swap elements. */\r\n    willSwapElements() {\r\n        return !!(this.dragTo || this.activeDropArea && this.startDropArea !== this.activeDropArea);\r\n    }\r\n    /** Returns the index of inserting index into drop area. */\r\n    getSwapIndex() {\r\n        return this.dragToIndex;\r\n    }\r\n    /** When mouse leaves drop area. */\r\n    onLeaveDroppable(drop) {\r\n        if (drop !== this.activeDropArea) {\r\n            return;\r\n        }\r\n        for (let el of this.movedElements) {\r\n            this.moveElement(el, 0, true);\r\n        }\r\n        this.activeDropArea = null;\r\n        this.dragTo = null;\r\n        this.dragToRect = null;\r\n        this.dragToIndex = -1;\r\n    }\r\n    /** Play drag end end transition. */\r\n    async playEndDraggingAnimation() {\r\n        // Animate dragging elemenet to drop area.\r\n        if (this.willSwapElements()) {\r\n            await this.animateDraggingElementToDropArea();\r\n            this.el.style.transform = '';\r\n        }\r\n        // Animate dragging elemenet to it's original position.\r\n        else {\r\n            // When moves dragging element outside.\r\n            if (this.activeDropArea !== this.startDropArea) {\r\n                this.moveSiblingsToGiveSpace(true);\r\n            }\r\n            await ff_1.animateTo(this.el, { transform: '' });\r\n        }\r\n        this.restoreMovedElements(false);\r\n        this.clearDraggingStyle();\r\n    }\r\n    /** Animate dragging elemenet to where it dropped. */\r\n    async animateDraggingElementToDropArea() {\r\n        let fromRect = ff_1.getRect(this.el);\r\n        let toRect = this.dragToRect || ff_1.getRect(this.placeholder);\r\n        let x = toRect.left - fromRect.left + this.translate[0];\r\n        let y = toRect.top - fromRect.top + this.translate[1];\r\n        if (this.direction === 'x') {\r\n            // Move from left to right, align at right.\r\n            if (this.dragging.index < this.dragToIndex) {\r\n                x = toRect.right - fromRect.right + this.translate[0];\r\n            }\r\n        }\r\n        else {\r\n            // Move from top to bottom, align at bottom.\r\n            if (this.dragging.index < this.dragToIndex) {\r\n                y = toRect.bottom - fromRect.bottom + this.translate[1];\r\n            }\r\n        }\r\n        let transform = `translate(${x}px, ${y}px)`;\r\n        await ff_1.animateTo(this.el, { transform });\r\n    }\r\n    /** Move next silbling elements to give space for dragging elemenet. */\r\n    moveSiblingsToGiveSpace(playAnimation) {\r\n        for (let el of this.getSiblingsAfter(this.el)) {\r\n            this.moveElement(el, 1, playAnimation);\r\n        }\r\n    }\r\n    /** Restore all moved and also translated elements. */\r\n    restoreMovedElements(playAnimation) {\r\n        for (let el of this.translatedElements) {\r\n            if (playAnimation) {\r\n                ff_1.animateTo(el, { transform: '' });\r\n            }\r\n            else {\r\n                ff_1.stopAnimation(el);\r\n                el.style.transform = '';\r\n            }\r\n        }\r\n        // Set a new set would be faster, but it's not performance sensitive here.\r\n        this.movedElements.clear();\r\n        this.translatedElements.clear();\r\n        this.placeholder.remove();\r\n    }\r\n    /** Clear dragging style for dragging element. */\r\n    clearDraggingStyle() {\r\n        document.body.style.cursor = '';\r\n        document.body.style.userSelect = '';\r\n        this.el.style.cssText = this.startStyleText;\r\n    }\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getClosestRouter = exports.recirectTo = exports.RedirectToBinding = exports.goTo = exports.GotoBinding = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst popup_1 = require(\"../components/popup\");\r\nconst router_1 = require(\"../components/router\");\r\n/**\r\n * A `:goto` binding will goto a target location path after clicking binded element.\r\n *\r\n * `:goto=\"relativeURL\"`\r\n * `:goto=${relativeURL}`\r\n */\r\nclass GotoBinding {\r\n    constructor(el) {\r\n        this.router = null;\r\n        this.value = '';\r\n        this.asPopupPath = false;\r\n        this.el = el;\r\n        flit_1.on(this.el, 'click', this.onClick, this);\r\n    }\r\n    update(value, options = {}) {\r\n        var _a, _b;\r\n        this.value = value;\r\n        this.asPopupPath = (_a = options.asPopupPath) !== null && _a !== void 0 ? _a : false;\r\n        this.router = (_b = options.router) !== null && _b !== void 0 ? _b : null;\r\n    }\r\n    onClick() {\r\n        this.ensureRouter();\r\n        this.router.goto(this.value, this.asPopupPath);\r\n    }\r\n    ensureRouter() {\r\n        if (!this.router) {\r\n            this.router = getClosestRouter(this.el.parentElement);\r\n            if (!this.router) {\r\n                throw new Error(`\":goto\" must be contained in a extended component of \"Router\"`);\r\n            }\r\n        }\r\n    }\r\n    remove() { }\r\n}\r\nexports.GotoBinding = GotoBinding;\r\n/**\r\n * A `goto` binding will goto a target location path after clicking binded element.\r\n *\r\n * `goto(path)`\r\n * `goto(path, asPopupPath)`\r\n */\r\nexports.goTo = flit_1.defineBinding('goto', GotoBinding);\r\nclass RedirectToBinding extends GotoBinding {\r\n    onClick() {\r\n        this.ensureRouter();\r\n        this.router.redirectTo(this.value, this.asPopupPath);\r\n    }\r\n}\r\nexports.RedirectToBinding = RedirectToBinding;\r\n/**\r\n * A `recirectTo` binding will redirect a target location path after clicking binded element.\r\n *\r\n * `recirectTo(path)`\r\n * `recirectTo(path, asPopupPath)`\r\n */\r\nexports.recirectTo = flit_1.defineBinding('redirectTo', GotoBinding);\r\n/** Get closest router by walking ancestor element. */\r\nfunction getClosestRouter(el) {\r\n    let parent = el;\r\n    while (parent && parent instanceof HTMLElement) {\r\n        if (parent.localName.includes('-')) {\r\n            let com = flit_1.getComponent(parent);\r\n            if (com instanceof router_1.Router) {\r\n                return com;\r\n            }\r\n            else if (com instanceof popup_1.Popup) {\r\n                parent = com.getTriggerElement();\r\n            }\r\n            else {\r\n                parent = parent.parentElement;\r\n            }\r\n        }\r\n        else {\r\n            parent = parent.parentElement;\r\n        }\r\n    }\r\n    return null;\r\n}\r\nexports.getClosestRouter = getClosestRouter;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.loading = exports.LoadingBinging = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst DefaultLoadingOptions = {\r\n    size: 'medium',\r\n    transition: { name: 'fade' },\r\n};\r\n/**\r\n * A `:loading` binding will show a loader and cover current element.\r\n *\r\n * `:loading=${isLoading}`\r\n */\r\nclass LoadingBinging {\r\n    constructor(el) {\r\n        this.options = new flit_1.UpdatableOptions(DefaultLoadingOptions);\r\n        this.value = false;\r\n        this.cover = null;\r\n        this.el = el;\r\n    }\r\n    update(value, options) {\r\n        this.value = value;\r\n        this.options.update(options);\r\n        let transition = this.options.get('transition');\r\n        if (this.value) {\r\n            if (this.cover) {\r\n                if (transition) {\r\n                    new flit_1.Transition(this.cover, transition).leave().then(finish => {\r\n                        if (finish) {\r\n                            this.cover.remove();\r\n                            this.cover = null;\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    this.cover.remove();\r\n                    this.cover = null;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (!this.cover) {\r\n                this.cover = flit_1.render(flit_1.html `<f-loader .size=${this.options.get('size')} .asCover />`).getFirstElement();\r\n                this.el.append(this.cover);\r\n            }\r\n            if (transition) {\r\n                new flit_1.Transition(this.cover, transition).enter();\r\n            }\r\n        }\r\n    }\r\n    remove() {\r\n        if (this.cover) {\r\n            this.cover.remove();\r\n        }\r\n    }\r\n}\r\nexports.LoadingBinging = LoadingBinging;\r\n/**\r\n * Shows a loader and cover current element.\r\n * @param value Whether shows loader.\r\n * @param options Options, `{size: small | medium | large, transition: {...}}`.\r\n */\r\nexports.loading = flit_1.defineBinding('loading', LoadingBinging);\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.popup = exports.PopupBinding = exports.DefaultPopupOptions = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst ff_1 = require(\"@pucelle/ff\");\r\n/** Default popup options. */\r\nexports.DefaultPopupOptions = {\r\n    trigger: 'hover',\r\n    alignPosition: 'b',\r\n    alignMargin: 4,\r\n    showDelay: 100,\r\n    hideDelay: 100,\r\n    triangle: true,\r\n    fixTriangle: false,\r\n    transition: { name: 'fade' },\r\n    showImmediately: false,\r\n    autoFocus: false,\r\n};\r\n/** Cache stacked popup components with specified `key` option. */\r\nconst SharedPopupCache = new Map();\r\n/** Cache last created popup component usage with specified `key` option. */\r\nconst SharedPopupsThatsInUse = new Map();\r\n/** Get a shared popup component by key. */\r\nfunction getSharedPopupCache(key) {\r\n    let caches = SharedPopupCache.get(key);\r\n    if (caches) {\r\n        for (let i = caches.length - 1; i >= 0; i--) {\r\n            let cache = caches[i];\r\n            let popup = cache.popup;\r\n            // If current popup is in use, not reuse it.\r\n            if (ff_1.MouseLeave.checkLocked(popup.el)) {\r\n                return null;\r\n            }\r\n            return cache;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n/** Get a shared popup component by key. */\r\nfunction addSharedPopupCache(key, cache) {\r\n    let caches = SharedPopupCache.get(key);\r\n    if (!caches) {\r\n        caches = [];\r\n        SharedPopupCache.set(key, caches);\r\n    }\r\n    caches.push(cache);\r\n}\r\n/** Delete a shared popup component after it hide. */\r\nfunction deleteSharedPopupCache(key, popup) {\r\n    let caches = SharedPopupCache.get(key);\r\n    if (caches) {\r\n        caches = caches.filter(cache => cache.popup !== popup);\r\n        SharedPopupCache.set(key, caches);\r\n    }\r\n}\r\n/** Get a shared popup component by key. */\r\nfunction isSharedPopupKeyInUse(key) {\r\n    let cache = getSharedPopupCache(key);\r\n    return cache ? SharedPopupsThatsInUse.has(cache.popup) : false;\r\n}\r\n/**\r\n * A `:popup` binding can bind trigger element with it's popup component,\r\n * and make popup component poped-up when interact with trigger element.\r\n *\r\n * `:popup=${() => popupComponent}`\r\n */\r\nclass PopupBinding extends ff_1.Emitter {\r\n    constructor(el, context) {\r\n        super();\r\n        /** When decided to open or opened. */\r\n        this.willOpen = false;\r\n        /** Be `true` after opened popup. */\r\n        this.opened = false;\r\n        /** Be a `Timeout` after decided to open popup but not yet. */\r\n        this.showTimeout = null;\r\n        /** Be a `Timeout` after decided to close popup but not yet. */\r\n        this.hideTimeout = null;\r\n        /** Used to watch rect change after popup opened. */\r\n        this.unwatchRect = null;\r\n        /** Used to watch mouse leaves trigger or popup element after popup opened. */\r\n        this.unwatchLeave = null;\r\n        /** Current popup. */\r\n        this.popup = null;\r\n        /** Controls current popup. */\r\n        this.popupTemplate = null;\r\n        /** Align to current popup. */\r\n        this.aligner = null;\r\n        this.el = el;\r\n        this.context = context;\r\n        // Don't assign default values.\r\n        this.options = new flit_1.UpdatableOptions({});\r\n    }\r\n    getOption(key) {\r\n        let value = this.options.get(key);\r\n        // `popupOptions` in popup component have a higher priority that default options.\r\n        if (value === undefined && this.popup && this.popup.defaultPopupOptions) {\r\n            value = this.popup.defaultPopupOptions[key];\r\n        }\r\n        if (value === undefined) {\r\n            value = exports.DefaultPopupOptions[key];\r\n        }\r\n        return value;\r\n    }\r\n    /** Get the trigger element. */\r\n    getTriggerElement() {\r\n        return this.el;\r\n    }\r\n    /** `renderFn` should never change. */\r\n    update(renderFn, options) {\r\n        let firstTimeUpdate = this.options.isNotUpdated();\r\n        this.renderFn = renderFn;\r\n        this.options.update(options);\r\n        if (firstTimeUpdate) {\r\n            // Must knows trigger type firstly, then can bind trigger.\r\n            this.bindTrigger();\r\n        }\r\n        else if (this.opened) {\r\n            flit_1.enqueueUpdatableInOrder(this, this.context, flit_1.UpdatableUpdateOrder.Directive);\r\n        }\r\n    }\r\n    bindTrigger() {\r\n        let trigger = this.getOption('trigger');\r\n        if (trigger === 'click') {\r\n            flit_1.on(this.el, 'click', this.togglePopupOpened, this);\r\n        }\r\n        else if (trigger === 'hover') {\r\n            flit_1.on(this.el, 'mouseenter', this.showPopupLater, this);\r\n        }\r\n        else if (trigger === 'focus') {\r\n            flit_1.on(this.el, 'focus', this.showPopupLater, this);\r\n            if (this.el.contains(document.activeElement)) {\r\n                this.showPopupLater();\r\n            }\r\n        }\r\n        if (this.getOption('showImmediately')) {\r\n            this.showPopupLater();\r\n        }\r\n    }\r\n    unbindTrigger() {\r\n        let trigger = this.getOption('trigger');\r\n        if (trigger === 'click') {\r\n            flit_1.off(this.el, 'click', this.togglePopupOpened, this);\r\n        }\r\n        else if (trigger === 'hover') {\r\n            flit_1.off(this.el, 'mouseenter', this.showPopupLater, this);\r\n        }\r\n        else if (trigger === 'focus') {\r\n            flit_1.off(this.el, 'focus', this.showPopupLater, this);\r\n        }\r\n    }\r\n    /** Toggle opened state and show or hide popup component immediately. */\r\n    togglePopupOpened() {\r\n        if (this.opened) {\r\n            this.willOpen = false;\r\n            this.hidePopup();\r\n        }\r\n        else {\r\n            this.willOpen = true;\r\n            this.showPopup();\r\n        }\r\n    }\r\n    /** Show popup component after a short time out. */\r\n    showPopupLater() {\r\n        if (this.willOpen) {\r\n            return;\r\n        }\r\n        let trigger = this.getOption('trigger');\r\n        let showDelay = this.getOption('showDelay');\r\n        let key = this.getOption('key');\r\n        // If can reuse exist, show without delay.\r\n        if (isSharedPopupKeyInUse(key)) {\r\n            showDelay = 0;\r\n        }\r\n        // If give a delay for `click` type trigger, it will feel like a stuck or slow responsive.\r\n        if (trigger === 'click' || trigger === 'focus') {\r\n            showDelay = 0;\r\n        }\r\n        this.willOpen = true;\r\n        if (showDelay > 0) {\r\n            this.showTimeout = new ff_1.Timeout(() => {\r\n                this.showTimeout = null;\r\n                if (this.willOpen) {\r\n                    this.showPopup();\r\n                }\r\n            }, showDelay);\r\n        }\r\n        else {\r\n            this.showPopup();\r\n        }\r\n        this.bindLeavingTriggerEvents();\r\n    }\r\n    /** Clear timeout for showing popup component. */\r\n    clearShowTimeout() {\r\n        if (this.showTimeout) {\r\n            this.showTimeout.cancel();\r\n            this.showTimeout = null;\r\n        }\r\n    }\r\n    /** Clear timeout for hiding popup component. */\r\n    clearHideTimeout() {\r\n        if (this.hideTimeout) {\r\n            this.hideTimeout.cancel();\r\n            this.hideTimeout = null;\r\n        }\r\n    }\r\n    /** Bind events to handle leaving trigger element before popup component showing. */\r\n    bindLeavingTriggerEvents() {\r\n        let trigger = this.getOption('trigger');\r\n        if (trigger === 'hover') {\r\n            flit_1.on(this.el, 'mouseleave', this.cancelShowingPopup, this);\r\n        }\r\n        else if (trigger === 'focus') {\r\n            flit_1.on(this.el, 'blur', this.cancelShowingPopup, this);\r\n        }\r\n    }\r\n    /** Unbind events to handle leaving trigger element before popup component showing. */\r\n    unbindLeavingTriggerEvents() {\r\n        let trigger = this.getOption('trigger');\r\n        if (trigger === 'hover') {\r\n            flit_1.off(this.el, 'mouseleave', this.cancelShowingPopup, this);\r\n        }\r\n        else if (trigger === 'focus') {\r\n            flit_1.off(this.el, 'blur', this.cancelShowingPopup, this);\r\n        }\r\n    }\r\n    /** Cancel showing popup. */\r\n    cancelShowingPopup() {\r\n        this.willOpen = false;\r\n        this.unbindLeavingTriggerEvents();\r\n        this.clearShowTimeout();\r\n    }\r\n    /** Show popup component. */\r\n    showPopup() {\r\n        flit_1.enqueueUpdatableInOrder(this, this.context, flit_1.UpdatableUpdateOrder.Directive);\r\n    }\r\n    __updateImmediately() {\r\n        // Why must enqueue updating?\r\n        // There are 2 entries: trigger here, and update from parent component.\r\n        // We should merge them into one.\r\n        if (!this.willOpen) {\r\n            return;\r\n        }\r\n        if (this.popup) {\r\n            this.updatePopup();\r\n        }\r\n        else {\r\n            let isOldInUse = this.ensurePopup();\r\n            this.popup.el.style.visibility = 'hidden';\r\n            this.unbindLeavingTriggerEvents();\r\n            this.bindLeaveEvents();\r\n            this.setOpened(true);\r\n            // May do something in handlers of `openedStateChange` event.\r\n            flit_1.onRenderComplete(() => {\r\n                if (!this.willOpen || !this.popup) {\r\n                    return;\r\n                }\r\n                this.alignPopup();\r\n                this.popup.el.style.visibility = '';\r\n                this.mayGetFocus();\r\n                if (!isOldInUse) {\r\n                    new flit_1.Transition(this.popup.el, this.getOption('transition')).enter();\r\n                }\r\n                this.unwatchRect = ff_1.watchLayout(this.el, 'rect', this.onTriggerRectChanged.bind(this));\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Get a cached popup component, or create a new one.\r\n     * Returns whether old popup is in use.\r\n     */\r\n    ensurePopup() {\r\n        let result = this.renderFn();\r\n        let key = this.getOption('key');\r\n        let popup = null;\r\n        let template = null;\r\n        let canShareWithOld = true;\r\n        let isOldInUse = false;\r\n        if (!(result instanceof flit_1.TemplateResult)) {\r\n            result = flit_1.html `${result}`;\r\n        }\r\n        if (key) {\r\n            let cache = getSharedPopupCache(key);\r\n            if (cache) {\r\n                ({ popup, template } = cache);\r\n                let currentTriggerInsideCachedPopup = popup.el.contains(this.el);\r\n                // Reuse and merge.\r\n                if (!currentTriggerInsideCachedPopup && template.canMergeWith(result)) {\r\n                    template.merge(result);\r\n                }\r\n                // Can't reuse since trigger element inside it.\r\n                else if (currentTriggerInsideCachedPopup) {\r\n                    popup = null;\r\n                }\r\n                // Destroy same name old one immediately.\r\n                else {\r\n                    canShareWithOld = false;\r\n                }\r\n            }\r\n        }\r\n        if (popup) {\r\n            // Whether use by other popup binding, such that no need to play transition.\r\n            let inUseBinding = SharedPopupsThatsInUse.get(popup);\r\n            if (inUseBinding && inUseBinding !== this) {\r\n                inUseBinding.losePopupControl();\r\n            }\r\n            isOldInUse = !!inUseBinding;\r\n            if (!canShareWithOld) {\r\n                popup.el.remove();\r\n                popup = null;\r\n            }\r\n        }\r\n        if (!popup) {\r\n            // No need to watch the renderFn, it will be watched from outer component render function.\r\n            template = flit_1.render(result, this.context);\r\n            popup = flit_1.getRenderedAsComponent(template);\r\n            if (key) {\r\n                addSharedPopupCache(key, { popup, template });\r\n            }\r\n        }\r\n        if (key) {\r\n            SharedPopupsThatsInUse.set(popup, this);\r\n        }\r\n        this.popup = popup;\r\n        this.popupTemplate = template;\r\n        popup.setBinding(this);\r\n        popup.applyAppendTo();\r\n        return isOldInUse;\r\n    }\r\n    losePopupControl() {\r\n        this.clean();\r\n    }\r\n    /** Clean all popup properties. */\r\n    clean() {\r\n        if (this.opened) {\r\n            this.unbindLeaveEvents();\r\n            if (this.unwatchRect) {\r\n                this.unwatchRect();\r\n                this.unwatchRect = null;\r\n            }\r\n            this.willOpen = false;\r\n            this.setOpened(false);\r\n            this.popup = null;\r\n            this.popupTemplate = null;\r\n            this.aligner = null;\r\n        }\r\n    }\r\n    /** Update popup component, calls when updating an outer component. */\r\n    updatePopup() {\r\n        let result = this.renderFn();\r\n        let key = this.getOption('key');\r\n        let popup = this.popup;\r\n        let template = this.popupTemplate;\r\n        if (!(result instanceof flit_1.TemplateResult)) {\r\n            result = flit_1.html `${result}`;\r\n        }\r\n        if (template.canMergeWith(result)) {\r\n            template.merge(result);\r\n        }\r\n        else {\r\n            popup.el.remove();\r\n            let template = this.popupTemplate = flit_1.render(result, this.context);\r\n            popup = flit_1.getRenderedAsComponent(template);\r\n            if (key) {\r\n                addSharedPopupCache(key, { popup, template });\r\n            }\r\n        }\r\n        flit_1.onRenderComplete(() => {\r\n            if (this.popup) {\r\n                this.alignPopup();\r\n            }\r\n        });\r\n    }\r\n    /** Set opened state and triggers event. */\r\n    setOpened(opened) {\r\n        this.opened = opened;\r\n        this.emit('openedStateChange', opened);\r\n    }\r\n    /** Align popup component. */\r\n    alignPopup() {\r\n        let popup = this.popup;\r\n        let alignToFn = this.getOption('alignTo');\r\n        let alignTo = alignToFn ? alignToFn(this.el) : this.el;\r\n        this.emit('willAlign');\r\n        // Create a aligner since align too much times for a tooltip.\r\n        if (!this.aligner) {\r\n            this.aligner = new ff_1.Aligner(popup.el, alignTo, this.getOption('alignPosition'), this.getAlignOptions());\r\n        }\r\n        this.aligner.align();\r\n    }\r\n    /** Get align options. */\r\n    getAlignOptions() {\r\n        let triangle = this.popup.refs.triangle;\r\n        return {\r\n            margin: this.getOption('alignMargin'),\r\n            canShrinkInY: true,\r\n            triangle,\r\n            fixTriangle: this.getOption('fixTriangle'),\r\n        };\r\n    }\r\n    /** Make element of popup component get focus if possible. */\r\n    mayGetFocus() {\r\n        let trigger = this.getOption('trigger');\r\n        if (this.getOption('autoFocus') && (trigger !== 'hover' && trigger !== 'focus') && this.popup && this.popup.el.tabIndex >= 0) {\r\n            this.popup.el.focus();\r\n        }\r\n    }\r\n    /** Bind hiding popup component events. */\r\n    bindLeaveEvents() {\r\n        var _a;\r\n        let trigger = this.getOption('trigger');\r\n        if (trigger === 'hover') {\r\n            // Should not use `MouseLeave.once`, because `hidePopupLater` may be canceled, it needs trigger again.\r\n            this.unwatchLeave = ff_1.MouseLeave.on(this.el, this.popup.el, this.hidePopup.bind(this), {\r\n                delay: this.getOption('hideDelay'),\r\n                mouseIn: true,\r\n            });\r\n        }\r\n        else if (trigger === 'click' || trigger === 'contextmenu') {\r\n            flit_1.on(document, 'mousedown', this.onDocMouseDown, this);\r\n            ff_1.MouseLeave.lock(this.el, (_a = this.popup) === null || _a === void 0 ? void 0 : _a.el);\r\n        }\r\n        else if (trigger === 'focus') {\r\n            flit_1.on(this.el, 'blur', this.hidePopupLater, this);\r\n        }\r\n    }\r\n    /** Unbind hiding popup component events. */\r\n    unbindLeaveEvents() {\r\n        var _a;\r\n        let trigger = this.getOption('trigger');\r\n        if (trigger === 'hover') {\r\n            if (this.unwatchLeave) {\r\n                this.unwatchLeave();\r\n                this.unwatchLeave = null;\r\n            }\r\n        }\r\n        else if (trigger === 'click' || trigger === 'contextmenu') {\r\n            flit_1.off(document, 'mousedown', this.onDocMouseDown, this);\r\n            ff_1.MouseLeave.unlock(this.el, (_a = this.popup) === null || _a === void 0 ? void 0 : _a.el);\r\n        }\r\n        else if (trigger === 'focus') {\r\n            flit_1.off(this.el, 'blur', this.hidePopupLater, this);\r\n        }\r\n    }\r\n    /** Hide popup component after a short time out. */\r\n    hidePopupLater() {\r\n        if (!this.opened) {\r\n            return;\r\n        }\r\n        let hideDelay = this.getOption('hideDelay');\r\n        this.hideTimeout = new ff_1.Timeout(() => {\r\n            this.hideTimeout = null;\r\n            if (this.opened) {\r\n                this.hidePopup();\r\n            }\r\n        }, hideDelay);\r\n        this.willOpen = false;\r\n    }\r\n    /** Hide popup component. */\r\n    hidePopup() {\r\n        let key = this.getOption('key');\r\n        let popup = this.popup;\r\n        let popupEl = popup.el;\r\n        if (key) {\r\n            deleteSharedPopupCache(key, popup);\r\n            SharedPopupsThatsInUse.delete(popup);\r\n        }\r\n        new flit_1.Transition(popupEl, this.getOption('transition')).leave().then(finish => {\r\n            if (finish) {\r\n                popupEl.remove();\r\n            }\r\n        });\r\n        this.clean();\r\n    }\r\n    /** Trigger when mouse down on document. */\r\n    onDocMouseDown(e) {\r\n        let target = e.target;\r\n        if (!this.el.contains(target) && (!this.popup || !this.popup.el.contains(target))) {\r\n            this.hidePopupLater();\r\n        }\r\n    }\r\n    /** After trigger element position changed. */\r\n    onTriggerRectChanged() {\r\n        if (ff_1.isVisibleInViewport(this.el, 0.1, this.popup.el)) {\r\n            if (this.popup) {\r\n                this.alignPopup();\r\n            }\r\n        }\r\n        else {\r\n            this.hidePopupLater();\r\n        }\r\n    }\r\n    remove() {\r\n        flit_1.off(this.el, 'mouseenter', this.showPopupLater, this);\r\n        if (this.opened) {\r\n            this.hidePopup();\r\n        }\r\n        else {\r\n            this.clean();\r\n        }\r\n        this.unbindTrigger();\r\n    }\r\n}\r\nexports.PopupBinding = PopupBinding;\r\n/**\r\n * Bind trigger element with it's popup component,\r\n * and make popup component poped-up when interact with trigger element.\r\n * @param renderFn Should return a `<f-popup />` type template result.\r\n * @param options Popup options, `{trigger, alignTo, alignPosition, ...}`.\r\n */\r\nexports.popup = flit_1.defineBinding('popup', PopupBinding);\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.tooltip = exports.TooltipBinding = void 0;\r\nconst ff_1 = require(\"@pucelle/ff\");\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst popup_1 = require(\"./popup\");\r\nconst defaultTooltipOptions = {\r\n    alignPosition: 'r',\r\n    alignMargin: 3,\r\n    showDelay: 0,\r\n    hideDelay: 200,\r\n    triangle: true,\r\n    fixTriangle: false,\r\n    type: 'default',\r\n};\r\n/**\r\n * A `:tooltip` binding can help to show a short text message beside it's trigger element.\r\n *\r\n * `:tooltip=\"message\"`\r\n * `:tooltip=${message}`\r\n */\r\nclass TooltipBinding extends popup_1.PopupBinding {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.title = '';\r\n    }\r\n    update(title, options = {}) {\r\n        this.title = title;\r\n        super.update(this.getRenderFn.bind(this), this.getPopupOptions(options));\r\n    }\r\n    getRenderFn() {\r\n        return flit_1.html `\n\t\t\t<f-tooltip\n\t\t\t\t.herizontal=${this.isHerizontal()}\n\t\t\t\t.type=${this.getOption('type')}\n\t\t\t>\n\t\t\t\t${this.title}\n\t\t\t</f-tooltip>\n\t\t`;\r\n    }\r\n    getPopupOptions(options = {}) {\r\n        var _a;\r\n        let optionType = (_a = options.type) !== null && _a !== void 0 ? _a : defaultTooltipOptions.type;\r\n        return {\r\n            ...defaultTooltipOptions,\r\n            // Default key is `tooltip` for default type.\r\n            key: optionType === 'default' ? 'tooltip' : '',\r\n            ...options,\r\n        };\r\n    }\r\n    isHerizontal() {\r\n        let direction = ff_1.getMainAlignDirection(this.options.get('alignPosition'));\r\n        return direction === 'l' || direction === 'r';\r\n    }\r\n    showPopupLater() {\r\n        // Not popup if no `title` specified.\r\n        if (!this.title) {\r\n            return;\r\n        }\r\n        super.showPopupLater();\r\n    }\r\n    bindTrigger() {\r\n        if (this.shouldAlwaysKeepVisible()) {\r\n            // If not wait window loaded, page scrolling position may be not determinated yet.\r\n            // So element may be aligned to a wrong position.\r\n            ff_1.ensureWindowLoaded().then(() => {\r\n                this.showPopupLater();\r\n            });\r\n        }\r\n        else {\r\n            super.bindTrigger();\r\n        }\r\n    }\r\n    /** Whether the tooltip should always visible. */\r\n    shouldAlwaysKeepVisible() {\r\n        return ['prompt', 'error'].includes(this.getOption('type'));\r\n    }\r\n    bindLeaveEvents() {\r\n        if (!this.shouldAlwaysKeepVisible()) {\r\n            super.bindLeaveEvents();\r\n        }\r\n    }\r\n    /** After trigger element position changed. */\r\n    onTriggerRectChanged() {\r\n        if (this.shouldAlwaysKeepVisible() || ff_1.isVisibleInViewport(this.el, 0.1, this.popup.el)) {\r\n            if (this.popup) {\r\n                this.alignPopup();\r\n            }\r\n        }\r\n        else {\r\n            this.hidePopupLater();\r\n        }\r\n    }\r\n    getAlignOptions() {\r\n        let triangle = this.popup.refs.triangle;\r\n        return {\r\n            margin: this.getOption('alignMargin'),\r\n            stickToEdges: false,\r\n            canShrinkInY: true,\r\n            triangle,\r\n            fixTriangle: this.getOption('fixTriangle'),\r\n        };\r\n    }\r\n}\r\nexports.TooltipBinding = TooltipBinding;\r\n/**\r\n * tooltip binding can help to show a short text message.\r\n *\r\n * `tooltip(title, {alignPosition, alignMargin, ...})`\r\n */\r\nexports.tooltip = flit_1.defineBinding('tooltip', TooltipBinding);\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ButtonGroup = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\n/** `<f-buttongroup>` can contains several `<button>` elements as a button group. */\r\nlet ButtonGroup = class ButtonGroup extends flit_1.Component {\r\n    static style() {\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tdisplay: inline-flex;\n\t\t\tvertical-align: top;\n\t\t}\n\n\t\tbutton{\n\t\t\t&:nth-child(n+2){\n\t\t\t\tmargin-left: -1px;\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t}\n\t\n\t\t\t&:nth-last-child(n+2){\n\t\t\t\tborder-top-right-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\n\t\t\t&[primary]{\n\t\t\t\tposition: relative;\n\t\t\t\tz-index: 1;\n\t\t\t}\n\n\t\t\t&:hover{\n\t\t\t\tposition: relative;\n\t\t\t\tz-index: 1;\n\t\t\t}\n\t\t}\n\t\t`;\r\n    }\r\n};\r\nButtonGroup = __decorate([\r\n    flit_1.define('f-buttongroup')\r\n], ButtonGroup);\r\nexports.ButtonGroup = ButtonGroup;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Checkbox = exports.CheckboxGroup = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst theme_1 = require(\"../style/theme\");\r\nconst ff_1 = require(\"@pucelle/ff\");\r\n/** `<f-checkboxgroup>` can contains several `<f-checkbox>` as child. */\r\nlet CheckboxGroup = class CheckboxGroup extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** All child `<f-checkbox>`. */\r\n        this.checkboxs = [];\r\n        /** All values of checked child checkboxs. */\r\n        this.value = [];\r\n    }\r\n    /** Retister a child checkbox. */\r\n    register(checkbox) {\r\n        this.checkboxs.push(checkbox);\r\n        checkbox.on('change', this.onCheckboxChange.bind(this, checkbox));\r\n    }\r\n    onCheckboxChange(checkbox) {\r\n        if (checkbox.checked) {\r\n            ff_1.add(this.value, checkbox.value);\r\n        }\r\n        else {\r\n            ff_1.removeWhere(this.value, value => value == checkbox.value);\r\n        }\r\n        this.emit('change', this.value);\r\n    }\r\n};\r\nCheckboxGroup = __decorate([\r\n    flit_1.define('f-checkboxgroup')\r\n], CheckboxGroup);\r\nexports.CheckboxGroup = CheckboxGroup;\r\n/** `<f-checkbox>` just like `<input type=checkbox>`, you can click to check or uncheck one checkbox in a checkbox group. */\r\nlet Checkbox = class Checkbox extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.checkboxGroup = null;\r\n        /** Whether the checkbox was checked. */\r\n        this.checked = false;\r\n        /** Whether the checkbox in indeterminate state, than means, not determined checked or unchecked. */\r\n        this.indeterminate = false;\r\n        /** If having a parent `<f-checkboxgroup>`, the `value` property will be assign to it after current checkbox checked. */\r\n        this.value = null;\r\n    }\r\n    static style() {\r\n        let { mainColor, focusBlurRadius, adjust } = theme_1.theme;\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tdisplay: inline-flex;\n\t\t\tvertical-align: top;\n\t\t\talign-items: center;\n\t\t\tcursor: pointer;\n\n\t\t\t&:hover{\n\t\t\t\tcolor: ${mainColor};\n\t\t\t}\n\n\t\t\t&:focus{\n\t\t\t\tcolor: ${mainColor};\n\n\t\t\t\t.icon{\n\t\t\t\t\tbox-shadow: 0 0 ${focusBlurRadius}px ${mainColor};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t.icon{\n\t\t\tposition: relative;\n\t\t\ttop: -2px;\n\t\t\tmargin-right: ${adjust(7)}px;\n\t\t\tborder-radius: 4px;\n\t\t}\n\n\t\t.indeterminate, .checked{\n\t\t\tcolor: ${mainColor};\n\t\t}\n\n\t\t.label{\n\t\t\tflex: 1;\n\t\t\twhite-space: nowrap;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\t\t`;\r\n    }\r\n    onCreated() {\r\n        let group = flit_1.getClosestComponentOfType(this.el, CheckboxGroup);\r\n        if (group) {\r\n            this.checkboxGroup = group;\r\n            this.checked = this.checkboxGroup.value.includes(this.value);\r\n            this.checkboxGroup.register(this);\r\n        }\r\n    }\r\n    render() {\r\n        let iconType = this.checked ? 'checkbox-checked' : this.indeterminate ? 'checkbox-indeterminate' : 'checkbox-unchecked';\r\n        return flit_1.html `\n\t\t\t<template\n\t\t\t\ttabindex=\"0\"\n\t\t\t\t:class.checked=${this.checked}\n\t\t\t\t:class.indeterminate=${this.indeterminate}\n\t\t\t\t@click=${this.onClick}\n\t\t\t\t@focus=${this.onFocus}\n\t\t\t\t@blur=${this.onBlur}\n\t\t\t>\n\t\t\t\t<f-icon class=\"icon\" .type=${iconType} />\n\t\t\t\t<div class=\"label\">\n\t\t\t\t\t<slot />\n\t\t\t\t</div>\n\t\t\t</template>\n\t\t`;\r\n    }\r\n    onClick() {\r\n        this.toggleChecked();\r\n    }\r\n    toggleChecked() {\r\n        this.checked = !this.checked;\r\n        this.indeterminate = false;\r\n        this.emit('change', this.checked);\r\n    }\r\n    onFocus() {\r\n        flit_1.on(document, 'keydown.enter', this.onEnter, this);\r\n    }\r\n    onEnter(e) {\r\n        e.preventDefault();\r\n        this.toggleChecked();\r\n    }\r\n    onBlur() {\r\n        flit_1.off(document, 'keydown', this.onEnter, this);\r\n    }\r\n};\r\nCheckbox = __decorate([\r\n    flit_1.define('f-checkbox')\r\n], Checkbox);\r\nexports.Checkbox = Checkbox;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ContextMenu = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst theme_1 = require(\"../style/theme\");\r\nconst popup_1 = require(\"../components/popup\");\r\n/** `<f-contextmenu>` is used for render a context menu after right clicking. */\r\nlet ContextMenu = class ContextMenu extends popup_1.Popup {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.triangle = false;\r\n    }\r\n    static style() {\r\n        let { adjust } = theme_1.theme;\r\n        return flit_1.css `\n\t\t${super.style()}\n\t\t:host{\n\t\t\tposition: fixed;\n\t\t\tborder-radius: 0;\n\t\t\t\n\t\t\t.option__f-list{\n\t\t\t\tpadding: ${adjust(2)}px ${adjust(8)}px;\n\t\t\t}\n\n\t\t\tf-list{\n\t\t\t\tborder-bottom: none;\n\t\t\t}\n\t\t}\n\t\t`.extends(super.style());\r\n    }\r\n};\r\nContextMenu = __decorate([\r\n    flit_1.define('f-contextmenu')\r\n], ContextMenu);\r\nexports.ContextMenu = ContextMenu;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.dialog = exports.QuickDialog = exports.Dialog = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst theme_1 = require(\"../style/theme\");\r\nconst ff_1 = require(\"@pucelle/ff\");\r\nconst element_1 = require(\"../utils/element\");\r\nconst translations_1 = require(\"../translations/translations\");\r\n/** `<f-dialog>` shows critical content and in a overlay modal, you must interact with it before continue. */\r\nlet Dialog = class Dialog extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** Options for current dialog. */\r\n        this.currentOptions = null;\r\n        /** Also as a marker to know if current options are expired. */\r\n        this.resolve = null;\r\n        /** Dialog stack, will show one by one. */\r\n        this.stack = [];\r\n        /** Whether any dialog opened. */\r\n        this.opened = true;\r\n        /** Where to append current dialog. */\r\n        this.appendTo = 'body';\r\n    }\r\n    static style() {\r\n        let { textColor, adjust, adjustFontSize, popupBorderRadius, popupShadowBlurRadius, popupShadowColor, popupBackgroundColor } = theme_1.theme;\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tz-index: 1000;\n\t\t\twidth: ${adjust(360)}px;\n\t\t\tposition: fixed;\n\t\t\tborder-radius: ${popupBorderRadius}px;\n\t\t\tbox-shadow: 0 0 ${popupShadowBlurRadius}px ${popupShadowColor};\n\t\t\tbackground: ${popupBackgroundColor};\n\t\t\tmax-width: 96%;\n\t\t\tmax-height: 96%;\n\t\t\tpadding: ${adjust(8)}px ${adjust(16)}px ${adjust(16)}px;\n\t\t}\n\n\t\t.mask{\n\t\t\tposition: fixed;\n\t\t\tz-index: 1000;\n\t\t\tleft: 0;\n\t\t\ttop: 0;\n\t\t\twidth: 100%;\n\t\t\theight: 100%;\n\t\t\tbackground: rgba(0, 0, 0, 0.5);\n\t\t}\n\n\t\t.header{\n\t\t\tdisplay: flex;\n\t\t\tline-height: ${adjust(22)}px;\n\t\t\theight: ${adjust(28) + 1}px;\n\t\t\tfont-size: ${adjustFontSize(13)}px;\n\t\t\tpadding-bottom: ${adjust(6)}px;\n\t\t\tborder-bottom: 1px solid ${textColor.alpha(0.8)};\n\t\t}\n\n\t\t.title{\n\t\t\tflex: 1;\n\t\t\tmin-width: 0;\n\t\t\tpadding: 0 ${adjust(16)}px 0 0;\n\t\t\tfont-weight: bold;\n\t\t\toverflow: hidden;\n\t\t\twhite-space: nowrap;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\n\t\t.content{\n\t\t\tdisplay: flex;\n\t\t\tmargin-top: ${adjust(8)}px;\n\t\t}\n\n\t\t.icon{\n\t\t\tpadding-right: ${adjust(12)}px;\n\t\t}\n\n\t\t.message{\n\t\t\tflex: 1;\n\t\t\tmin-width: 0;\n\t\t\tline-height: ${adjust(20)}px;\n\t\t\tpadding: ${adjust(4)}px 0;\n\t\t}\n\n\t\t.list{\n\t\t\tmargin: ${adjust(8)}px 0;\n\t\t\tline-height: ${adjust(20)}px;\n\t\t\tlist-style-type: square;\n\t\t\tpadding-left: ${adjust(28)}px;\n\t\t}\n\n\t\t.actions{\n\t\t\tdisplay: flex;\n\t\t\tjustify-content: flex-end;\n\t\t\tmargin-top: ${adjust(16)}px;\n\n\t\t\tbutton{\n\t\t\t\tmargin-left: ${adjust(8)}px;\n\t\t\t}\n\n\t\t\t.third{\n\t\t\t\tmargin-left: 0;\n\t\t\t\tmargin-right: auto;\n\t\t\t}\n\t\t}\n\n\t\t.input{\n\t\t\tmargin-top: ${adjust(8)}px;\n\t\t\tmargin-bottom: ${adjust(22)}px;\n\t\t\twidth: 100%;\n\t\t}\n\t\t`;\r\n    }\r\n    render() {\r\n        let options = this.currentOptions;\r\n        if (!options) {\r\n            return '';\r\n        }\r\n        return flit_1.html `\n\t\t\t<template\n\t\t\t\ttabindex=\"0\"\n\t\t\t\t${flit_1.show(this.opened, { name: 'fade', enterAtStart: true, onend: this.onTransitionEnd })}\n\t\t\t>\n\t\t\t\t<div class=\"mask\"\n\t\t\t\t\t:ref=\"mask\"\n\t\t\t\t\t${flit_1.show(this.opened, { name: 'fade', enterAtStart: true })}\n\t\t\t\t/>\n\n\t\t\t\t${options.title ? flit_1.html `\n\t\t\t\t\t<div class=\"header\">\n\t\t\t\t\t\t<div class=\"title\">\n\t\t\t\t\t\t\t${options.title}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t` : ''}\n\n\t\t\t\t<div class=\"content\">\n\n\t\t\t\t\t${options.icon ? flit_1.html `<div class=\"icon\">\n\t\t\t\t\t\t<f-icon .type=\"${options.icon}\" />\n\t\t\t\t\t</div>` : ''}\n\n\t\t\t\t\t<div class=\"message\">\n\t\t\t\t\t\t${options.message}\n\t\t\t\t\t</div>\n\n\t\t\t\t\t${options.list && options.list.length > 0 ? flit_1.html `\n\t\t\t\t\t\t<ul class=\"list\">\n\t\t\t\t\t\t\t${options.list.map(text => flit_1.html `<li>${text}</li>`)}\n\t\t\t\t\t\t</ul>\n\t\t\t\t\t` : ''}\n\t\t\t\t</div>\n\n\t\t\t\t${this.renderActions(options.actions)}\n\t\t\t</template>\n\t\t`;\r\n    }\r\n    renderActions(actions) {\r\n        if (actions && actions.length > 0) {\r\n            let results = actions.map(action => flit_1.html `\n\t\t\t\t<button class=\"action\"\n\t\t\t\t\t?primary=${action.primary}\n\t\t\t\t\t:class.third=${action.third}\n\t\t\t\t\t@click=${() => this.onClickActionButton(action)}>\n\t\t\t\t\t${action.text}\n\t\t\t\t</button>\n\t\t\t`);\r\n            return flit_1.html `<div class=\"actions\">${results}</div>`;\r\n        }\r\n        return '';\r\n    }\r\n    onClickActionButton(action) {\r\n        var _a, _b, _c;\r\n        // Interrupted.\r\n        if ((_b = (_a = this.currentOptions) === null || _a === void 0 ? void 0 : _a.interruptAction) === null || _b === void 0 ? void 0 : _b.call(_a, (_c = action.value) !== null && _c !== void 0 ? _c : '')) {\r\n            return;\r\n        }\r\n        if (this.resolve) {\r\n            this.resolve(action.value);\r\n            this.resolve = null;\r\n        }\r\n        if (this.stack.length > 0) {\r\n            let item = this.stack.shift();\r\n            this.applyOptions(item.options, item.resolve);\r\n        }\r\n        else {\r\n            this.hide();\r\n        }\r\n    }\r\n    onTransitionEnd(type, finish) {\r\n        if (type === 'leave' && finish) {\r\n            if (this.refs.mask) {\r\n                this.refs.mask.remove();\r\n            }\r\n            this.el.remove();\r\n        }\r\n        else if (type === 'enter') {\r\n            let input = this.el.querySelector('input');\r\n            if (input) {\r\n                input.focus();\r\n            }\r\n        }\r\n    }\r\n    async onConnected() {\r\n        await flit_1.untilRenderComplete();\r\n        if (this.refs.mask && this.el.previousElementSibling !== this.refs.mask) {\r\n            this.el.before(this.refs.mask);\r\n        }\r\n        this.toCenter();\r\n        if (this.el.tabIndex === 0) {\r\n            this.el.focus();\r\n        }\r\n        flit_1.on(window, 'resize', this.onWindowResize, this);\r\n    }\r\n    onDisconnected() {\r\n        flit_1.off(window, 'resize', this.onWindowResize, this);\r\n    }\r\n    onWindowResize() {\r\n        if (this.opened) {\r\n            this.toCenter();\r\n        }\r\n    }\r\n    toCenter() {\r\n        ff_1.align(this.el, document.documentElement, 'c');\r\n    }\r\n    /** Apply options as current options. */\r\n    applyOptions(options, resolve) {\r\n        this.currentOptions = options;\r\n        this.resolve = resolve;\r\n    }\r\n    /** Add an option to stack. */\r\n    async addOptions(options) {\r\n        let resolve;\r\n        let promise = new Promise(scopedResolve => {\r\n            resolve = scopedResolve;\r\n        });\r\n        if (this.resolve) {\r\n            this.stack.push({\r\n                options,\r\n                resolve: resolve,\r\n            });\r\n        }\r\n        else {\r\n            this.applyOptions(options, resolve);\r\n            this.show();\r\n        }\r\n        return promise;\r\n    }\r\n    /** Show current dialog. */\r\n    show() {\r\n        this.opened = true;\r\n        if (this.appendTo) {\r\n            element_1.appendTo(this.el, this.appendTo);\r\n        }\r\n    }\r\n    /** Hide current dialog. */\r\n    hide() {\r\n        this.opened = false;\r\n    }\r\n    /** Trigger specified action manually. */\r\n    triggerAction(value) {\r\n        if (!this.currentOptions || !this.currentOptions.actions) {\r\n            return;\r\n        }\r\n        let action = this.currentOptions.actions.find(action => action.value === value);\r\n        if (action) {\r\n            this.onClickActionButton(action);\r\n        }\r\n    }\r\n};\r\nDialog = __decorate([\r\n    flit_1.define('f-dialog')\r\n], Dialog);\r\nexports.Dialog = Dialog;\r\nclass QuickDialog {\r\n    constructor() {\r\n        this.dialogComponent = null;\r\n    }\r\n    addOptions(options) {\r\n        if (!this.dialogComponent) {\r\n            this.dialogComponent = flit_1.getRenderedAsComponent(flit_1.render(flit_1.html `<f-dialog />`));\r\n        }\r\n        return this.dialogComponent.addOptions(options);\r\n    }\r\n    /** Show default type dialog or add it to dialog stack. */\r\n    show(message, options = {}) {\r\n        return this.addOptions({\r\n            message,\r\n            actions: [{ value: 'ok', text: translations_1.translations.get('ok') }],\r\n            ...options,\r\n        });\r\n    }\r\n    /** Show confirm type dialog or add it to dialog stack. */\r\n    confirm(message, options = {}) {\r\n        return this.addOptions({\r\n            icon: 'confirm',\r\n            message,\r\n            actions: [\r\n                { value: 'cancel', text: translations_1.translations.get('cancel') },\r\n                { value: 'ok', text: translations_1.translations.get('ok'), primary: true },\r\n            ],\r\n            ...options,\r\n        });\r\n    }\r\n    /** Show prompt type dialog or add it to dialog stack. */\r\n    async prompt(message, options = {}) {\r\n        let value = options.defaultValue ? String(options.defaultValue) : '';\r\n        let input;\r\n        let originalInterruptAction = options.interruptAction;\r\n        let messageWithInput = flit_1.html `\n\t\t\t${message}\n\t\t\t<f-input class=\"input\" \n\t\t\t\t.placeholder=${options.placeholder}\n\t\t\t\t.validator=${options.validator}\n\t\t\t\t.type=${options.inputType || 'text'}\n\t\t\t\t.value=${value}\n\t\t\t\t:ref=${async (i) => input = await flit_1.getComponentAsync(i)}\n\t\t\t\t@@input=${(v) => value = v}\n\t\t\t\t@keydown.enter=${() => this.dialogComponent.triggerAction('ok')}\n\t\t\t/>\n\t\t`;\r\n        let btn = await this.addOptions({\r\n            message: messageWithInput,\r\n            actions: [\r\n                { value: 'cancel', text: translations_1.translations.get('cancel') },\r\n                { value: 'ok', text: translations_1.translations.get('ok'), primary: true },\r\n            ],\r\n            ...options,\r\n            interruptAction: (button) => {\r\n                return (originalInterruptAction === null || originalInterruptAction === void 0 ? void 0 : originalInterruptAction(button)) || button === 'ok' && input.valid === false;\r\n            },\r\n        });\r\n        if (btn === 'ok') {\r\n            return value;\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\nexports.QuickDialog = QuickDialog;\r\n/** A quick global API to show dialogs. */\r\nexports.dialog = new QuickDialog();\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Dropdown = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst theme_1 = require(\"../style/theme\");\r\nconst popup_1 = require(\"../bindings/popup\");\r\n/**\r\n * `Dropdown` is abstract class for any component having popup content to show.\r\n * You should extend it to implement some dropdown type components, like `Select`.\r\n  */\r\nclass Dropdown extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.popupBinding = null;\r\n        /** Whether dropdown content is opened. */\r\n        this.opened = false;\r\n        /** Trigger event type. Default value is `click`. */\r\n        this.trigger = 'click';\r\n        /** Whether shows triangle. Default value is `true`. */\r\n        this.triangle = true;\r\n        /**\r\n         * Align position with trigger element.\r\n         * Default value is 'b', means bottom position.\r\n         */\r\n        this.alignPosition = 'b';\r\n        /**\r\n         * Align margin betweens trigger element and popup content.\r\n         * Default value is '3' in pixels.\r\n         */\r\n        this.alignMargin = 3;\r\n        /**\r\n         * Transition to play when begin to show or hide popup content.\r\n         * Default value is fade css transition.\r\n         */\r\n        this.transition = { name: 'fade' };\r\n        /**\r\n         * Delay in milliseconds before showing popup content.\r\n         * Default value is `100`.\r\n         */\r\n        this.showDelay = 100;\r\n        /**\r\n         * Delay in milliseconds before hiding popup content.\r\n         * Default value is `100`.\r\n         */\r\n        this.hideDelay = 100;\r\n    }\r\n    static style() {\r\n        let { mainColor } = theme_1.theme;\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tdisplay: inline-flex;\n\t\t}\n\n\t\t.opened{\n\t\t\tcolor: ${mainColor};\n\t\t}\n\n\t\t.down-icon{\n\t\t\tmargin-right: 6px;\n\t\t}\n\n\t\t.popup{\n\t\t\tpadding: 5px 0;\n\t\t}\n\n\t\t.list{\n\t\t\toverflow-y: auto;\n\t\t\tmax-height: 100%;\n\t\t}\n\t\t`;\r\n    }\r\n    render() {\r\n        let { trigger, triangle, alignPosition, alignMargin, transition, showDelay, hideDelay } = this;\r\n        let toPopup = flit_1.refBinding(popup_1.popup(this.renderPopup.bind(this), { trigger, triangle, alignPosition, alignMargin, transition, showDelay, hideDelay }), this.refBinding.bind(this));\r\n        return flit_1.html `\n\t\t\t<template :class.opened=${this.opened} ${toPopup}>\n\t\t\t\t<slot />\n\t\t\t\t<f-icon class=\"down-icon\" .type=\"down\" />\n\t\t\t</template>\n\t\t`;\r\n    }\r\n    renderPopup() {\r\n        return flit_1.html `\n\t\t\t<f-popup\n\t\t\t\tclass=\"popup\"\n\t\t\t\t.triangle=${this.triangle}\n\t\t\t/>\n\t\t`;\r\n    }\r\n    refBinding(binding) {\r\n        this.popupBinding = binding;\r\n        this.popupBinding.on('openedStateChange', this.setOpened, this);\r\n        this.popupBinding.on('willAlign', this.onWillAlign, this);\r\n    }\r\n    setOpened(opened) {\r\n        this.opened = opened;\r\n        if (opened) {\r\n            this.onPopupOpened();\r\n        }\r\n    }\r\n    onPopupOpened() { }\r\n    onWillAlign() { }\r\n    showPopup() {\r\n        if (this.popupBinding) {\r\n            this.popupBinding.showPopupLater();\r\n        }\r\n    }\r\n    hidePopup() {\r\n        if (this.popupBinding) {\r\n            this.popupBinding.hidePopupLater();\r\n        }\r\n    }\r\n}\r\nexports.Dropdown = Dropdown;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Form = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\n/** `<f-form>` can contain `<f-input>` or `<f-textarea>` and check their valid state in bundle. */\r\nlet Form = class Form extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** All child `<f-input>` or `<f-textarea>`. */\r\n        this.inputs = [];\r\n        /** Whether all input or textare are valid. */\r\n        this.valid = true;\r\n    }\r\n    static style() {\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tdisplay: block;\n\t\t}\n\t\t`;\r\n    }\r\n    /** Register a child `<f-input>` or `<f-textarea>`. */\r\n    register(input) {\r\n        this.inputs.push(input);\r\n        this.valid = this.valid && input.valid !== false;\r\n        input.on('change', this.onInputChange, this);\r\n    }\r\n    onInputChange(_value, valid) {\r\n        if (valid !== this.valid) {\r\n            if (valid) {\r\n                this.valid = this.inputs.every(input => input.valid);\r\n            }\r\n            else {\r\n                this.valid = false;\r\n            }\r\n        }\r\n    }\r\n    /** Validate all child inputs or textareas. */\r\n    validate() {\r\n        for (let input of this.inputs) {\r\n            input.setTouched(true);\r\n        }\r\n    }\r\n    /** Reset valid state for all child inputs or textareas. */\r\n    reset() {\r\n        for (let input of this.inputs) {\r\n            input.setTouched(false);\r\n        }\r\n    }\r\n};\r\nForm = __decorate([\r\n    flit_1.define('f-form')\r\n], Form);\r\nexports.Form = Form;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ColLayout = exports.RowLayout = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\n/**\r\n * `<f-row>` used to do grid layout, can contain several `<f-col>`.\r\n * If available width changes, count of `<f-col>` in one line may be adjusted.\r\n */\r\nlet RowLayout = class RowLayout extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.cols = [];\r\n        /** Column count in one line. */\r\n        this.columnCount = 24;\r\n        /** Gutter betweens columns in pixels. */\r\n        this.gutter = 0;\r\n        /** Column alignment starts from. */\r\n        this.justify = 'start';\r\n    }\r\n    static style() {\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tdisplay: flex;\n\t\t\tflex-wrap: wrap;\n\t\t}\n\t\t`;\r\n    }\r\n    onReady() {\r\n        this.watchImmediately(() => this.justify, (justify) => {\r\n            this.el.style.justifyContent = justify === 'start' ? '' : justify === 'end' ? 'flex-end' : justify;\r\n        });\r\n    }\r\n    /** Register child `<f-col>`. */\r\n    register(col) {\r\n        this.cols.push(col);\r\n    }\r\n    /** Returns whether `col` is the first column. */\r\n    isFirstCol(col) {\r\n        return col === this.cols[0];\r\n    }\r\n    /** Get column count in left. */\r\n    getLeftColumnCount(col) {\r\n        let { columnCount } = this;\r\n        let count = 0;\r\n        for (let c of this.cols) {\r\n            if (c === col) {\r\n                break;\r\n            }\r\n            let span = Math.min(c.span, columnCount);\r\n            let offset = c.offset % columnCount;\r\n            count += span + offset;\r\n        }\r\n        return count;\r\n    }\r\n};\r\nRowLayout = __decorate([\r\n    flit_1.define('f-row')\r\n], RowLayout);\r\nexports.RowLayout = RowLayout;\r\n/** `<f-col>` will be contained inside a `<f-row>` to do grid layout. */\r\nlet ColLayout = class ColLayout extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** Column span, default value is  */\r\n        this.span = 1;\r\n        this.offset = 0;\r\n    }\r\n    onCreated() {\r\n        let row = flit_1.getComponent(this.el.parentElement);\r\n        if (!(row instanceof RowLayout)) {\r\n            throw new Error(`\"<f-col>\" must be included in a \"<f-row>\"`);\r\n        }\r\n        row.register(this);\r\n        this.row = row;\r\n    }\r\n    onUpdated() {\r\n        this.el.style.marginLeft = this.getMarginLeft();\r\n        this.el.style.width = this.getWidth();\r\n    }\r\n    getMarginLeft() {\r\n        let leftColCount = this.row.getLeftColumnCount(this);\r\n        let { columnCount, gutter } = this.row;\r\n        let offset = this.offset % columnCount;\r\n        let isFirstCol = (leftColCount + offset) % columnCount === 0;\r\n        if (offset > 0) {\r\n            return (offset / gutter) * 100 + '%';\r\n        }\r\n        else {\r\n            return isFirstCol ? '0' : gutter + 'px';\r\n        }\r\n    }\r\n    getWidth() {\r\n        let { gutter, columnCount } = this.row;\r\n        let span = Math.min(this.span, columnCount);\r\n        let percent = span / columnCount;\r\n        let gutterPXs = gutter * (span - 1 - (columnCount - 1) * percent);\r\n        return `calc(${percent * 100}% - ${-gutterPXs}px)`;\r\n    }\r\n};\r\nColLayout = __decorate([\r\n    flit_1.define('f-col')\r\n], ColLayout);\r\nexports.ColLayout = ColLayout;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ColumnWidthResizer = void 0;\r\nconst ff_1 = require(\"@pucelle/ff\");\r\nconst flit_1 = require(\"@pucelle/flit\");\r\n/** For `<f-table>` to resize column widths. */\r\nclass ColumnWidthResizer {\r\n    constructor(head, columnContainer, colgroup, columns, minColumnWidth, resizingMaskClassName) {\r\n        /** Column widths array. */\r\n        this.columnWidths = null;\r\n        /** Column widths array when resizeing. */\r\n        this.resizingColumnWidths = null;\r\n        /** Whether column resized. */\r\n        this.columnResized = false;\r\n        /** Cached head client width. */\r\n        this.cachedHeadClientWidth = 0;\r\n        this.head = head;\r\n        this.columnContainer = columnContainer;\r\n        this.colgroup = colgroup;\r\n        this.columns = columns;\r\n        this.minColumnWidth = minColumnWidth;\r\n        this.resizingMaskClassName = resizingMaskClassName;\r\n    }\r\n    /** Update column configuration. */\r\n    setColumns(columns) {\r\n        this.columns = columns;\r\n    }\r\n    /** Update column configuration. */\r\n    setMinColumnWidth(minColumnWidth) {\r\n        this.minColumnWidth = minColumnWidth;\r\n    }\r\n    /**\r\n     * Update column widths from column configuration.\r\n     * Will check available column width and may cause page reflow.\r\n     */\r\n    updatColumnWidthsPrecisely() {\r\n        let headClientWidth = this.head.clientWidth - ff_1.getStyleValueAsNumber(this.head, 'paddingLeft') - ff_1.getStyleValueAsNumber(this.head, 'paddingRight');\r\n        this.cachedHeadClientWidth = headClientWidth;\r\n        this.updatColumnWidthsByAvailableWidth(headClientWidth);\r\n    }\r\n    /** A quick method to update column widths when knows head width is not adjusted. */\r\n    updatColumnWidthsRoughly() {\r\n        this.updatColumnWidthsByAvailableWidth(this.cachedHeadClientWidth);\r\n    }\r\n    /** Update column widths after knows available head width. */\r\n    updatColumnWidthsByAvailableWidth(availableWidth) {\r\n        let widthAndFlexArray = this.columns.map(({ flex, width }, index) => {\r\n            var _a, _b;\r\n            let baseWidthInColumnConfig = Math.max(width || 0, this.minColumnWidth);\r\n            // If column resized, we use the column width percentage to calculate new column width.\r\n            let baseWidth = this.columnResized ? this.columnWidths[index] : baseWidthInColumnConfig;\r\n            let extendFlex = 0;\r\n            let shrinkFlex = 0;\r\n            if (Array.isArray(flex)) {\r\n                extendFlex = (_a = flex[0]) !== null && _a !== void 0 ? _a : 0;\r\n                shrinkFlex = (_b = flex[1]) !== null && _b !== void 0 ? _b : extendFlex;\r\n            }\r\n            else {\r\n                extendFlex = shrinkFlex = flex !== null && flex !== void 0 ? flex : 0;\r\n            }\r\n            return [baseWidth, extendFlex, shrinkFlex];\r\n        });\r\n        let widths = this.calcColumnWidths(widthAndFlexArray, availableWidth, this.minColumnWidth);\r\n        this.columnWidths = widths;\r\n        this.setColumnWidths(widths);\r\n    }\r\n    /**\r\n     * Calculate column widths from `[baseWidth, extendFlex, shrinkFlex]` values in column config.\r\n     * The algorithm is nearly same with the flex layout,\r\n     * except that the total column widths will always equal the available client width,\r\n     * and no column width should less than `minColumnWidth`.\r\n     */\r\n    calcColumnWidths(widthAndFlexArray, clientWidth, minColumnWidth) {\r\n        // Not enough space for even `minColumnWidth`, then average `clientWidth` to each column.\r\n        if (clientWidth < minColumnWidth * widthAndFlexArray.length) {\r\n            return ff_1.repeatForTimes(clientWidth / widthAndFlexArray.length, widthAndFlexArray.length);\r\n        }\r\n        let totalBaseWidth = 0;\r\n        let totalExtendFlex = 0;\r\n        let totalShrinkFlex = 0;\r\n        let widths = ff_1.repeatForTimes(minColumnWidth, widthAndFlexArray.length);\r\n        let excludedIndexSet = new Set();\r\n        for (let [baseWidth, extendFlex, shrinkFlex] of widthAndFlexArray) {\r\n            totalBaseWidth += baseWidth;\r\n            totalExtendFlex += extendFlex;\r\n            totalShrinkFlex += shrinkFlex;\r\n        }\r\n        // If no `flex` set for any column, set `flex` to `1` for all the columns.\r\n        if (totalExtendFlex === 0) {\r\n            totalExtendFlex = widthAndFlexArray.length;\r\n            widthAndFlexArray.forEach(a => a[1] = 1);\r\n        }\r\n        if (totalShrinkFlex === 0) {\r\n            totalShrinkFlex = widthAndFlexArray.length;\r\n            widthAndFlexArray.forEach(a => a[2] = 1);\r\n        }\r\n        while (true) {\r\n            let totalFlex = clientWidth >= totalBaseWidth ? totalExtendFlex : totalShrinkFlex;\r\n            let widthPerFlex = (clientWidth - totalBaseWidth) / totalFlex;\r\n            let moreColumnExcluded = false;\r\n            for (let index = 0; index < widthAndFlexArray.length; index++) {\r\n                if (excludedIndexSet.has(index)) {\r\n                    continue;\r\n                }\r\n                let [baseWidth, extendFlex, shrinkFlex] = widthAndFlexArray[index];\r\n                let flex = widthPerFlex >= 0 ? extendFlex : shrinkFlex;\r\n                let width = flex * widthPerFlex + baseWidth;\r\n                if (width < minColumnWidth) {\r\n                    clientWidth -= minColumnWidth;\r\n                    totalBaseWidth -= minColumnWidth;\r\n                    totalExtendFlex -= flex;\r\n                    excludedIndexSet.add(index);\r\n                    moreColumnExcluded = true;\r\n                }\r\n                else {\r\n                    widths[index] = width;\r\n                }\r\n            }\r\n            if (!moreColumnExcluded) {\r\n                break;\r\n            }\r\n        }\r\n        return widths;\r\n    }\r\n    setColumnWidths(widths) {\r\n        let totalWidth = ff_1.sum(widths);\r\n        for (let index = 0; index < widths.length; index++) {\r\n            let isLastColumn = index === widths.length - 1;\r\n            let percent = widths[index] / totalWidth;\r\n            let col = this.colgroup.children[index];\r\n            col.style.width = percent * 100 + '%';\r\n            if (!isLastColumn) {\r\n                let col = this.columnContainer.children[index];\r\n                col.style.width = percent * 100 + '%';\r\n            }\r\n        }\r\n    }\r\n    /** Called after mouse down at column resizer. */\r\n    onStartResize(e, index) {\r\n        let startX = e.clientX;\r\n        let onMouseMove = (e) => {\r\n            e.preventDefault();\r\n            this.resizeColumnByMovementX(e.clientX - startX, index);\r\n        };\r\n        let onMouseUp = () => {\r\n            if (this.resizingColumnWidths) {\r\n                this.columnWidths = this.resizingColumnWidths;\r\n                this.resizingColumnWidths = null;\r\n            }\r\n            flit_1.off(document, 'mousemove', onMouseMove);\r\n            cursorMask.remove();\r\n            this.columnResized = true;\r\n        };\r\n        let cursorMask = flit_1.render(flit_1.html `<div class=\"${this.resizingMaskClassName}\" />`).getFirstElement();\r\n        document.body.append(cursorMask);\r\n        flit_1.on(document, 'mousemove', onMouseMove);\r\n        flit_1.once(document, 'mouseup', onMouseUp);\r\n    }\r\n    resizeColumnByMovementX(movementX, index) {\r\n        let widths = [...this.columnWidths];\r\n        let needShrink = Math.abs(movementX);\r\n        let moveLeft = movementX < 0;\r\n        let expandIndex = moveLeft ? index + 1 : index;\r\n        let firstShrinkIndex = moveLeft ? index : index + 1;\r\n        // When move to left, we reduce the width of current and previous columns until the `minWidth`,\r\n        // then we add the reduced width to next column.\r\n        // When move to right, we reduce the width of next columns until the `minWidth`,\r\n        // then we add the reduced width to current column.\r\n        for (let i = firstShrinkIndex; (moveLeft ? i >= 0 : i < this.columns.length) && needShrink > 0; moveLeft ? i-- : i++) {\r\n            let width = widths[i];\r\n            let shrink = needShrink;\r\n            if (width - shrink < this.minColumnWidth) {\r\n                shrink = width - this.minColumnWidth;\r\n            }\r\n            widths[i] -= shrink;\r\n            widths[expandIndex] += shrink; // index <= column count - 2\r\n            needShrink -= shrink;\r\n        }\r\n        this.resizingColumnWidths = widths;\r\n        this.setColumnWidths(widths);\r\n    }\r\n}\r\nexports.ColumnWidthResizer = ColumnWidthResizer;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TableStateCacher = void 0;\r\nconst ff_1 = require(\"@pucelle/ff\");\r\nconst remote_store_1 = require(\"../../store/remote-store\");\r\nconst DefaultTableStateOptions = {\r\n    filter: false,\r\n    order: false,\r\n    visibleIndex: false,\r\n    data: false,\r\n    store: false,\r\n    customized: {},\r\n};\r\nclass TableStateCacher {\r\n    constructor(table) {\r\n        this.storagePrefix = 'table_state_';\r\n        this.cacheMap = new Map();\r\n        this.table = table;\r\n    }\r\n    /** Checks whether caches table state in specified name. */\r\n    has(name) {\r\n        return this.cacheMap.has(name) || ff_1.storage.get(this.storagePrefix + name);\r\n    }\r\n    /** Cache current table state. */\r\n    cache(name, options) {\r\n        let state = this.getState(options);\r\n        if (options.toStorage) {\r\n            try {\r\n                ff_1.storage.set(this.storagePrefix + name, state);\r\n            }\r\n            catch (err) {\r\n                console.error(`Can't serialize table cache data!`, state, err);\r\n            }\r\n        }\r\n        this.cacheMap.set(name, state);\r\n    }\r\n    getState(options) {\r\n        let table = this.table;\r\n        let store = this.table.store;\r\n        let state = {};\r\n        options = { ...DefaultTableStateOptions, ...options };\r\n        if (options.filter) {\r\n            state.storeFilter = store.getFilter();\r\n        }\r\n        if (options.order) {\r\n            state.orderName = table.getOrderName();\r\n            state.orderDirection = table.getOrderDirection();\r\n        }\r\n        if (options.visibleIndex) {\r\n            state.visibleIndex = table.getFirstVisibleIndex();\r\n        }\r\n        if (options.data) {\r\n            state.data = store instanceof remote_store_1.RemoteStore ? store.getCache() : store.getFullData();\r\n        }\r\n        if (options.store) {\r\n            state.store = store;\r\n        }\r\n        state.customized = options.customized;\r\n        return state;\r\n    }\r\n    /**\r\n     * Restore table state by it's cached name.\r\n     * Returns customized data with `{}` as default value if restored successfully,\r\n     * Returns `undefined` if have no cache to restore.\r\n     * Will clear the cache after restored.\r\n     */\r\n    restore(name) {\r\n        let table = this.table;\r\n        let store = this.table.store;\r\n        let state = this.cacheMap.get(name);\r\n        if (!state) {\r\n            state = ff_1.storage.get(this.storagePrefix + name);\r\n            if (!state) {\r\n                return undefined;\r\n            }\r\n        }\r\n        if (state.storeFilter !== undefined) {\r\n            store.setFilter(state.storeFilter);\r\n        }\r\n        if (state.orderName !== undefined && state.orderDirection !== undefined) {\r\n            table.setOrder(state.orderName, state.orderDirection);\r\n        }\r\n        if (state.visibleIndex !== undefined) {\r\n            table.setFirstVisibleIndex(state.visibleIndex);\r\n        }\r\n        if (state.data !== undefined) {\r\n            if (store instanceof remote_store_1.RemoteStore) {\r\n                store.setCache(state.data);\r\n            }\r\n            else {\r\n                store.setFullData(state.data);\r\n            }\r\n        }\r\n        if (state.store) {\r\n            table.store = store;\r\n        }\r\n        store.sync();\r\n        this.clear(name);\r\n        return state.customized;\r\n    }\r\n    /** Clear cache with specified name. */\r\n    clear(name) {\r\n        this.cacheMap.delete(name);\r\n        ff_1.storage.delete(this.storagePrefix + name);\r\n    }\r\n}\r\nexports.TableStateCacher = TableStateCacher;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TreeDataNavigator = void 0;\r\nvar TreeDataNavigator;\r\n(function (TreeDataNavigator) {\r\n    function moveArrowUp(data, indices) {\r\n        if (data.length === 0) {\r\n            return [];\r\n        }\r\n        if (indices.length === 0) {\r\n            indices = [0];\r\n        }\r\n        if (correctIndices(data, indices)) {\r\n            return indices;\r\n        }\r\n        // Moves to parent node.\r\n        if (indices[indices.length - 1] <= 0) {\r\n            indices.pop();\r\n            // Move to bottom most if reaches top edge\r\n            if (indices.length === 0) {\r\n                while (true) {\r\n                    let childData = getChildDataByIndices(data, indices);\r\n                    if (childData && childData.length > 0) {\r\n                        indices.push(childData.length - 1);\r\n                    }\r\n                    else {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Moves to last available position deep inside previous node.\r\n        else {\r\n            indices[indices.length - 1]--;\r\n            while (true) {\r\n                let childData = getChildDataByIndices(data, indices);\r\n                if (childData && childData.length > 0) {\r\n                    indices.push(childData.length - 1);\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return indices;\r\n    }\r\n    TreeDataNavigator.moveArrowUp = moveArrowUp;\r\n    function moveArrowDown(data, indices) {\r\n        var _a;\r\n        if (data.length === 0) {\r\n            return [];\r\n        }\r\n        if (indices.length === 0) {\r\n            return [0];\r\n        }\r\n        if (correctIndices(data, indices)) {\r\n            return indices;\r\n        }\r\n        // Moves to first child node.\r\n        if ((((_a = getChildDataByIndices(data, indices)) === null || _a === void 0 ? void 0 : _a.length) || 0) > 0) {\r\n            indices.push(0);\r\n        }\r\n        // Moves to next siblings and may be next sibling of parent node.\r\n        else {\r\n            while (indices.length > 0) {\r\n                if (indices[indices.length - 1] < getSiblingsByIndices(data, indices).length - 1) {\r\n                    indices[indices.length - 1]++;\r\n                    break;\r\n                }\r\n                else {\r\n                    indices.pop();\r\n                }\r\n            }\r\n            //Have at least one node in top level, or it will be handled inside `correctIndices`.\r\n            if (indices.length === 0) {\r\n                indices = [0];\r\n            }\r\n        }\r\n        return indices;\r\n    }\r\n    TreeDataNavigator.moveArrowDown = moveArrowDown;\r\n    function moveArrowLeft(data, indices) {\r\n        if (data.length === 0 || indices.length === 0) {\r\n            return [];\r\n        }\r\n        if (indices.length > 0) {\r\n            indices.pop();\r\n        }\r\n        correctIndices(data, indices);\r\n        return indices;\r\n    }\r\n    TreeDataNavigator.moveArrowLeft = moveArrowLeft;\r\n    function moveArrowRight(data, indices) {\r\n        if (data.length === 0 || indices.length === 0) {\r\n            return [];\r\n        }\r\n        indices.push(0);\r\n        correctIndices(data, indices);\r\n        return indices;\r\n    }\r\n    TreeDataNavigator.moveArrowRight = moveArrowRight;\r\n    /** Returns whether corrected it. */\r\n    function correctIndices(data, indices) {\r\n        let corrected = false;\r\n        // No siblings, move to previous in parent siblings.\r\n        // Happens after data changed much.\r\n        while (indices.length > 0) {\r\n            let siblings = getSiblingsByIndices(data, indices);\r\n            if (siblings) {\r\n                let lastIndex = indices[indices.length - 1];\r\n                if (lastIndex >= siblings.length) {\r\n                    indices[indices.length - 1] = siblings.length - 1;\r\n                    corrected = true;\r\n                }\r\n                break;\r\n            }\r\n            else {\r\n                indices.pop();\r\n                corrected = true;\r\n            }\r\n        }\r\n        return corrected;\r\n    }\r\n    TreeDataNavigator.correctIndices = correctIndices;\r\n    function getItemByIndices(data, indices) {\r\n        if (!indices) {\r\n            return undefined;\r\n        }\r\n        let value = undefined;\r\n        let childData = data;\r\n        for (let index of indices) {\r\n            if (!childData) {\r\n                value = undefined;\r\n                break;\r\n            }\r\n            if (index >= 0 && index < childData.length) {\r\n                value = childData[index];\r\n                childData = value.opened ? value.children || null : null;\r\n            }\r\n        }\r\n        return value;\r\n    }\r\n    TreeDataNavigator.getItemByIndices = getItemByIndices;\r\n    function getSiblingsByIndices(data, indices) {\r\n        if (indices.length === 1) {\r\n            return data;\r\n        }\r\n        let value = getItemByIndices(data, indices.slice(0, -1));\r\n        if ((value === null || value === void 0 ? void 0 : value.opened) && (value === null || value === void 0 ? void 0 : value.children)) {\r\n            return value === null || value === void 0 ? void 0 : value.children;\r\n        }\r\n        return null;\r\n    }\r\n    function getChildDataByIndices(data, indices) {\r\n        if (indices.length === 0) {\r\n            return data;\r\n        }\r\n        let value = getItemByIndices(data, indices);\r\n        if (value === null || value === void 0 ? void 0 : value.opened) {\r\n            return value === null || value === void 0 ? void 0 : value.children;\r\n        }\r\n        return null;\r\n    }\r\n})(TreeDataNavigator = exports.TreeDataNavigator || (exports.TreeDataNavigator = {}));\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IconLoading = exports.Icon = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst icons_1 = require(\"../icons/icons\");\r\nconst ff_1 = require(\"@pucelle/ff\");\r\nconst theme_1 = require(\"../style/theme\");\r\n/** `<f-icon type>` will show a specified type svg icon. */\r\nlet Icon = class Icon extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * Icon type.\r\n         * You may extend icons by `icons.add(...)`.\r\n         */\r\n        this.type = '';\r\n    }\r\n    render() {\r\n        let code = icons_1.icons.get(this.type);\r\n        if (!code) {\r\n            return '';\r\n        }\r\n        let [viewBox, inner] = ff_1.subMatches(code, /<svg viewBox=\"(.+?)\">([\\s\\S]+?)<\\/svg>/)[0];\r\n        let [, , w, h] = viewBox.split(' ');\r\n        let width = theme_1.theme.adjust(Number(w));\r\n        let height = theme_1.theme.adjust(Number(h));\r\n        return flit_1.html `\n\t\t\t<template>\n\t\t\t\t<svg\n\t\t\t\t\tviewBox=${viewBox}\n\t\t\t\t\twidth=${width}\n\t\t\t\t\theight=${height}\n\t\t\t\t\t:html=${inner}\n\t\t\t\t></svg>\n\t\t\t</template>\n\t\t`;\r\n    }\r\n};\r\nIcon.style = flit_1.css `\n\t:host{\n\t\tdisplay: inline-flex;\n\t\tstroke: currentColor;\n\t\tfill: none;\n\t\tmargin: auto 0;\n\t\tvertical-align: middle;\n\n\t\tsvg{\n\t\t\tmargin: auto;\n\t\t}\n\t}\n\t`;\r\nIcon = __decorate([\r\n    flit_1.define('f-icon')\r\n], Icon);\r\nexports.Icon = Icon;\r\n/**\r\n * `<f-icon-loading>` will show a specified type svg icon,\r\n * and make it keep ratate when it's `loading` state is `true`.\r\n */\r\nlet IconLoading = class IconLoading extends Icon {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** Loading icon type. Default value is `loading`. */\r\n        this.type = 'refresh';\r\n        /** Whether in loading state. */\r\n        this.loading = false;\r\n        /**\r\n         * Whether is playing animation.\r\n         * May keep playing for a little while after stop loading.\r\n         */\r\n        this.playing = false;\r\n    }\r\n    onCreated() {\r\n        this.watchImmediately(() => this.loading, (value) => {\r\n            if (value && !this.playing) {\r\n                this.play();\r\n                this.playing = true;\r\n            }\r\n        });\r\n    }\r\n    play() {\r\n        let fn = (value) => {\r\n            this.el.style.transform = `rotate(${value}deg)`;\r\n        };\r\n        // Playing web animation will cause svg icon becomes fuzzy.\r\n        ff_1.animateInterpolatedValue(fn, 0, 360, 1000, 'linear').promise.then(() => {\r\n            if (this.loading) {\r\n                this.play();\r\n            }\r\n            else {\r\n                this.playing = false;\r\n            }\r\n        });\r\n    }\r\n};\r\nIconLoading.style = flit_1.css `\n\t:host{\n\t\tdisplay: inline-flex;\n\t\tstroke: currentColor;\n\t\tfill: none;\n\t\tmargin: auto 0;\n\t\tvertical-align: top;\n\t\tposition: relative;\n\t}`;\r\nIconLoading = __decorate([\r\n    flit_1.define('f-icon-loading')\r\n], IconLoading);\r\nexports.IconLoading = IconLoading;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Textarea = exports.Input = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst tooltip_1 = require(\"../bindings/tooltip\");\r\nconst theme_1 = require(\"../style/theme\");\r\nconst form_1 = require(\"./form\");\r\n/**\r\n * `<f-input>` works just like a `<input type=\"text\">`,\r\n * you can also set validator to validate it's value, or set customized error message.\r\n */\r\nlet Input = class Input extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** When in composition inputting. */\r\n        this.inCompositionInputting = false;\r\n        /** Input type, same with `<input type=...>`. */\r\n        this.type = 'text';\r\n        /** Whether input was touched, error messages only appear after touched. */\r\n        this.touched = false;\r\n        /** Whether current input is valid, be `null` if not validated yet. */\r\n        this.valid = null;\r\n        /** Placeholder when input is empty. */\r\n        this.placeholder = '';\r\n        /** Current value. */\r\n        this.value = '';\r\n        /** To validate current value, returns an error message or `null` if passes. */\r\n        this.validator = null;\r\n        /** Custom error message. */\r\n        this.error = '';\r\n        /** Whether show error on a tooltip, so it doesn't need to leave a space for error message. */\r\n        this.errorInTooltip = false;\r\n    }\r\n    static style() {\r\n        let { adjust, adjustFontSize, errorColor, borderColor, backgroundColor, mainColor, successColor, focusBlurRadius } = theme_1.theme;\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tdisplay: inline-block;\n\t\t\tvertical-align: top;\n\t\t\tposition: relative;\n\t\t\twidth: ${adjust(200)}px;\n\t\t\theight: ${adjust(28)}px;\n\t\t\tbackground: ${backgroundColor.toMiddle(5)};\n\t\t\tbox-shadow: inset 0 -1px 0 0 ${borderColor};\n\t\t}\n\n\t\tinput, textarea{\n\t\t\twidth: 100%;\n\t\t\theight: 100%;\n\t\t\tborder: none;\n\t\t\tbackground: none;\n\t\t\t\n\t\t\t&:focus{\n\t\t\t\tbox-shadow: 0 0 ${focusBlurRadius}px ${mainColor.alpha(0.5)};\n\t\t\t}\n\t\t}\n\n\t\tinput{\n\t\t\theight: 100%;\n\t\t\tpadding: 0 0 0 ${adjust(8)}px;\n\t\t}\n\n\t\ttextarea{\n\t\t\tline-height: ${adjust(20)}px;\n\t\t\tpadding: ${adjust(4)}px ${adjust(8)}px;\n\t\t}\n\n\t\t.valid{\n\t\t\tbox-shadow: inset 0 -1px 0 0 ${successColor};\n\n\t\t\tinput, textarea{\n\t\t\t\tpadding-right: ${adjust(28)}px;\n\n\t\t\t\t&:focus{\n\t\t\t\t\tbox-shadow: 0 0 ${focusBlurRadius}px ${successColor.alpha(0.5)};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t.invalid{\n\t\t\tbox-shadow: inset 0 -1px 0 0 ${errorColor};\n\n\t\t\tinput, textarea{\n\t\t\t\tpadding-right: ${adjust(28)}px;\n\n\t\t\t\t&:focus{\n\t\t\t\t\tbox-shadow: 0 0 ${focusBlurRadius}px ${errorColor.alpha(0.5)};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t.valid-icon{\n\t\t\tposition: absolute;\n\t\t\ttop: 0;\n\t\t\tbottom: 0;\n\t\t\tright: 6px;\n\t\t\tcolor: ${successColor};\n\t\t}\n\n\t\t.error{\n\t\t\tposition: absolute;\n\t\t\tleft: 0;\n\t\t\ttop: 100%;\n\t\t\tfont-size: ${adjustFontSize(13)}px;\n\t\t\tline-height: ${adjust(22)}px;\n\t\t\tcolor: ${errorColor};\n\t\t}\n\t\t`;\r\n    }\r\n    onCreated() {\r\n        this.validate();\r\n        let form = flit_1.getClosestComponentOfType(this.el, form_1.Form);\r\n        if (form) {\r\n            form.register(this);\r\n        }\r\n    }\r\n    render() {\r\n        let errorTip = this.errorInTooltip && this.error && this.touched\r\n            ? tooltip_1.tooltip(this.error, { type: 'error' })\r\n            : null;\r\n        return flit_1.html `\n\t\t\t<template\n\t\t\t\t:class.valid=${this.touched && this.valid}\n\t\t\t\t:class.invalid=${this.touched && this.valid === false}\n\t\t\t>\n\t\t\t\t<input type=${this.type}\n\t\t\t\t\t.placeholder=${this.placeholder || ''}\n\t\t\t\t\t.value=${this.value}\n\t\t\t\t\t:ref=\"input\"\n\t\t\t\t\t${errorTip}\n\t\t\t\t\t@blur=${this.onBlur}\n\t\t\t\t\t@compositionstart=${this.onCompositionStart}\n\t\t\t\t\t@compositionend=${this.onCompositionEnd}\n\t\t\t\t\t@input=${this.onInput}\n\t\t\t\t\t@change=${this.onChange}\n\t\t\t\t/>\n\t\t\t\t${this.touched && this.valid ? flit_1.html `<f-icon class=\"valid-icon\" .type=\"checked\" />` : ''}\n\t\t\t\t${this.touched && this.error && !this.errorInTooltip ? flit_1.html `<div class=\"error\">${this.error}</div>` : ''}\n\t\t\t</template>\n\t\t`;\r\n    }\r\n    onBlur() {\r\n        this.touched = true;\r\n        // Validate after change event is not enough.\r\n        // We clear error message after input,\r\n        // So may still not valid even though not changed.\r\n        this.validate();\r\n    }\r\n    onCompositionStart() {\r\n        this.inCompositionInputting = true;\r\n    }\r\n    onCompositionEnd() {\r\n        this.inCompositionInputting = false;\r\n        this.onInput();\r\n    }\r\n    onInput() {\r\n        if (this.inCompositionInputting) {\r\n            return;\r\n        }\r\n        let value = this.refs.input.value;\r\n        if (this.validator) {\r\n            this.valid = null;\r\n            this.error = '';\r\n        }\r\n        this.emit('input', value);\r\n    }\r\n    onChange() {\r\n        let input = this.refs.input;\r\n        let value = this.value = input.value;\r\n        this.validate();\r\n        this.emit('change', value, this.valid);\r\n    }\r\n    validate() {\r\n        if (this.validator) {\r\n            this.error = this.validator(this.value);\r\n            this.valid = !this.error;\r\n        }\r\n    }\r\n    /** Set `touched` property. */\r\n    setTouched(touched) {\r\n        this.touched = touched;\r\n    }\r\n};\r\nInput = __decorate([\r\n    flit_1.define('f-input')\r\n], Input);\r\nexports.Input = Input;\r\n/**\r\n * `<f-textarea>` works just like a `<textarea>`,\r\n * you can also set validator to validate it's value, or set customized error message.\r\n */\r\nlet Textarea = class Textarea extends Input {\r\n    static style() {\r\n        return flit_1.css `\n\t\t:host{\n\t\t\theight: auto;\n\t\t}\n\t\t`.extends(super.style());\r\n    }\r\n    render() {\r\n        return flit_1.html `\n\t\t\t<textarea\n\t\t\t\tplaceholder=${this.placeholder}\n\t\t\t\t.value=${this.value}\n\t\t\t\t:ref=\"input\"\n\t\t\t\t:class.valid=${this.touched && this.valid === true}\n\t\t\t\t:class.invalid=${this.touched && this.valid === false}\n\t\t\t\t@focus=${this.onBlur}\n\t\t\t\t@input=${this.onInput}\n\t\t\t\t@change=${this.onChange}\n\t\t\t/>\n\t\t`;\r\n    }\r\n};\r\nTextarea = __decorate([\r\n    flit_1.define('f-textarea')\r\n], Textarea);\r\nexports.Textarea = Textarea;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.List = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst theme_1 = require(\"../style/theme\");\r\nconst ff_1 = require(\"@pucelle/ff\");\r\nconst tooltip_1 = require(\"../bindings/tooltip\");\r\nconst tree_data_navigator_1 = require(\"./helpers/tree-data-navigator\");\r\n/**\r\n * `<f-list>` will render data items to a list,\r\n * and provide single or multiple selection.\r\n * It shouldn't include too many levels, since it doesn't have overflow setting like `f-tree`.\r\n */\r\nlet List = class List extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** Selected indices by keyboard navigation. */\r\n        this.treeNavigationIndices = [];\r\n        /** Whether watching keyboard navigation events. */\r\n        this.watchingKeyBoardNavigation = false;\r\n        /** List type:\r\n         * `selection`: provide single item or multiple items selection with a checkbox icon.\r\n         * `navigation`: provide single item navigation with a vertical line icon.\r\n         * Default value is `selection`.\r\n         */\r\n        this.type = 'selection';\r\n        /**\r\n         * Whether each items selectable, only for type `selection`.\r\n         * Default value is `false`.\r\n         */\r\n        this.selectable = false;\r\n        /**\r\n         * Whether can select multiple items, only for type `selection`.\r\n         * Default value is `false`.\r\n         */\r\n        this.multipleSelect = false;\r\n        /** Input data list. */\r\n        this.data = [];\r\n        /** Indicates current select values. */\r\n        this.selected = [];\r\n        /**\r\n         * Unique active value for `navigation` type.\r\n         * If this value set when initializing, will make the associated item visible.\r\n         * Otherwise you can call `ensureActiveItemVisible()` to do same thing.\r\n         */\r\n        this.active = null;\r\n        /** If specified, when the element get focus, you can use keyboard arrow keys to navigate inside current list. */\r\n        this.navigateFrom = null;\r\n    }\r\n    static style() {\r\n        let { mainColor, adjust, borderColor, adjustFontSize } = theme_1.theme;\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tdisplay: block;\n\t\t\tborder-bottom: 1px solid ${borderColor.alpha(0.4)};\n\t\t}\n\t\t\n\t\t.option{\n\t\t\tposition: relative;\n\t\t\tdisplay: flex;\n\t\t\tpadding-top: ${adjust(2)}px;\n\t\t\tpadding-bottom: ${adjust(2)}px;\n\t\t\tcursor: pointer;\n\t\t\tborder-top: 1px solid ${borderColor.alpha(0.4)};\n\n\t\t\t&:first-child{\n\t\t\t\tborder-top: none;\n\t\t\t}\n\n\t\t\t&:hover{\n\t\t\t\tcolor: ${mainColor};\n\t\t\t}\n\n\t\t\t&.selected{\n\t\t\t\tcolor: ${mainColor};\n\t\t\t}\n\n\t\t\t&.active{\n\t\t\t\tcolor: ${mainColor};\n\n\t\t\t\t&::after{\n\t\t\t\t\tcontent: '';\n\t\t\t\t\tposition: absolute;\n\t\t\t\t\ttop: ${adjust(3)}px;\n\t\t\t\t\tbottom: ${adjust(3)}px;\n\t\t\t\t\tright: 0;\n\t\t\t\t\twidth: 2px;\n\t\t\t\t\tbackground: ${mainColor.alpha(0.8)};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t&.arrow-selected{\n\t\t\t\tbackground-color: ${mainColor.alpha(0.1)};\n\t\t\t}\n\t\t}\n\n\t\t.toggle{\n\t\t\tdisplay: flex;\n\t\t\twidth: ${adjust(22)}px;\n\t\t\topacity: 0.7;\n\t\t}\n\n\t\t.icon{\n\t\t\tdisplay: flex;\n\t\t\twidth: ${adjust(22)}px;\n\t\t}\n\n\t\t.text{\n\t\t\tflex: 1;\n\t\t\tmin-width: 0;\n\t\t\tpadding-right: 4px;\n\t\t\twhite-space: nowrap;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\n\t\t.selected-icon{\n\t\t\tmargin: 0 ${adjust(6)}px;\n\t\t}\n\n\t\t.subsection{\n\t\t\tpadding-left: ${adjust(22)}px;\n\t\t\tpadding-bottom: ${adjust(4)}px;\n\t\t\toverflow: hidden;\n\t\t\tfont-size: ${adjustFontSize(13)}px;\n\n\t\t\t.option{\n\t\t\t\tpadding-top: 0;\n\t\t\t\tpadding-bottom: 0;\n\t\t\t\tborder-top: none;\n\t\t\t\tline-height: ${adjust(26)}px;\n\t\t\t}\n\n\t\t\t.subsection{\n\t\t\t\tpadding-top: 0;\n\t\t\t}\n\n\t\t\t.subsection:not(:last-child){\n\t\t\t\tpadding-bottom: ${adjust(3)}px;\n\t\t\t\tmargin-bottom: ${adjust(3)}px;\n\t\t\t\tborder-bottom: 1px solid ${borderColor.alpha(0.4)};\n\t\t\t}\n\n\t\t\t.subsection:last-child{\n\t\t\t\tpadding-bottom: 0;\n\t\t\t\tmargin-bottom: 0;\n\t\t\t}\n\t\t}\n\t\t`;\r\n    }\r\n    render() {\r\n        return flit_1.html `${this.renderOptions(this.data, this.treeNavigationIndices)}`;\r\n    }\r\n    renderOptions(items, indices) {\r\n        let siblingsHaveIcon = items.some(item => item.icon);\r\n        let siblingsHaveChildren = items.some(item => item.children);\r\n        let options = flit_1.repeat(items, (item, index) => {\r\n            let childIndices = (indices === null || indices === void 0 ? void 0 : indices[0]) === index ? indices.slice(1) : null;\r\n            return this.renderOption(item, siblingsHaveIcon, siblingsHaveChildren, childIndices);\r\n        });\r\n        return options;\r\n    }\r\n    renderOption(item, siblingsHaveIcon, siblingsHaveChildren, indices) {\r\n        let subsection = item.children && item.opened ? flit_1.html `\n\t\t\t<div class=\"subsection\">${this.renderOptions(item.children, indices)}</div>\n\t\t` : null;\r\n        let tip = item.tip ? tooltip_1.tooltip(item.tip) : null;\r\n        return flit_1.html `\n\t\t\t<div\n\t\t\t\tclass=\"option\"\n\t\t\t\t:class=${this.renderClassName(item)}\n\t\t\t\t:class.arrow-selected=${(indices === null || indices === void 0 ? void 0 : indices.length) === 0}\n\t\t\t\t@click.prevent=${() => this.onClickOption(item)}\n\t\t\t\t${tip}\n\n\t\t\t>\n\t\t\t\t${item.children ? flit_1.html `\n\t\t\t\t\t<div class='toggle' @click.stop=${() => this.toggleOpened(item)}>\n\t\t\t\t\t\t<f-icon .type=${item.opened ? 'triangle-down' : 'triangle-right'} />\n\t\t\t\t\t</div>\n\t\t\t\t` : siblingsHaveChildren ? flit_1.html `\n\t\t\t\t\t<div class='toggle' />\n\t\t\t\t` : ''}\n\n\t\t\t\t${siblingsHaveIcon ? flit_1.html `\n\t\t\t\t\t<div class='icon'>\n\t\t\t\t\t\t<f-icon .type=${item.icon} />\n\t\t\t\t\t</div>\n\t\t\t\t` : ''}\n\t\t\n\t\t\t\t<div class=\"text\">\n\t\t\t\t\t${item.text}\n\t\t\t\t</div>\n\n\t\t\t\t${this.isSelected(item) ? flit_1.html `<f-icon class=\"selected-icon\" .type=\"checked\" />` : ''}\n\t\t\t</div>\n\n\t\t\t${flit_1.toggle(subsection, { properties: ['height', 'marginBottom', 'paddingBottom', 'opacity'] })}\n\t\t`;\r\n    }\r\n    onCreated() {\r\n        if (this.active) {\r\n            this.ensureActiveItemVisible();\r\n        }\r\n    }\r\n    onReady() {\r\n        if (this.navigateFrom) {\r\n            let lastElement = null;\r\n            this.watchImmediately(() => {\r\n                if (typeof this.navigateFrom === 'function') {\r\n                    return this.navigateFrom();\r\n                }\r\n                else {\r\n                    return this.navigateFrom;\r\n                }\r\n            }, navigateFrom => {\r\n                if (navigateFrom) {\r\n                    flit_1.on(navigateFrom, 'keydown', this.moveArrowSelectedByEvent, this);\r\n                    flit_1.on(navigateFrom, 'blur', this.onNavigateFromElementBlur, this);\r\n                }\r\n                else if (lastElement) {\r\n                    flit_1.off(lastElement, 'keydown', this.moveArrowSelectedByEvent, this);\r\n                    flit_1.on(lastElement, 'blur', this.onNavigateFromElementBlur, this);\r\n                }\r\n                lastElement = navigateFrom;\r\n            });\r\n        }\r\n    }\r\n    /** Moves arrow selected by a keyboard event. */\r\n    moveArrowSelectedByEvent(event) {\r\n        if (event.key === 'ArrowUp') {\r\n            this.watchingKeyBoardNavigation = true;\r\n            this.treeNavigationIndices = tree_data_navigator_1.TreeDataNavigator.moveArrowUp(this.data, this.treeNavigationIndices);\r\n        }\r\n        else if (event.key === 'ArrowDown') {\r\n            this.watchingKeyBoardNavigation = true;\r\n            this.treeNavigationIndices = tree_data_navigator_1.TreeDataNavigator.moveArrowDown(this.data, this.treeNavigationIndices);\r\n        }\r\n        else if (event.key === 'ArrowLeft') {\r\n            if (this.watchingKeyBoardNavigation) {\r\n                this.treeNavigationIndices = tree_data_navigator_1.TreeDataNavigator.moveArrowLeft(this.data, this.treeNavigationIndices);\r\n            }\r\n        }\r\n        else if (event.key === 'ArrowRight') {\r\n            if (this.watchingKeyBoardNavigation && this.treeNavigationIndices) {\r\n                let item = tree_data_navigator_1.TreeDataNavigator.getItemByIndices(this.data, this.treeNavigationIndices);\r\n                if (item && !item.opened && item.children) {\r\n                    this.toggleOpened(item);\r\n                    this.treeNavigationIndices = tree_data_navigator_1.TreeDataNavigator.moveArrowRight(this.data, this.treeNavigationIndices);\r\n                }\r\n            }\r\n        }\r\n        else if (event.key === 'Enter') {\r\n            if (this.watchingKeyBoardNavigation && this.treeNavigationIndices) {\r\n                let item = tree_data_navigator_1.TreeDataNavigator.getItemByIndices(this.data, this.treeNavigationIndices);\r\n                if (item) {\r\n                    this.onClickOption(item);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this.watchingKeyBoardNavigation = false;\r\n            this.treeNavigationIndices = [];\r\n        }\r\n    }\r\n    onNavigateFromElementBlur() {\r\n        this.watchingKeyBoardNavigation = false;\r\n        this.treeNavigationIndices = [];\r\n    }\r\n    renderClassName(item) {\r\n        if (this.type === 'navigation') {\r\n            if (this.active === item.value) {\r\n                return 'active';\r\n            }\r\n        }\r\n        else {\r\n            if (this.isSelected(item)) {\r\n                return 'selected';\r\n            }\r\n        }\r\n        return '';\r\n    }\r\n    isSelected(item) {\r\n        return this.selected.includes(item.value);\r\n    }\r\n    onClickOption(item) {\r\n        if (this.type === 'navigation') {\r\n            this.active = item.value;\r\n            this.emit('navigate', item.value);\r\n        }\r\n        else if (this.selectable) {\r\n            if (this.multipleSelect) {\r\n                if (this.selected.includes(item.value)) {\r\n                    ff_1.remove(this.selected, item.value);\r\n                }\r\n                else {\r\n                    ff_1.add(this.selected, item.value);\r\n                }\r\n            }\r\n            else {\r\n                this.selected = [item.value];\r\n            }\r\n            this.emit('select', this.selected);\r\n        }\r\n        else {\r\n            this.emit('click', item.value);\r\n        }\r\n    }\r\n    toggleOpened(item) {\r\n        if (item.children) {\r\n            item.opened = !item.opened;\r\n        }\r\n    }\r\n    /** Open sub list recursively to make sure active item becomes visible. */\r\n    ensureActiveItemVisible() {\r\n        if (this.active) {\r\n            this.ensureActiveItemVisibleRecursively(this.data);\r\n        }\r\n    }\r\n    ensureActiveItemVisibleRecursively(items) {\r\n        return items.some(item => {\r\n            if (item.value === this.active) {\r\n                return true;\r\n            }\r\n            if (item.children) {\r\n                let hasActiveChildItem = this.ensureActiveItemVisibleRecursively(item.children);\r\n                if (hasActiveChildItem) {\r\n                    item.opened = true;\r\n                }\r\n            }\r\n            return item.opened;\r\n        });\r\n    }\r\n};\r\nList = __decorate([\r\n    flit_1.define('f-list')\r\n], List);\r\nexports.List = List;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar Loader_1;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Loader = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst theme_1 = require(\"../style/theme\");\r\n/** `<f-loader>` shows an loading animation to indicate resource is loading. */\r\nlet Loader = Loader_1 = class Loader extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * Size of loader, one of `small | medium | large`.\r\n         * Default value is `medium`.\r\n         */\r\n        this.size = 'medium';\r\n        /**\r\n         * Whether work as a cover to cover whole parent.\r\n         * Default value is `false`.\r\n         */\r\n        this.asCover = false;\r\n        /** How many round per second. */\r\n        this.speed = 0.6;\r\n    }\r\n    static style() {\r\n        let { mainColor, backgroundColor } = theme_1.theme;\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tdisplay: inline-block;\n\t\t\tvertical-align: top;\n\t\t\tcolor: ${mainColor};\n\t\t}\n\n\t\t.as-cover{\n\t\t\tposition: absolute;\n\t\t\tleft: 0;\n\t\t\ttop: 0;\n\t\t\tright: 0;\n\t\t\tbottom: 0;\n\t\t\tz-index: 10;\n\t\t\tbackground: ${backgroundColor.alpha(0.9)};\n\t\t\tdisplay: flex;\n\t\t\tflex-direction: column;\n\t\t\tjustify-content: center;\n\t\t\talign-items: center;\n\t\t\ttext-align: center;\n\t\t}\n\n\t\tsvg{\n\t\t\tmargin: auto;\n\t\t}\n\n\t\tpath{\n\t\t\tstroke: currentColor;\n\t\t\tfill: none;\n\t\t\tstroke-linecap: square;\n\t\t}\n\n\t\t.bg{\n\t\t\tstroke-opacity: 0.3;\n\t\t}\n\t\t`;\r\n    }\r\n    render() {\r\n        let strokeWidth = this.getStrokeWidth();\r\n        let halfWidth = strokeWidth / 2;\r\n        let size = Loader_1.sizes[this.size];\r\n        let d = `M${halfWidth} ${halfWidth} H${size - halfWidth} V${size - halfWidth} H${halfWidth}Z`;\r\n        let dashArray = `${size - strokeWidth} ${(size - strokeWidth) * 3}`;\r\n        return flit_1.html `\n\t\t\t<template\n\t\t\t\t:class=\"size-${this.size}\"\n\t\t\t\t:class.as-cover=${this.asCover}\n\t\t\t\t:style.width.px=${size}\n\t\t\t\t:style.height.px=${size}\n\t\t\t\t:style.animation=\"loader-snake-${this.size} 2s linear infinite\"\n\t\t\t>\n\t\t\t\t<svg viewBox=\"0 0 ${size} ${size}\" width=${size} height=${size}>\n\t\t\t\t\t<path class=\"bg\" d=${d} style=\"stroke-width: ${strokeWidth}\" />\n\t\t\t\t\t<path :ref=\"snake\" d=${d} style=\"stroke-width: ${strokeWidth}; stroke-dasharray: ${dashArray};\" />\n\t\t\t\t</svg>\n\t\t\t</template>\n\t\t`;\r\n    }\r\n    getStrokeWidth() {\r\n        return Loader_1.strokeWidths[this.size];\r\n    }\r\n    onReady() {\r\n        let strokeWidth = this.getStrokeWidth();\r\n        let size = Loader_1.sizes[this.size];\r\n        this.refs.snake.animate([\r\n            {\r\n                strokeDashoffset: 0,\r\n            },\r\n            {\r\n                strokeDashoffset: -(size - strokeWidth) * 4,\r\n            }\r\n        ], {\r\n            duration: 1000 / this.speed,\r\n            iterations: Infinity\r\n        });\r\n    }\r\n};\r\nLoader.sizes = {\r\n    small: 18,\r\n    medium: 28,\r\n    large: 48,\r\n};\r\nLoader.strokeWidths = {\r\n    small: 3,\r\n    medium: 4,\r\n    large: 5,\r\n};\r\nLoader = Loader_1 = __decorate([\r\n    flit_1.define('f-loader')\r\n], Loader);\r\nexports.Loader = Loader;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Menu = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst theme_1 = require(\"../style/theme\");\r\nconst popup_1 = require(\"./popup\");\r\n/** `<f-menu>` shows a menu with a list beside it's trigger element. */\r\nlet Menu = class Menu extends popup_1.Popup {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** Menu title. */\r\n        this.title = '';\r\n        this.defaultPopupOptions = {\r\n            // `trigger` not work here because when need to handle trigger, current component is not created.\r\n            alignPosition: 'bc',\r\n            fixTriangle: true,\r\n        };\r\n    }\r\n    static style() {\r\n        let { adjust, adjustFontSize, textColor } = theme_1.theme;\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tmin-width: ${adjust(180)}px;\n\t\t\tmax-width: ${adjust(320)}px;\n\t\t\tpadding: ${adjust(8)}px ${adjust(16)}px;\n\n\t\t\tf-list{\n\t\t\t\tborder-bottom: none;\n\t\t\t\tmax-height: 100%;\n\t\t\t\toverflow-y: auto;\n\t\t\t}\n\t\t}\n\n\t\t.triangle{\n\t\t\tleft: ${adjust(15)}px;\n\t\t}\n\n\t\t.header{\n\t\t\tdisplay: flex;\n\t\t\tline-height: ${adjust(22)}px;\n\t\t\theight: ${adjust(28) + 1}px;\n\t\t\tfont-size: ${adjustFontSize(13)}px;\n\t\t\tpadding-bottom: ${adjust(6)}px;\n\t\t\tborder-bottom: 1px solid ${textColor.alpha(0.8)};\n\t\t}\n\n\t\t.title{\n\t\t\tflex: 1;\n\t\t\tmin-width: 0;\n\t\t\tpadding: 0 ${adjust(16)}px 0 0;\n\t\t\tfont-weight: bold;\n\t\t\toverflow: hidden;\n\t\t\twhite-space: nowrap;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\t\t`.extends(super.style());\r\n    }\r\n    render() {\r\n        return flit_1.html `\n\t\t\t<f-popup>\t\n\t\t\t\t${this.renderHead()}\n\t\t\t\t<slot />\n\t\t\t</f-popup>\n\t\t`.extends(super.render());\r\n    }\r\n    renderHead() {\r\n        if (this.title) {\r\n            return flit_1.html `\n\t\t\t<div class=\"header\">\n\t\t\t\t<div class=\"title\">${this.title}</div>\n\t\t\t</div>\n\t\t\t`;\r\n        }\r\n        return '';\r\n    }\r\n};\r\nMenu = __decorate([\r\n    flit_1.define('f-menu')\r\n], Menu);\r\nexports.Menu = Menu;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Modal = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst theme_1 = require(\"../style/theme\");\r\nconst ff_1 = require(\"@pucelle/ff\");\r\nconst element_1 = require(\"../utils/element\");\r\n/**\r\n * `<f-modal>` shows content and help to complete a child task in a popup modal.\r\n *\r\n * `:slot=\"action\"` - Add action buttons and show them at head.\r\n */\r\nlet Modal = class Modal extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** Modal title. */\r\n        this.title = '';\r\n        /** Whether modal opened. */\r\n        this.opened = true;\r\n        /** Where to append current dialog. */\r\n        this.appendTo = 'body';\r\n    }\r\n    static style() {\r\n        let { adjustFontSize, textColor, popupBorderRadius, popupShadowBlurRadius, popupBackgroundColor, popupShadowColor, adjust } = theme_1.theme;\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tposition: fixed;\n\t\t\tdisplay: flex;\n\t\t\tflex-direction: column;\n\t\t\tz-index: 1000;\t// Same with popup\n\t\t\tborder-radius: ${popupBorderRadius}px;\n\t\t\tbox-shadow: 0 0 ${popupShadowBlurRadius}px ${popupShadowColor};\n\t\t\tbackground: ${popupBackgroundColor};\n\t\t\tmax-width: 100%;\n\t\t\tmax-height: 100%;\n\t\t\tpadding: ${adjust(8)}px ${adjust(16)}px;\n\t\t\toverflow: hidden;\n\t\t}\n\n\t\t.mask{\n\t\t\tposition: fixed;\n\t\t\tz-index: 1000;\n\t\t\tleft: 0;\n\t\t\ttop: 0;\n\t\t\twidth: 100%;\n\t\t\theight: 100%;\n\t\t\tbackground: rgba(0, 0, 0, 0.5);\n\t\t}\n\n\t\t.header{\n\t\t\tdisplay: flex;\n\t\t\tflex: none;\n\t\t\theight: ${adjust(34) + 1}px;\n\t\t\tfont-size: ${adjustFontSize(13)}px;\n\t\t\tpadding-bottom: ${adjust(6)}px;\n\t\t\tborder-bottom: 1px solid ${textColor.alpha(0.8)};\n\t\t\tmargin-bottom: ${adjust(8)}px;\n\t\t}\n\n\t\t.title{\n\t\t\tflex: 1;\n\t\t\tmin-width: 0;\n\t\t\tfont-weight: bold;\n\t\t\toverflow: hidden;\n\t\t\twhite-space: nowrap;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\n\t\t.close{\n\t\t\tdisplay: flex;\n\t\t\twidth: ${adjust(28)}px;\n\t\t\theight: ${adjust(28)}px;\n\t\t\tmargin-top: -${adjust(-6)}px;\n\t\t\tmargin-right: ${adjust(-9)}px;\n\t\t\tcursor: pointer;\n\n\t\t\t&:active{\n\t\t\t\ttransform: translateY(1px);\n\t\t\t}\n\n\t\t\tf-icon{\n\t\t\t\tmargin: auto;\n\t\t\t}\n\t\t}\n\n\t\t.actions{\n\t\t\tmargin-left: ${adjust(16)}px;\n\n\t\t\tbutton{\n\t\t\t\tmargin-left: ${adjust(8)}px;\n\t\t\t}\n\t\t}\n\n\t\t.content{\n\t\t\tflex: 1;\n\t\t\tmin-height: 0;\n\t\t\tdisplay: flex;\n\t\t\tflex-direction: column;\n\t\t\toverflow-y: auto;\n\t\t\tmargin-right: ${adjust(-16)}px;\n\t\t\tpadding-right: ${adjust(16)}px;\n\t\t}\n\t`;\r\n    }\r\n    render() {\r\n        let shouldRenderClose = !this.slots.action;\r\n        return flit_1.html `\n\t\t\t<template\n\t\t\t\ttabindex=\"0\"\n\t\t\t\t${flit_1.show(this.opened, { name: 'fade', enterAtStart: true, onend: this.onTransitionEnd })}\n\t\t\t>\n\t\t\t\t<div class=\"mask\"\n\t\t\t\t\t:ref=\"mask\"\n\t\t\t\t\t${flit_1.show(this.opened, { name: 'fade', enterAtStart: true })}\n\t\t\t\t/>\n\n\t\t\t\t<div class=\"header\">\n\t\t\t\t\t<div class=\"title\">${this.title}</div>\n\n\t\t\t\t\t<div class=\"actions\" :show=${this.slots.action}>\n\t\t\t\t\t\t<slot name=\"action\" />\n\t\t\t\t\t</div>\n\n\t\t\t\t\t${shouldRenderClose ? flit_1.html `\n\t\t\t\t\t\t<div class=\"close\" @click=${this.hide}>\n\t\t\t\t\t\t\t<f-icon .type=\"close\" />\n\t\t\t\t\t\t</div>\n\t\t\t\t\t` : ''}\n\t\t\t\t</div>\n\n\t\t\t\t<div class=\"content\">\n\t\t\t\t\t<slot />\n\t\t\t\t</div>\n\t\t\t</template>\n\t\t`;\r\n    }\r\n    onTransitionEnd(type, finish) {\r\n        if (type === 'leave' && finish) {\r\n            this.el.remove();\r\n            this.onTransitionLeaveEnd();\r\n        }\r\n    }\r\n    onTransitionLeaveEnd() { }\r\n    onConnected() {\r\n        flit_1.untilRenderComplete().then(() => {\r\n            if (this.refs.mask && this.el.previousElementSibling !== this.refs.mask) {\r\n                this.el.before(this.refs.mask);\r\n            }\r\n            this.align();\r\n            flit_1.on(window, 'resize', this.onWindowResize, this);\r\n            let unwatch = ff_1.watchLayout(this.el, 'size', () => this.align());\r\n            this.once('disconnected', unwatch);\r\n        });\r\n    }\r\n    onDisconnected() {\r\n        if (this.refs.mask) {\r\n            this.refs.mask.remove();\r\n        }\r\n        flit_1.off(window, 'resize', this.onWindowResize, this);\r\n    }\r\n    onWindowResize() {\r\n        if (this.opened) {\r\n            this.align();\r\n        }\r\n    }\r\n    align() {\r\n        ff_1.align(this.el, document.documentElement, 'c');\r\n    }\r\n    /**\r\n     * To show the modal, you may `renderComponent` and then call `show()` or append to `body`.\r\n     * If you want render modal as a child element  and append into document automatically,\r\n     * just call `show` in `onConnected`.\r\n     */\r\n    show() {\r\n        this.opened = true;\r\n        if (this.appendTo) {\r\n            element_1.appendTo(this.el, this.appendTo);\r\n        }\r\n    }\r\n    hide() {\r\n        this.opened = false;\r\n    }\r\n};\r\nModal = __decorate([\r\n    flit_1.define('f-modal')\r\n], Modal);\r\nexports.Modal = Modal;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Navigation = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst list_1 = require(\"./list\");\r\nconst theme_1 = require(\"../style/theme\");\r\n/** `<f-navigation>` can navigate to different pages within a navigation tree. */\r\nlet Navigation = class Navigation extends list_1.List {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** Type, always be `navigation`. */\r\n        this.type = 'navigation';\r\n        /** Navigation title. */\r\n        this.title = '';\r\n    }\r\n    static style() {\r\n        let { backgroundColor, adjust, adjustFontSize } = theme_1.theme;\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tpadding: ${adjust(8)}px ${adjust(16)}px;\n\t\t\tborder-bottom: none;\n\t\t\tbackground: ${backgroundColor.toMiddle(9)};\n\t\t\toverflow-y: auto;\n\t\t}\n\n\t\t.title{\n\t\t\tfont-size: ${adjustFontSize(18)}px;\n\t\t\tfont-weight: 300;\n\t\t\tmargin-top: ${adjust(4)}px;\n\t\t\tmargin-bottom: ${adjust(8)}px;\n\t\t}\n\n\t\t`.extends(super.style());\r\n    }\r\n    render() {\r\n        return flit_1.html `\n\t\t\t<tempalte>\n\t\t\t\t${this.title ? flit_1.html `\n\t\t\t\t<div class=\"title\">\n\t\t\t\t\t${this.title}\n\t\t\t\t</div>` : ''}\n\n\t\t\t\t${this.renderOptions(this.data, this.treeNavigationIndices)}\n\t\t\t</tempalte>\n\t\t`;\r\n    }\r\n};\r\nNavigation = __decorate([\r\n    flit_1.define('f-navigation')\r\n], Navigation);\r\nexports.Navigation = Navigation;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.notification = exports.UniqueNotification = exports.QuickNotification = exports.Notification = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst theme_1 = require(\"../style/theme\");\r\nconst ff_1 = require(\"@pucelle/ff\");\r\nconst element_1 = require(\"../utils/element\");\r\n/** `<f-notification>` helps to show a notification list to notify some info. */\r\nlet Notification = class Notification extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.seed = 1;\r\n        this.items = [];\r\n        /** Where to append notification list. */\r\n        this.appendTo = 'body';\r\n    }\r\n    static style() {\r\n        let { infoColor, adjust, successColor, errorColor, warningColor, popupBorderRadius, popupShadowBlurRadius, adjustFontSize, backgroundColor, textColor, popupShadowColor } = theme_1.theme;\r\n        let types = [\r\n            ['info', infoColor],\r\n            ['warning', warningColor],\r\n            ['error', errorColor],\r\n            ['success', successColor]\r\n        ];\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tposition: fixed;\n\t\t\tright: ${adjust(12)}px;\n\t\t\tbottom: ${adjust(12)}px;\n\t\t\tmin-width: ${adjust(280)}px;\n\t\t\tmax-width: ${adjust(480)}px;\n\t\t\tz-index: 1100;\t// Higher than tooltip, dialog, ...\n\t\t\tfont-size: ${adjustFontSize(13)}px;\n\t\t}\n\n\t\t.item{\n\t\t\tposition: relative;\n\t\t\tdisplay: flex;\n\t\t\tmargin-top: ${adjust(12)}px;\n\t\t\tbackground: ${backgroundColor};\n\t\t\tbox-shadow: 0 0 ${popupShadowBlurRadius}px ${popupShadowColor};\n\t\t\tcursor: pointer;\n\t\t\toverflow: hidden;\n\t\t\tborder-radius: ${popupBorderRadius}px;\n\t\t}\n\n\t\t.stripe{\n\t\t\twidth: 4px;\n\t\t}\n\n\t\t.left{\n\t\t\tpadding: ${adjust(16)}px ${adjust(14)}px ${adjust(16)}px ${adjust(16)}px;\n\t\t}\n\n\t\t.type-icon{\n\t\t\tdisplay: block;\n\t\t\twidth: ${adjust(20)}px;\n\t\t\theight: ${adjust(20)}px;\n\n\t\t\tsvg{\n\t\t\t\twidth: ${adjust(20)}px;\n\t\t\t\theight: ${adjust(20)}px;\n\t\t\t}\n\t\t}\n\n\t\t.content{\n\t\t\tflex: 1;\n\t\t\tmin-width: 0;\n\t\t\tpadding: ${adjust(16)}px ${adjust(16)}px ${adjust(8)}px 0;\n\t\t}\n\n\t\t.close{\n\t\t\tdisplay: flex;\n\t\t\twidth: ${adjust(28)}px;\n\t\t\theight: ${adjust(28)}px;\n\t\t\tcolor: ${textColor};\n\n\t\t\tf-icon{\n\t\t\t\tmargin: auto;\n\t\t\t}\n\n\t\t\t&:hover{\n\t\t\t\tcolor: ${textColor.toMiddle(10)};\n\t\t\t}\n\n\t\t\t&:active{\n\t\t\t\ttransform: translateY(1px);\n\t\t\t}\n\t\t}\n\n\t\t.title{\n\t\t\tfont-weight: bold;\n\t\t\tline-height: ${adjust(20)}px;\n\t\t\tmargin-bottom: ${adjust(4)}px;\n\t\t}\n\n\t\t.message{\n\t\t\tflex: 1;\n\t\t\tmin-width: 0;\n\t\t\tline-height: ${adjust(20)}px;\n\t\t\tmargin-bottom: ${adjust(4)}px;\n\t\t\ttext-align: left;\n\t\t\tword-wrap: break-word;\n\n\t\t\ta{\n\t\t\t\tfont-weight: bold;\n\t\t\t}\n\t\t}\n\n\t\t.list{\n\t\t\tmargin: ${adjust(8)}px 0;\n\t\t\tline-height: ${adjust(20)}px;\n\t\t\tlist-style-type: square;\n\t\t\tpadding-left: ${adjust(28)}px;\n\t\t}\n\n\t\t.actions{\n\t\t\tmargin-top: ${adjust(8)}px;\n\t\t}\n\n\t\t.action{\n\t\t\tmargin-right: ${adjust(6)}px;\n\t\t\theight: ${adjust(22)}px;\n\t\t\tline-height: ${20}px;\n\t\t\tpadding: 0 ${adjust(8)}px;\n\t\t}\n\n\t\t${types.map(([type, color]) => flit_1.css `\n\t\t\t.type-${type}{\n\t\t\t\t&:hover{\n\t\t\t\t\tbackground: ${color.mix(backgroundColor, 95)};\n\t\t\t\t}\n\n\t\t\t\t.stripe{\n\t\t\t\t\tbackground: ${color};\n\t\t\t\t}\n\t\t\t}\n\t\t`)}\n\t\t`;\r\n    }\r\n    render() {\r\n        return flit_1.repeat(this.items, (item) => flit_1.html `<div class=\"item\"\n\t\t\t\t:class=\"type-${item.type}\"\n\t\t\t\t@mouseenter=${() => this.onMouseEnter(item)}\n\t\t\t\t@mouseleave=${() => this.onMouseLeave(item)}\n\t\t\t>\n\t\t\t\t<div class=\"stripe\" />\n\n\t\t\t\t<div class=\"left\">\n\t\t\t\t\t<f-icon class=\"type-icon\" .type=${item.type} />\n\t\t\t\t</div>\n\n\t\t\t\t<div class=\"content\">\n\t\t\t\t\t${item.title ? flit_1.html `<div class=\"title\">${item.title}</div>` : ''}\n\n\t\t\t\t\t<div class=\"message\">${item.message}</div>\n\t\t\t\t\t\n\t\t\t\t\t${item.list && item.list.length > 0 ? flit_1.html `\n\t\t\t\t\t\t<ul class=\"list\">\n\t\t\t\t\t\t\t${item.list.map(text => flit_1.html `<li>${text}</li>`)}\n\t\t\t\t\t\t</ul>\n\t\t\t\t\t` : ''}\n\n\t\t\t\t\t${this.renderActions(item)}\n\t\t\t\t</div>\n\n\t\t\t\t<div class=\"close\" @click=${() => this.onClickClose(item)}>\n\t\t\t\t\t<f-icon .type=\"close\" />\n\t\t\t\t</div>\n\t\t\t</div>`, { name: 'fade', enterAtStart: true, onend: this.onTransitionEnd });\r\n    }\r\n    renderActions(item) {\r\n        let actions = item.actions;\r\n        if (actions && actions.length > 0) {\r\n            let results = actions.map(action => flit_1.html `\n\t\t\t\t<button class=\"action\"\n\t\t\t\t\t?primary=${action.primary}\n\t\t\t\t\t@click=${() => this.onClickActionButton(action, item)}>\n\t\t\t\t\t${action.text}\n\t\t\t\t</button>\n\t\t\t`);\r\n            return flit_1.html `<div class=\"actions\">${results}</div>`;\r\n        }\r\n        return '';\r\n    }\r\n    onClickActionButton(action, item) {\r\n        if (action.handler) {\r\n            action.handler();\r\n        }\r\n        this.hide(item.id);\r\n    }\r\n    onMouseEnter(item) {\r\n        item.hover = true;\r\n    }\r\n    onMouseLeave(item) {\r\n        item.hover = false;\r\n        if (!item.timeout) {\r\n            this.hideLater(item);\r\n        }\r\n    }\r\n    onClickClose(item) {\r\n        this.hide(item.id);\r\n    }\r\n    onTransitionEnd(type) {\r\n        if (type === 'leave' && this.items.length === 0) {\r\n            this.el.remove();\r\n        }\r\n    }\r\n    /** Shows a notification and returns it's list. */\r\n    show(options) {\r\n        if (options.id) {\r\n            let item = this.items.find(v => v.id === options.id);\r\n            if (item) {\r\n                Object.assign(item, options);\r\n                this.hideLater(item);\r\n                return options.id;\r\n            }\r\n        }\r\n        let item = {\r\n            id: this.seed++,\r\n            ...options,\r\n            hover: false,\r\n            timeout: null,\r\n        };\r\n        this.items.unshift(item);\r\n        this.hideLater(item);\r\n        if (this.items.length === 1 && this.appendTo) {\r\n            element_1.appendTo(this.el, this.appendTo);\r\n        }\r\n        return item.id;\r\n    }\r\n    hideLater(item) {\r\n        if (item.timeout) {\r\n            item.timeout.cancel();\r\n        }\r\n        item.timeout = new ff_1.Timeout(() => {\r\n            item.timeout = null;\r\n            if (!item.hover) {\r\n                this.hide(item.id);\r\n            }\r\n        }, item.hideDelay || 5000);\r\n    }\r\n    /** Hide notification by it's id. */\r\n    hide(id) {\r\n        let item = this.items.find(v => v.id === id);\r\n        if (item) {\r\n            ff_1.remove(this.items, item);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    /** Hide all notifications. */\r\n    hideAll() {\r\n        this.items = [];\r\n        if (this.items.length === 0) {\r\n            this.el.remove();\r\n        }\r\n    }\r\n};\r\nNotification = __decorate([\r\n    flit_1.define('f-notification')\r\n], Notification);\r\nexports.Notification = Notification;\r\n/** Class to manage a notification list. */\r\nclass QuickNotification {\r\n    constructor() {\r\n        this.noti = null;\r\n    }\r\n    /** Returns a unique notification instance, all notification calls will share a unique notification item. */\r\n    unique() {\r\n        return new UniqueNotification(this);\r\n    }\r\n    showNotification(options) {\r\n        if (!this.noti) {\r\n            this.noti = flit_1.getRenderedAsComponent(flit_1.render(flit_1.html `<f-notification />`));\r\n        }\r\n        return this.noti.show(options);\r\n    }\r\n    /** Shows info type notification, returns it's id. */\r\n    info(message, options = {}) {\r\n        options.type = 'info';\r\n        options.message = message;\r\n        return this.showNotification(options);\r\n    }\r\n    /** Shows warn type notification, returns it's id. */\r\n    warn(message, options = {}) {\r\n        options.type = 'warning';\r\n        options.message = message;\r\n        return this.showNotification(options);\r\n    }\r\n    /** Shows error type notification, returns it's id. */\r\n    error(message, options = {}) {\r\n        options.type = 'error';\r\n        options.message = message;\r\n        return this.showNotification(options);\r\n    }\r\n    /** Shows success type notification, returns it's id. */\r\n    success(message, options = {}) {\r\n        options.type = 'success';\r\n        options.message = message;\r\n        return this.showNotification(options);\r\n    }\r\n    /** Hide notification by it's id. */\r\n    hide(id) {\r\n        return this.noti.hide(id);\r\n    }\r\n    /** Hide all notifications. */\r\n    hideAll() {\r\n        this.noti.hideAll();\r\n    }\r\n}\r\nexports.QuickNotification = QuickNotification;\r\n/** All notification calls will share a unique notification item. */\r\nclass UniqueNotification {\r\n    constructor(raw) {\r\n        this.id = null;\r\n        this.raw = raw;\r\n    }\r\n    overwriteNotificationId(options) {\r\n        if (this.id) {\r\n            options.id = this.id;\r\n        }\r\n    }\r\n    /** Shows info type notification, returns it's id. */\r\n    info(message, options = {}) {\r\n        this.overwriteNotificationId(options);\r\n        return this.id = this.raw.info(message, options);\r\n    }\r\n    /** Shows warn type notification, returns it's id. */\r\n    warn(message, options = {}) {\r\n        this.overwriteNotificationId(options);\r\n        return this.id = this.raw.warn(message, options);\r\n    }\r\n    /** Shows error type notification, returns it's id. */\r\n    error(message, options = {}) {\r\n        this.overwriteNotificationId(options);\r\n        return this.id = this.raw.error(message, options);\r\n    }\r\n    /** Shows success type notification, returns it's id. */\r\n    success(message, options = {}) {\r\n        this.overwriteNotificationId(options);\r\n        return this.id = this.raw.success(message, options);\r\n    }\r\n    /** Hide current notification. */\r\n    hide() {\r\n        if (this.id) {\r\n            return this.raw.hide(this.id);\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\nexports.UniqueNotification = UniqueNotification;\r\n/** A quick global API to show notifications. */\r\nexports.notification = new QuickNotification();\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Popover = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst theme_1 = require(\"../style/theme\");\r\nconst popup_1 = require(\"./popup\");\r\n/**\r\n * `<f-popover>` shows content message in a popup beside it's trigger element.\r\n *\r\n * `:slot=action` - Add action buttons and show them at head.\r\n */\r\nlet Popover = class Popover extends popup_1.Popup {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** Popover title. */\r\n        this.title = '';\r\n        /** Whether shows a close icon to quickly close current popover. */\r\n        this.closable = false;\r\n        this.defaultPopupOptions = {\r\n            // `trigger` not work here because when need to handle trigger, current component is not created.\r\n            alignPosition: 'bc',\r\n            fixTriangle: true,\r\n        };\r\n    }\r\n    static style() {\r\n        let { adjust, adjustFontSize, textColor } = theme_1.theme;\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tpadding: ${adjust(8)}px ${adjust(16)}px;\n\t\t\tmin-width: ${adjust(240)}px;\n\t\t\tmax-width: ${adjust(400)}px;\n\t\t}\n\n\t\t.triangle{\n\t\t\tleft: ${adjust(12)}px;\n\t\t}\n\n\t\t.header{\n\t\t\tdisplay: flex;\n\t\t\tline-height: ${adjust(22)}px;\n\t\t\theight: ${adjust(28) + 1}px;\n\t\t\tfont-size: ${adjustFontSize(13)}px;\n\t\t\tpadding-bottom: ${adjust(6)}px;\n\t\t\tborder-bottom: 1px solid ${textColor.alpha(0.8)};\n\t\t\tmargin-bottom: ${adjust(8)}px;\n\t\t}\n\n\t\t.title{\n\t\t\tflex: 1;\n\t\t\tmin-width: 0;\n\t\t\tfont-weight: bold;\n\t\t\toverflow: hidden;\n\t\t\twhite-space: nowrap;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\n\t\t.close{\n\t\t\tdisplay: flex;\n\t\t\twidth: ${adjust(28)}px;\n\t\t\theight: ${adjust(28)}px;\n\t\t\tmargin-top: ${adjust(-6)}px;\n\t\t\tmargin-right: ${adjust(-9)}px;\n\t\t\tcursor: pointer;\n\n\t\t\t&:active{\n\t\t\t\ttransform: translateY(1px);\n\t\t\t}\n\n\t\t\tf-icon{\n\t\t\t\tmargin: auto;\n\t\t\t}\n\t\t}\n\n\t\t.actions{\n\t\t\tmargin-left: ${adjust(15)}px;\n\n\t\t\tbutton{\n\t\t\t\tmargin-left: ${adjust(6)}px;\n\t\t\t\theight: ${adjust(22)}px;\n\t\t\t\tline-height: ${20}px;\n\t\t\t\tpadding: 0 ${adjust(8)}px;\n\t\t\t}\n\t\t}\n\n\t\t.content{\n\t\t\tline-height: ${adjust(20)}px;\n\t\t\tpadding: ${adjust(4)}px 0;\n\t\t}\n\t\t`.extends(super.style());\r\n    }\r\n    render() {\r\n        return flit_1.html `\n\t\t\t<template>\t\n\t\t\t\t${this.renderHead()}\n\t\t\t\t<div class=\"content\"><slot /></div>\n\t\t\t</template>\n\t\t`.extends(super.render());\r\n    }\r\n    renderHead() {\r\n        if (this.title) {\r\n            let shouldRenderClose = this.closable && !this.slots.action;\r\n            return flit_1.html `\n\t\t\t<div class=\"header\">\n\t\t\t\t<div class=\"title\">${this.title}</div>\n\n\t\t\t\t<div class=\"actions\" :show=${this.slots.action}>\n\t\t\t\t\t<slot name=\"action\" />\n\t\t\t\t</div>\n\n\t\t\t\t${shouldRenderClose ? flit_1.html `\n\t\t\t\t\t<div class=\"close\" @click=${this.close}>\n\t\t\t\t\t\t<f-icon .type=\"close\" />\n\t\t\t\t\t</div>\n\t\t\t\t` : ''}\n\t\t\t</div>\n\t\t\t`;\r\n        }\r\n        return '';\r\n    }\r\n};\r\nPopover = __decorate([\r\n    flit_1.define('f-popover')\r\n], Popover);\r\nexports.Popover = Popover;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Popup = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst theme_1 = require(\"../style/theme\");\r\nconst element_1 = require(\"../utils/element\");\r\n/** `<f-popup>` is the container for popup content. */\r\nlet Popup = class Popup extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * Options to overwrite default popup binding to control default alignment.\r\n         * Will be overwritten by options passed to `popup(...)`.\r\n         */\r\n        this.defaultPopupOptions = null;\r\n        this.binding = null;\r\n        /** Show triangle element in herizontal order - left or right position. */\r\n        this.herizontal = false;\r\n        /** Whether shows triangle element. */\r\n        this.triangle = true;\r\n        /** Where to append current popup. */\r\n        this.appendTo = 'body';\r\n    }\r\n    static style() {\r\n        let { popupBorderRadius, popupBackgroundColor, popupShadowBlurRadius, popupShadowColor, adjust } = theme_1.theme;\r\n        let w = adjust(10);\r\n        let h = adjust(7);\r\n        let x = adjust(11);\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tposition: absolute;\n\t\t\tleft: 0;\n\t\t\ttop: 0;\n\t\t\tz-index: 1000;\t// Same with window, so if in window, we must move it behind the window\n\t\t\tbackground: ${popupBackgroundColor};\n\t\t\tborder-radius: ${popupBorderRadius}px;\n\t\t\tfilter: drop-shadow(0 0 ${popupShadowBlurRadius / 2}px ${popupShadowColor});\t// 3px nearly equals 6px in box-shadow.\n\t\t}\n\n\t\t.triangle{\n\t\t\t// Must be the styles in top position\n\t\t\tposition: absolute;\n\t\t\tborder-left: ${w / 2}px solid transparent;\n\t\t\tborder-right: ${w / 2}px solid transparent;\n\t\t\tborder-bottom: ${h}px solid ${popupBackgroundColor};\n\t\t\ttop: -${h}px;\n\t\t\tleft: ${x}px;\t// 11 + 5 = 16\n\n\t\t\t&-herizontal{\n\t\t\t\tborder-top: ${w / 2}px solid transparent;\n\t\t\t\tborder-bottom: ${w / 2}px solid transparent;\n\t\t\t\tborder-right: ${h}px solid ${popupBackgroundColor};\n\t\t\t\tborder-left: 0;\n\t\t\t\ttop: ${x}px;\n\t\t\t\tleft: -${h}px;\n\t\t\t}\n\t\t}\n\t\t`;\r\n    }\r\n    render() {\r\n        return flit_1.html `\n\t\t\t<template tabindex=\"0\">\n\t\t\t\t${this.triangle ? flit_1.html `\n\t\t\t\t\t<div class=\"triangle\" :ref=\"triangle\" :class.triangle-herizontal=${this.herizontal} />\n\t\t\t\t` : ''}\n\t\t\t\t<slot />\n\t\t\t</template>\n\t\t`;\r\n    }\r\n    // Call `update` every time after restored from `cache(...)`.\r\n    onConnected() {\r\n        // Why render `<popup>` to body?\r\n        // It's very common that the `el` is covered or clipped,\r\n        // which will cause the `<popup>` is not fully visible.\r\n        // You can still render the `<popup>` in the same scroller with `<popup>`.\r\n        // Why inserted into body every time?\r\n        // Most popups share same `z-index`, append newly opened `<popup>` will makesure it covers others.\r\n        // Note that:\r\n        // The template `content` can't pass into `<popup>` as an argument,\r\n        // it will cause the template was parsed in `<popup>` context.\r\n        // The `<popup>` will be cached in `<popup>`, and element will be removed when not in use.\r\n        // After restored from `cache`, it will be inserted back into `<popup>`.\r\n        // So here we need to move it to `body` after every time rendered.\r\n        // If there are serval nodes which belong to an template you need to append into another element,\r\n        // Don't forget to move the anchor nodes, or the whole template nodes into the target element,\r\n        // or they will can't be removed because they are outside of the template node ranges.\r\n        // In the future, we may implement a flit directive `renderTo(..., ...)`, \r\n        // to render elements and it's anchor node to another element.\r\n        this.applyAppendTo();\r\n    }\r\n    /** Insert popup element into target specified by `appendTo`. */\r\n    applyAppendTo() {\r\n        if (this.appendTo) {\r\n            element_1.appendTo(this.el, this.appendTo);\r\n        }\r\n    }\r\n    /** Set related popup binding. */\r\n    setBinding(binding) {\r\n        this.binding = binding;\r\n    }\r\n    /** Close popup content, may play leave transition. */\r\n    close() {\r\n        if (this.binding) {\r\n            this.binding.hidePopupLater();\r\n        }\r\n        else {\r\n            this.el.remove();\r\n        }\r\n    }\r\n    /** Get the trigger element. */\r\n    getTriggerElement() {\r\n        var _a;\r\n        return ((_a = this.binding) === null || _a === void 0 ? void 0 : _a.getTriggerElement()) || null;\r\n    }\r\n};\r\nPopup = __decorate([\r\n    flit_1.define('f-popup')\r\n], Popup);\r\nexports.Popup = Popup;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Progress = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst theme_1 = require(\"../style/theme\");\r\nconst tooltip_1 = require(\"../bindings/tooltip\");\r\n/** `<f-progress>` gives a progress notification in percentage, just like `<input type=progress>`. */\r\nlet Progress = class Progress extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * Progress value betweens 0~1.\r\n         * Defult value is `0`.\r\n         */\r\n        this.value = 0;\r\n        /**\r\n         * Fixed decimal count of progress text.\r\n         * Defult value is `null`.\r\n         */\r\n        this.decimalCount = null;\r\n    }\r\n    static style() {\r\n        let { mainColor, adjust, adjustFontSize } = theme_1.theme;\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tdisplay: inline-block;\n\t\t\tvertical-align: top;\n\t\t\tposition: relative;\n\t\t\twidth: ${adjust(200)}px;\n\t\t\theight: ${adjust(28)}px;\n\t\t}\n\n\t\t.groove{\n\t\t\tposition: absolute;\n\t\t\tleft: 0;\n\t\t\tright: 0;\n\t\t\ttop: 0;\n\t\t\tbottom: 0;\n\t\t\theight: 1px;\n\t\t\tmargin: auto 0;\n\t\t\tbackground: ${mainColor.alpha(0.2)};\n\t\t}\n\n\t\t.progress{\n\t\t\theight: 100%;\n\t\t\tbackground: ${mainColor};\n\t\t}\n\n\t\t.tooltip{\n\t\t\tfont-family: consolas;\n\t\t\tfont-size: ${adjustFontSize(14)}px;\n\t\t}\n\t\t`;\r\n    }\r\n    render() {\r\n        let tip = tooltip_1.tooltip(this.renderTooltipValue(), {\r\n            alignTo: () => this.refs.progress,\r\n            alignPosition: 'bc-tr',\r\n            alignMargin: [8, 0],\r\n        });\r\n        return flit_1.html `\n\t\t\t<template ${tip}>\n\t\t\t\t<div class=\"groove\">\n\t\t\t\t\t<div class=\"progress\" :ref=\"progress\" :style.width.percent=${Math.min(this.value, 1) * 100}></div>\n\t\t\t\t</div>\n\t\t\t</template>\n\t\t`;\r\n    }\r\n    renderTooltipValue() {\r\n        let tipValue = (Math.min(this.value, 1) * 100);\r\n        let tipText = tipValue.toString();\r\n        if (this.decimalCount !== null) {\r\n            tipText = tipValue.toFixed(this.decimalCount);\r\n        }\r\n        tipText += '%';\r\n        return flit_1.html `<span class=\"${this.scopeClassName('tooltip')}\">${tipText}</span>`;\r\n    }\r\n};\r\nProgress = __decorate([\r\n    flit_1.define('f-progress')\r\n], Progress);\r\nexports.Progress = Progress;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Radio = exports.RadioGroup = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst theme_1 = require(\"../style/theme\");\r\n/** `<f-radiogroup>` can contain several `<f-radio>` elements as it's child radios. */\r\nlet RadioGroup = class RadioGroup extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** All child `<f-checkbox>`. */\r\n        this.radios = [];\r\n        /** Current value, child radio which have same value will be checked. */\r\n        this.value = null;\r\n    }\r\n    /** Retister a child radio. */\r\n    register(radio) {\r\n        this.radios.push(radio);\r\n        radio.on('change', this.onRadioChange.bind(this, radio));\r\n    }\r\n    onRadioChange(changedRadio) {\r\n        for (let radio of this.radios) {\r\n            if (radio !== changedRadio) {\r\n                radio.checked = false;\r\n            }\r\n        }\r\n        this.value = changedRadio.value;\r\n        this.emit('change', this.value);\r\n    }\r\n};\r\nRadioGroup = __decorate([\r\n    flit_1.define('f-radiogroup')\r\n], RadioGroup);\r\nexports.RadioGroup = RadioGroup;\r\n/** `<f-radio>` just like `<input type=radio>`, you can click to check one radio in a radio group. */\r\nlet Radio = class Radio extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.radioGroup = null;\r\n        /** Whether the radio was checked. */\r\n        this.checked = false;\r\n        /** If having a parent `<f-radiogroup>`, the `value` property will be assign to it after current ratio checked. */\r\n        this.value = null;\r\n    }\r\n    static style() {\r\n        let { mainColor, adjust, focusBlurRadius } = theme_1.theme;\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tdisplay: inline-flex;\n\t\t\tvertical-align: top;\n\t\t\talign-items: center;\n\t\t\tcursor: pointer;\n\n\t\t\t&:hover{\n\t\t\t\tcolor: ${mainColor};\n\t\t\t}\n\n\t\t\t&:focus{\n\t\t\t\tcolor: ${mainColor};\n\n\t\t\t\t.icon{\n\t\t\t\t\tbox-shadow: 0 0 ${focusBlurRadius}px ${mainColor};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t.icon{\n\t\t\tposition: relative;\n\t\t\ttop: -2px;\n\t\t\tborder-radius: 50%;\n\t\t\tmargin-right: ${adjust(6)}px;\n\t\t}\n\n\t\t.checked{\n\t\t\tcolor: ${mainColor};\n\t\t}\n\t\n\t\t.label{\n\t\t\tflex: 1;\n\t\t\twhite-space: nowrap;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\t\t`;\r\n    }\r\n    onCreated() {\r\n        let group = flit_1.getClosestComponentOfType(this.el, RadioGroup);\r\n        if (group) {\r\n            this.radioGroup = group;\r\n            this.checked = this.radioGroup.value == this.value;\r\n            this.radioGroup.register(this);\r\n        }\r\n    }\r\n    render() {\r\n        return flit_1.html `\n\t\t\t<template\n\t\t\t\ttabindex=\"0\"\n\t\t\t\t:class.checked=${this.checked}\n\t\t\t\t@click=${this.onClick}\n\t\t\t\t@focus=${this.onFocus}\n\t\t\t>\n\t\t\t\t<f-icon class=\"icon\" .type=${this.checked ? 'radio-checked' : 'radio-unchecked'} />\n\t\t\t\t<div class=\"label\">\n\t\t\t\t\t<slot />\n\t\t\t\t</div>\n\t\t\t</template>\n\t\t`;\r\n    }\r\n    onClick() {\r\n        if (!this.checked) {\r\n            this.checked = true;\r\n            this.emit('change', true);\r\n        }\r\n    }\r\n    onFocus() {\r\n        if (!this.checked) {\r\n            flit_1.once(this.el, 'blur', this.onBlur, this);\r\n            flit_1.once(document, 'keydown.enter', this.onEnter, this);\r\n        }\r\n    }\r\n    onBlur() {\r\n        flit_1.off(document, 'keydown', this.onEnter, this);\r\n    }\r\n    onEnter() {\r\n        this.onClick();\r\n    }\r\n};\r\nRadio = __decorate([\r\n    flit_1.define('f-radio')\r\n], Radio);\r\nexports.Radio = Radio;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Resizer = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst ff_1 = require(\"@pucelle/ff\");\r\n/** `<f-resizer>` should an absolute type resizer bar, drag it will */\r\nlet Resizer = class Resizer extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** Which position should align resizer relative to parent. */\r\n        this.position = 'right';\r\n        /** Resizing speed rate, set it to `2` if element aligns to center, and moves 1px will cause 2px increases. */\r\n        this.rate = 1;\r\n        /** Minimum size of parent. */\r\n        this.min = 0;\r\n        /** Maximum size of parent. */\r\n        this.max = Infinity;\r\n        /** Current size of parent. */\r\n        this.size = -1;\r\n    }\r\n    static style() {\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tposition: absolute;\n\t\t\tz-index: 100;\n\t\t}\n\n\t\t.top{\n\t\t\twidth: 100%;\n\t\t\theight: 10px;\n\t\t\ttop: -5px;\n\t\t\tleft: 0;\n\t\t\tcursor: ns-resize;\n\t\t}\n\n\t\t.bottom{\n\t\t\twidth: 100%;\n\t\t\theight: 10px;\n\t\t\tbottom: -5px;\n\t\t\tleft: 0;\n\t\t\tcursor: ns-resize;\n\t\t}\n\n\t\t.left{\n\t\t\twidth: 10px;\n\t\t\theight: 100%;\n\t\t\ttop: 0;\n\t\t\tleft: -5px;\n\t\t\tcursor: ew-resize;\n\t\t}\n\n\t\t.right{\n\t\t\twidth: 10px;\n\t\t\theight: 100%;\n\t\t\ttop: 0;\n\t\t\tright: -5px;\n\t\t\tcursor: ew-resize;\n\t\t}\n\n\t\t.resizing-mask{\n\t\t\tposition: fixed;\n\t\t\tz-index: 9999;\n\t\t\tleft: 0;\n\t\t\tright: 0;\n\t\t\ttop: 0;\n\t\t\tbottom: 0;\n\n\t\t\t&.herizontal{\n\t\t\t\tcursor: ew-resize;\n\t\t\t}\n\n\t\t\t&.vertical{\n\t\t\t\tcursor: ns-resize;\n\t\t\t}\n\t\t}\n\t\t`;\r\n    }\r\n    render() {\r\n        return flit_1.html `\n\t\t\t<template\n\t\t\t\t:class=${this.position}\n\t\t\t\t@mousedown=${this.onStartResize}\n\t\t\t></template>\n\t\t`;\r\n    }\r\n    onReady() {\r\n        if (ff_1.getStyleValue(this.el.parentElement, 'position') === 'static') {\r\n            throw new Error('Parent of \"<f-resizer>\" must can\\'t have an \"static\" position');\r\n        }\r\n    }\r\n    onStartResize(e) {\r\n        let startX = e.clientX;\r\n        let startY = e.clientY;\r\n        let startParentWidth = this.el.parentElement.offsetWidth;\r\n        let startParentHeight = this.el.parentElement.offsetHeight;\r\n        let onMouseMove = (e) => {\r\n            e.preventDefault();\r\n            this.resize(startParentWidth, startParentHeight, e.clientX - startX, e.clientY - startY);\r\n        };\r\n        let onMouseUp = () => {\r\n            flit_1.off(document, 'mousemove', onMouseMove);\r\n            cursorMask.remove();\r\n            this.emit('change', this.size);\r\n        };\r\n        let cursorMask = flit_1.render(flit_1.html `\n\t\t\t<div class=\"resizing-mask\" class=\"${this.position === 'left' || this.position === 'right' ? 'herizontal' : 'vertical'}\" />\n\t\t`, this).getFirstElement();\r\n        document.body.append(cursorMask);\r\n        flit_1.on(document, 'mousemove', onMouseMove);\r\n        flit_1.once(document, 'mouseup', onMouseUp);\r\n    }\r\n    resize(startParentWidth, startParentHeight, movementX, movementY) {\r\n        let value;\r\n        if (this.position === 'top' || this.position === 'bottom') {\r\n            let flag = this.position === 'bottom' ? 1 : -1;\r\n            value = startParentHeight + flag * movementY * this.rate;\r\n            value = ff_1.constrain(value, this.min, this.max);\r\n            this.el.parentElement.style.height = value + 'px';\r\n        }\r\n        else {\r\n            let flag = this.position === 'right' ? 1 : -1;\r\n            value = startParentWidth + flag * movementX * this.rate;\r\n            value = ff_1.constrain(value, this.min, this.max);\r\n            this.el.parentElement.style.width = value + 'px';\r\n        }\r\n        this.size = value;\r\n        this.emit('change', this.size);\r\n    }\r\n};\r\nResizer = __decorate([\r\n    flit_1.define('f-resizer')\r\n], Resizer);\r\nexports.Resizer = Resizer;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Router = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\n/**\r\n * `<f-router>` can be used as a top container to contains everything that should be routed,\r\n * Which means choose to be rendered depends on whether current path match.\r\n * You will need initialize start path by `this.goto(this.getUnPrefixedPath(location.pathname))`.\r\n *\r\n * ```ts\r\n * render() {\r\n *     this.route('/user:id', ({id}) => {\r\n *         return html`User Id: ${id}`\r\n *     })\r\n * }\r\n * ```\r\n */\r\nlet Router = class Router extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** A prefix will be added to current location, but will be removed from router path. */\r\n        this.prefix = '';\r\n        /** Current path, no matter normal path or popup path. */\r\n        this.path = '';\r\n        /** Normal not popup type path. */\r\n        this.normalPath = '';\r\n        /** Popup path come from `goto(..., true)`. */\r\n        this.popupPath = null;\r\n        /** Stacked popup count. */\r\n        this.stackedPopupCount = 0;\r\n    }\r\n    onCreated() {\r\n        flit_1.on(window, 'popstate', this.onWindowStateChange, this);\r\n    }\r\n    /** Get relative path for router from a uri. */\r\n    getPathFromUri(uri) {\r\n        let path = new URL(uri).pathname;\r\n        return this.getUnPrefixedPath(path);\r\n    }\r\n    /** Get relative path for router from a uri. */\r\n    getUnPrefixedPath(path) {\r\n        if (this.prefix && path.startsWith(this.prefix)) {\r\n            path = path.slice(this.prefix.length);\r\n        }\r\n        if (!path) {\r\n            path = '/';\r\n        }\r\n        return path;\r\n    }\r\n    onDisconnected() {\r\n        flit_1.off(window, 'popstate', this.onWindowStateChange, this);\r\n    }\r\n    onWindowStateChange(e) {\r\n        if (e.state) {\r\n            this.redirectTo(e.state.path, e.state.asPopupPath);\r\n        }\r\n    }\r\n    route(routePath, renderFn, options = {}) {\r\n        if (this.isMatch(routePath)) {\r\n            if (options.title) {\r\n                document.title = options.title;\r\n            }\r\n            let result = this.matchPath(routePath);\r\n            if (routePath instanceof RegExp) {\r\n                return renderFn(result === null || result === void 0 ? void 0 : result.captures);\r\n            }\r\n            else {\r\n                return renderFn(result === null || result === void 0 ? void 0 : result.params);\r\n            }\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    }\r\n    /** Returns whether current path matches router path. */\r\n    isMatch(routePath) {\r\n        return PathParser.isMatch(this.normalPath, routePath)\r\n            || !!(this.popupPath && PathParser.isMatch(this.popupPath, routePath));\r\n    }\r\n    /** Match current path with router path, returns match parameters and captures. */\r\n    matchPath(routePath) {\r\n        if (PathParser.isMatch(this.normalPath, routePath)) {\r\n            return PathParser.matchPath(this.normalPath, routePath);\r\n        }\r\n        else if (this.popupPath && PathParser.isMatch(this.popupPath, routePath)) {\r\n            return PathParser.matchPath(this.popupPath, routePath);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Goto a new path and update render result, add a history state.\r\n     * If `asPopupPath` is `true`, can update current path and also keep last rendering.\r\n     */\r\n    goto(path, asPopupPath = false) {\r\n        if (asPopupPath && path === this.popupPath) {\r\n            return;\r\n        }\r\n        if (!asPopupPath && path === this.normalPath) {\r\n            return;\r\n        }\r\n        if (asPopupPath) {\r\n            this.popupPath = path;\r\n            this.stackedPopupCount++;\r\n        }\r\n        else {\r\n            this.clearPopupStack();\r\n            this.normalPath = path;\r\n        }\r\n        this.path = path;\r\n        let uri = this.getURIFromPath(path);\r\n        history.pushState({ path, asPopupPath }, '', uri);\r\n        this.emit('goto', path, asPopupPath);\r\n    }\r\n    /**\r\n     * Redirect to a new path and update render result, replace current history state.\r\n     * If `asPopupPath` is `true`, can update current path and also keep last rendering.\r\n     */\r\n    redirectTo(path, asPopupPath = false) {\r\n        if (asPopupPath && path === this.popupPath) {\r\n            return;\r\n        }\r\n        if (!asPopupPath && path === this.normalPath) {\r\n            return;\r\n        }\r\n        if (asPopupPath) {\r\n            this.popupPath = path;\r\n            this.stackedPopupCount++;\r\n        }\r\n        else {\r\n            this.clearPopupStack();\r\n            this.normalPath = path;\r\n        }\r\n        this.path = path;\r\n        let uri = this.getURIFromPath(path);\r\n        history.replaceState({ path, asPopupPath }, '', uri);\r\n        this.emit('redirectTo', path, asPopupPath);\r\n    }\r\n    /**\r\n     * Clear all popup states and pop last non-popup state.\r\n     * Must call before set current path.\r\n     */\r\n    clearPopupStack() {\r\n        if (this.popupPath) {\r\n            history.go(-this.stackedPopupCount);\r\n            this.stackedPopupCount = 0;\r\n            this.popupPath = null;\r\n        }\r\n    }\r\n    /** Get whole url. */\r\n    getURIFromPath(path) {\r\n        if (!path) {\r\n            path = '/';\r\n        }\r\n        if (this.prefix) {\r\n            path = this.prefix + path;\r\n        }\r\n        return path;\r\n    }\r\n};\r\nRouter = __decorate([\r\n    flit_1.define('f-router')\r\n], Router);\r\nexports.Router = Router;\r\nvar PathParser;\r\n(function (PathParser) {\r\n    const pathParsedResultMap = new Map();\r\n    function isMatch(path, routePath) {\r\n        let re;\r\n        if (typeof routePath === 'string') {\r\n            re = ensureParsedResult(routePath).re;\r\n        }\r\n        else {\r\n            re = routePath;\r\n        }\r\n        return re.test(path);\r\n    }\r\n    PathParser.isMatch = isMatch;\r\n    function ensureParsedResult(routePath) {\r\n        if (pathParsedResultMap.has(routePath)) {\r\n            return pathParsedResultMap.get(routePath);\r\n        }\r\n        else {\r\n            return parsePath(routePath);\r\n        }\r\n    }\r\n    function matchPath(path, routePath) {\r\n        let params = {};\r\n        let captures = [];\r\n        if (typeof routePath === 'string') {\r\n            let { re, keys } = ensureParsedResult(routePath);\r\n            let m = path.match(re);\r\n            if (!m) {\r\n                return null;\r\n            }\r\n            if (keys) {\r\n                for (let i = 0; i < keys.length; i++) {\r\n                    let key = keys[i];\r\n                    params[key] = m[i + 1];\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            let m = path.match(routePath);\r\n            if (!m) {\r\n                return null;\r\n            }\r\n            captures = [...m];\r\n        }\r\n        return {\r\n            params,\r\n            captures,\r\n        };\r\n    }\r\n    PathParser.matchPath = matchPath;\r\n    function parsePath(routePath) {\r\n        let keys = [];\r\n        let re = new RegExp(routePath\r\n            .replace(/\\./g, '\\\\.')\r\n            .replace(/\\*/g, '.*?')\r\n            .replace(/(\\/):(\\w+)/g, function (_m0, slash, property) {\r\n            if (property) {\r\n                keys.push(property);\r\n            }\r\n            return slash + '([\\\\w-]+)';\r\n        })\r\n            .replace(/^/, '^')\r\n            .replace(/$/, '$'), 'i');\r\n        let parsed = { re, keys };\r\n        pathParsedResultMap.set(routePath, parsed);\r\n        return parsed;\r\n    }\r\n})(PathParser || (PathParser = {}));\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Search = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst theme_1 = require(\"../style/theme\");\r\n/**\r\n * `<f-search>` can be inputted text to do searching.\r\n * Now only a input, will extend to list suggestted local or remote data in future.\r\n */\r\nlet Search = class Search extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** Whether search input get focus. */\r\n        this.focused = false;\r\n        /** When in composition inputting. */\r\n        this.inCompositionInputting = false;\r\n        /**\r\n         * Whether update value after change event.\r\n         * If is `false`, update value after input event.\r\n         */\r\n        this.lazy = true;\r\n        /** Search input placeholder. */\r\n        this.placeholder = '';\r\n        /** Current inputted value. */\r\n        this.value = '';\r\n    }\r\n    static style() {\r\n        let { adjust, borderColor, borderRadius, mainColor, focusBlurRadius, lineHeight } = theme_1.theme;\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tdisplay: inline-block;\n\t\t\tvertical-align: top;\n\t\t\tposition: relative;\n\t\t}\n\n\t\tinput{\n\t\t\twidth: 100%;\n\t\t\tborder: none;\n\t\t\tbackground: none;\n\t\t\theight: ${adjust(28)}px;\n\t\t\tpadding: 0 ${adjust(lineHeight - 2)}px 0 ${adjust(lineHeight - 2)}px;\n\t\t\tline-height: ${lineHeight - 2}px;\n\t\t\tborder: 1px solid ${borderColor};\n\t\t\tborder-radius: ${borderRadius}px;\n\t\t\t\n\t\t\t&:focus{\n\t\t\t\tborder-color: ${mainColor};\n\t\t\t\tbox-shadow: 0 0 ${focusBlurRadius}px ${mainColor.alpha(0.5)};\n\t\t\t}\n\t\t}\n\n\t\t.search-icon{\n\t\t\tposition: absolute;\n\t\t\ttop: 0;\n\t\t\tbottom: 0;\n\t\t\tleft: 8px;\n\t\t\tcolor: ${borderColor.toMiddle(10)};\n\t\t}\n\n\t\t.clear{\n\t\t\tdisplay: flex;\n\t\t\tposition: absolute;\n\t\t\twidth: ${adjust(28)}px;\n\t\t\ttop: 0;\n\t\t\tbottom: 0;\n\t\t\tright: 0px;\n\t\t\tcolor: ${borderColor.toMiddle(10)};\n\t\t\tcursor: pointer;\n\n\t\t\t&:hover{\n\t\t\t\tcolor: ${mainColor};\n\t\t\t}\n\n\t\t\t&:active{\n\t\t\t\ttransform: translateY(1px);\n\t\t\t}\n\t\t}\n\n\t\t.close-icon{\n\t\t\tmargin: auto;\n\t\t}\n\t\t`;\r\n    }\r\n    render() {\r\n        return flit_1.html `\n\t\t\t<f-icon class=\"search-icon\" .type=\"search\" />\n\n\t\t\t<input type=\"text\"\n\t\t\t\tplaceholder=${this.placeholder}\n\t\t\t\t.value=${this.value}\n\t\t\t\t:ref=\"input\"\n\t\t\t\t@focus=${this.onFocus}\n\t\t\t/>\n\n\t\t\t${this.value\r\n            ? flit_1.html `\n\t\t\t\t\t<div class=\"clear\" @click.stop=${this.clear}>\n\t\t\t\t\t\t<f-icon class=\"close-icon\" .type=\"close\" />\n\t\t\t\t\t</div>`\r\n            : ''}\n\t\t`;\r\n    }\r\n    onReady() {\r\n        if (this.lazy) {\r\n            flit_1.on(this.refs.input, 'change', this.onChange, this);\r\n        }\r\n        else {\r\n            flit_1.on(this.refs.input, 'compositionstart', this.onCompositionStart, this);\r\n            flit_1.on(this.refs.input, 'compositionend', this.onCompositionEnd, this);\r\n            flit_1.on(this.refs.input, 'input', this.onInput, this);\r\n        }\r\n    }\r\n    onFocus() {\r\n        this.focused = true;\r\n        flit_1.once(this.refs.input, 'blur', () => this.focused = false);\r\n    }\r\n    onChange() {\r\n        this.updateValue();\r\n    }\r\n    onCompositionStart() {\r\n        this.inCompositionInputting = true;\r\n    }\r\n    onCompositionEnd() {\r\n        this.inCompositionInputting = false;\r\n        this.onInput();\r\n    }\r\n    onInput() {\r\n        this.updateValue();\r\n    }\r\n    updateValue() {\r\n        if (this.inCompositionInputting) {\r\n            return;\r\n        }\r\n        this.value = this.refs.input.value;\r\n        this.emit('change', this.value);\r\n    }\r\n    clear() {\r\n        this.value = '';\r\n        this.emit('change', '');\r\n    }\r\n};\r\nSearch = __decorate([\r\n    flit_1.define('f-search')\r\n], Search);\r\nexports.Search = Search;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Select = void 0;\r\nconst ff_1 = require(\"@pucelle/ff\");\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst theme_1 = require(\"../style/theme\");\r\nconst dropdown_1 = require(\"./dropdown\");\r\n/** `<f-select>` works just like `<select>`, you can select one or multiple option from it. */\r\nlet Select = class Select extends dropdown_1.Dropdown {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** Inputted text for filtering list items. */\r\n        this.inputted = '';\r\n        /** Is in editing mode, in which you can input text to filter list items. */\r\n        this.editing = false;\r\n        /** Trigger event type. Default value is `click`. */\r\n        this.trigger = 'click';\r\n        /** Whether shows triangle. Default value is `false`. */\r\n        this.triangle = false;\r\n        /**\r\n         * Align margin betweens trigger element and popup content.\r\n         * Default value is '0' in pixels.\r\n         */\r\n        this.alignMargin = 0;\r\n        /**\r\n         * Whether can select multiple items, only for type `selection`.\r\n         * Default value is `false`.\r\n         */\r\n        this.multipleSelect = false;\r\n        /** Whether can input to search from all option text. */\r\n        this.searchable = false;\r\n        /** Placeholder for search input. */\r\n        this.placeholder = '';\r\n        /** Input data list. */\r\n        this.data = [];\r\n        /** Current selected value or multiple values when `multipleSelect` is `true`. */\r\n        this.value = null;\r\n    }\r\n    static style() {\r\n        let { mainColor, adjust, borderColor, popupShadowBlurRadius, backgroundColor, popupShadowColor } = theme_1.theme;\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tdisplay: inline-flex;\n\t\t\tvertical-align: top;\n\t\t\twidth: ${adjust(200)}px;\n\t\t\theight: ${adjust(28)}px;\n\t\t\tbackground: ${backgroundColor.toMiddle(5)};\n\t\t\tline-height: ${adjust(28)}px;\n\t\t\tjustify-content: space-between;\n\t\t\talign-items: center;\n\t\t\tcursor: pointer;\n\t\t\tbox-shadow: inset 0 -1px 0 0 ${borderColor};\n\n\t\t\t&:hover, &.opened{\n\t\t\t\tbox-shadow: inset 0 -1px 0 0 ${mainColor};\n\n\t\t\t\t.icon{\n\t\t\t\t\tcolor: ${mainColor};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t&.not-inputable input{\n\t\t\t\tcursor: pointer;\n\t\t\t}\n\t\t}\n\n\t\t.down-icon{\n\t\t\tmargin-left: auto;\n\t\t\tmargin-right: 4px;\n\t\t}\n\t\n\t\t.display, .input{\n\t\t\tflex: 1;\n\t\t\tmin-width: 0;\n\t\t\tpadding: 0 0 0 ${adjust(8)}px;\n\t\t\theight: 100%;\n\t\t\tborder: none;\n\t\t\tbackground: transparent;\n\t\t\twhite-space: nowrap;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t\tbox-shadow: none;\n\n\t\t\t&:focus{\n\t\t\t\tbox-shadow: none;\n\t\t\t}\n\t\t}\n\n\t\t.placeholder{\n\t\t\topacity: 0.5;\n\t\t}\n\t\n\t\t.popup{\n\t\t\tpadding: 0;\n\t\t\tborder-radius: 0;\n\t\t\tfilter: none;\n\t\t\tbox-shadow: 0 1px ${popupShadowBlurRadius}px ${popupShadowColor};\n\t\t}\n\n\t\t.list{\n\t\t\tborder-bottom: none;\n\n\t\t\t.option__f-list{\n\t\t\t\tpadding-left: ${adjust(8)}px;\n\t\t\t\tborder-top: none;\n\t\t\t}\n\t\t}\n\n\t\t.selected-icon{\n\t\t\tmargin-right: -4px;\n\t\t}\n\t\t`.extends(super.style());\r\n    }\r\n    onCreated() {\r\n        this.initializeStartValue();\r\n    }\r\n    initializeStartValue() {\r\n        if (this.multipleSelect && !Array.isArray(this.value)) {\r\n            this.value = [];\r\n        }\r\n    }\r\n    setOpened(opened) {\r\n        super.setOpened(opened);\r\n        if (this.searchable && !opened && this.editing) {\r\n            this.endEditing();\r\n        }\r\n    }\r\n    render() {\r\n        return flit_1.html `\n\t\t\t<template :class.not-inputable=${!this.searchable}>\n\t\t\t\t${this.renderDisplayOrInput()}\n\t\t\t</template>\n\t\t`.extends(super.render());\r\n    }\r\n    renderDisplayOrInput() {\r\n        if (this.editing) {\r\n            return flit_1.html `\n\t\t\t\t<input type=\"text\"\n\t\t\t\t\tclass=\"input\"\n\t\t\t\t\t:ref=\"input\"\n\t\t\t\t\t.value=${this.inputted}\n\t\t\t\t\t.placeholder=${this.placeholder}\n\t\t\t\t\t?readonly=${!this.editing}\n\t\t\t\t\t@click=${this.onClick}\n\t\t\t\t\t@input=${this.onInput}\n\t\t\t\t>\n\t\t\t`;\r\n        }\r\n        else {\r\n            let text = this.renderCurrentDisplay();\r\n            return flit_1.html `\n\t\t\t\t<div\n\t\t\t\t\tclass=\"input\"\n\t\t\t\t\t:class.placeholder=${!text}\n\t\t\t\t\t@click=${this.onClick}\n\t\t\t\t>\n\t\t\t\t\t${text || this.placeholder}\n\t\t\t\t</div>\n\t\t\t`;\r\n        }\r\n    }\r\n    renderPopup() {\r\n        let data = this.getDisplayData();\r\n        return flit_1.html `\n\t\t\t<f-popup\n\t\t\t\tclass=\"popup\"\n\t\t\t\t:ref=\"popup\"\n\t\t\t\t.triangle=\"false\"\n\t\t\t>\n\t\t\t\t<f-list class=\"list\"\n\t\t\t\t\t:ref=\"list\"\n\t\t\t\t\t.type=\"selection\"\n\t\t\t\t\t.selectable\n\t\t\t\t\t.data=${data}\n\t\t\t\t\t.multipleSelect=${this.multipleSelect}\n\t\t\t\t\t.selected=${this.multipleSelect ? this.value : [this.value]}\n\t\t\t\t\t.navigateFrom=${() => this.refs.input}\n\t\t\t\t\t@@select=${this.onSelected}\n\t\t\t\t/>\n\t\t\t</f-popup>\n\t\t`;\r\n    }\r\n    renderCurrentDisplay() {\r\n        if (this.multipleSelect) {\r\n            let displays = [];\r\n            for (let { value, text } of this.data) {\r\n                if (this.value.includes(value)) {\r\n                    displays.push(text.toString());\r\n                }\r\n            }\r\n            return displays.join('; ');\r\n        }\r\n        else {\r\n            for (let { value, text } of this.data) {\r\n                if (this.value === value) {\r\n                    return text;\r\n                }\r\n            }\r\n            return '';\r\n        }\r\n    }\r\n    getDisplayData() {\r\n        var _a;\r\n        if (this.searchable && this.inputted) {\r\n            let lowerSearchWord = this.inputted.toLowerCase();\r\n            let filteredData = [];\r\n            for (let item of this.data) {\r\n                let searchText = (_a = item.searchText) !== null && _a !== void 0 ? _a : String(item.text).toLowerCase();\r\n                if (searchText.includes(lowerSearchWord)) {\r\n                    filteredData.push(item);\r\n                }\r\n            }\r\n            return filteredData;\r\n        }\r\n        else {\r\n            return this.data;\r\n        }\r\n    }\r\n    onClick() {\r\n        if (this.searchable && !this.editing) {\r\n            this.startEditing();\r\n        }\r\n    }\r\n    onSelected(values) {\r\n        if (this.multipleSelect) {\r\n            this.value = values;\r\n        }\r\n        else {\r\n            this.value = values[0];\r\n            this.hidePopup();\r\n        }\r\n        this.emit('change', this.value);\r\n    }\r\n    async startEditing() {\r\n        this.editing = true;\r\n        await flit_1.untilRenderComplete();\r\n        this.refs.input.focus();\r\n    }\r\n    endEditing() {\r\n        this.editing = false;\r\n        this.inputted = '';\r\n    }\r\n    onPopupOpened() {\r\n        flit_1.onRenderComplete(() => {\r\n            this.mayFocusInput();\r\n            this.scrollToViewSelectedOption();\r\n        });\r\n    }\r\n    mayFocusInput() {\r\n        if (this.editing && this.refs.input) {\r\n            this.refs.input.focus();\r\n        }\r\n    }\r\n    onWillAlign() {\r\n        this.syncPopupWidth();\r\n    }\r\n    syncPopupWidth() {\r\n        if (this.refs.popup) {\r\n            this.refs.popup.style.minWidth = String(this.el.offsetWidth) + 'px';\r\n        }\r\n    }\r\n    scrollToViewSelectedOption() {\r\n        if (this.refs.list) {\r\n            let selectedOption = this.refs.list.querySelector('[class*=selected]');\r\n            if (selectedOption && ff_1.getScrollDirection(this.refs.list) === 'y') {\r\n                ff_1.scrollToTop(selectedOption);\r\n            }\r\n        }\r\n    }\r\n    onInput() {\r\n        this.inputted = this.refs.input.value;\r\n        this.showPopup();\r\n    }\r\n};\r\nSelect = __decorate([\r\n    flit_1.define('f-select')\r\n], Select);\r\nexports.Select = Select;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Slider = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst theme_1 = require(\"../style/theme\");\r\nconst ff_1 = require(\"@pucelle/ff\");\r\nconst tooltip_1 = require(\"../bindings/tooltip\");\r\n/** `<f-slider>` provides a range selector, you may pick one value by sliding in the bar. */\r\nlet Slider = class Slider extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** Whether in vertical mode. Defult value is `false` */\r\n        this.vertical = false;\r\n        /** Minimum value. Defult value is `0`. */\r\n        this.min = 0;\r\n        /** Maximum value. Defult value is `100`. */\r\n        this.max = 100;\r\n        /** Value step when increasing or decreasing. Defult value is `1`. */\r\n        this.step = 1;\r\n        /** Current value. Defult value is `0`. */\r\n        this.value = 0;\r\n        /** Fixed decimal count of progress text. Default value is `null`. */\r\n        this.decimalCount = null;\r\n        this.draging = false;\r\n    }\r\n    static style() {\r\n        let { mainColor, borderColor, adjust, adjustFontSize, focusBlurRadius, backgroundColor } = theme_1.theme;\r\n        let grooveSize = 1;\r\n        let ballSize = Math.ceil(adjust(7)) * 2 + grooveSize;\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tdisplay: inline-flex;\n\t\t\tvertical-align: top;\n\t\t\tflex-direction: column;\n\t\t\tjustify-content: center;\n\t\t\tposition: relative;\n\t\t\twidth: ${adjust(150)}px;\n\t\t\theight: ${adjust(28)}px;\n\t\t\tfont-size: ${adjustFontSize(13)}px;\n\t\t\tcursor: pointer;\n\n\t\t\t&:focus .ball{\n\t\t\t\tbox-shadow: 0 0 ${focusBlurRadius}px ${mainColor};\n\t\t\t\tborder-color: ${mainColor};\n\t\t\t}\n\t\t}\n\n\t\t.groove{\n\t\t\tposition: relative;\n\t\t\theight: ${grooveSize}px;\n\t\t}\n\n\t\t.groove-bg{\n\t\t\tposition: absolute;\n\t\t\tleft: 0;\n\t\t\ttop: 0;\n\t\t\twidth: 100%;\n\t\t\theight: 100%;\n\t\t\tbackground: ${borderColor};\n\t\t}\n\t\n\t\t.progress{\n\t\t\tposition: relative;\n\t\t\tbackground: ${mainColor};\n\t\t\theight: 100%;\n\t\t}\n\t\n\t\t.ball{\n\t\t\tposition: absolute;\n\t\t\ttop: -${(ballSize - grooveSize) / 2}px;\n\t\t\tmargin-left: -${Math.round(ballSize / 2)}px;\n\t\t\twill-change: top, left;\n\t\t\tborder-radius: 50%;\n\t\t\tborder: 1px solid ${borderColor};\n\t\t\tbackground: ${backgroundColor};\n\t\t\tfloat: right;\n\t\t\twidth: ${ballSize}px;\n\t\t\theight: ${ballSize}px;\n\n\t\t\t&:hover{\n\t\t\t\tborder-color: ${mainColor};\n\t\t\t}\n\t\t}\n\n\t\t.dragging{\n\t\t\t.ball{\n\t\t\t\tborder-color: ${mainColor.darken(10)};\n\t\t\t\tbackground: ${mainColor.darken(10)};\n\t\t\t}\n\t\t}\n\n\t\t.vertical{\n\t\t\twidth: ${adjust(30)}px;\n\t\t\theight: ${adjust(150)}px;\n\t\t\tflex-direction: row;\n\n\t\t\t.groove{\n\t\t\t\twidth: ${grooveSize}px;\n\t\t\t\theight: 100%;\n\t\t\t}\n\n\t\t\t.progress{\n\t\t\t\tposition: absolute;\n\t\t\t\tbottom: 0;\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 0;\n\t\t\t}\n\n\t\t\t.ball{\n\t\t\t\tmargin: -${Math.round(ballSize / 2)}px -${(ballSize - grooveSize) / 2}px;\n\t\t\t}\n\t\t}\n\n\t\t.tooltip{\n\t\t\tfont-family: consolas;\n\t\t\tfont-size: ${adjustFontSize(14)}px;\n\t\t}\n\t\t`;\r\n    }\r\n    render() {\r\n        let tip = tooltip_1.tooltip(this.renderTooltipContent(), {\r\n            alignTo: () => this.refs.ball,\r\n            alignPosition: this.vertical ? 'r' : 't',\r\n        });\r\n        let sizeStyle = {};\r\n        if (this.vertical) {\r\n            sizeStyle.height = this.getPercent() + '%';\r\n        }\r\n        else {\r\n            sizeStyle.width = this.getPercent() + '%';\r\n        }\r\n        let positionStyle = {};\r\n        if (this.vertical) {\r\n            positionStyle.top = (100 - this.getPercent()) + '%';\r\n        }\r\n        else {\r\n            positionStyle.left = this.getPercent() + '%';\r\n        }\r\n        return flit_1.html `\n\t\t\t<template\n\t\t\t\ttabindex=\"0\"\n\t\t\t\t:class.vertical=${this.vertical}\n\t\t\t\t:class.dragging=${this.draging}\n\t\t\t\t${tip}\n\t\t\t\t@mousedown=${this.onMouseDown}\n\t\t\t\t@focus=${this.onFocus}\n\t\t\t\t@blur=${this.onBlur}\n\t\t\t>\n\t\t\t\t<div class=\"groove\" :ref=\"groove\">\n\t\t\t\t\t<div class=\"groove-bg\" />\n\t\t\t\t\t<div class=\"progress\" :style=${sizeStyle} />\n\t\t\t\t\t<div class=\"ball\" :ref=\"ball\" :style=${positionStyle} />\n\t\t\t\t</div>\n\t\t\t\t\n\t\t\t</template>\n\t\t`;\r\n    }\r\n    renderTooltipContent() {\r\n        let decimalCount = this.decimalCount;\r\n        if (decimalCount === null) {\r\n            decimalCount = String(this.step).replace(/^\\d+\\.?/, '').length;\r\n        }\r\n        let tipText = this.value.toFixed(decimalCount);\r\n        return flit_1.html `<span class=\"${this.scopeClassName('tooltip')}\">${tipText}</span>`;\r\n    }\r\n    getPercent() {\r\n        if (this.value === this.min) {\r\n            return 0;\r\n        }\r\n        let percentage = (this.value - this.min) / (this.max - this.min) * 100;\r\n        return ff_1.constrain(percentage, 0, 100);\r\n    }\r\n    onMouseDown(e) {\r\n        let rect = ff_1.getRect(this.refs.groove);\r\n        // Avoid mouse leave to cause it hide.\r\n        ff_1.MouseLeave.lock(this.el);\r\n        this.draging = true;\r\n        // If clicked the ball, not move; only move when clicked the groove.\r\n        if (!e.target.matches(this.scopeClassName('.ball'))) {\r\n            this.changeValueByEvent(e, rect);\r\n        }\r\n        let onMouseMove = (e) => {\r\n            // Disable selecting text unexpectedly, and makesure ball not lose focus.\r\n            e.preventDefault();\r\n            this.changeValueByEvent(e, rect);\r\n        };\r\n        flit_1.on(document, 'mousemove', onMouseMove);\r\n        flit_1.once(document, 'mouseup', () => {\r\n            ff_1.MouseLeave.unlock(this.el);\r\n            flit_1.off(document, 'mousemove', onMouseMove);\r\n            this.draging = false;\r\n            this.emit('dragend');\r\n        });\r\n        this.emit('dragstart');\r\n    }\r\n    changeValueByEvent(e, rect) {\r\n        let rate;\r\n        if (this.vertical) {\r\n            rate = ff_1.constrain(1 - (e.clientY - rect.top) / rect.height, 0, 1);\r\n        }\r\n        else {\r\n            rate = ff_1.constrain((e.clientX - rect.left) / rect.width, 0, 1);\r\n        }\r\n        let diff = (this.max - this.min) * rate;\r\n        if (this.step) {\r\n            diff = Math.round(diff / this.step) * this.step;\r\n        }\r\n        let oldValue = this.value;\r\n        let newValue = ff_1.toDecimal(this.min + diff, 4);\r\n        if (newValue !== oldValue) {\r\n            this.emit('change', this.value = newValue);\r\n        }\r\n    }\r\n    onWheel(e) {\r\n        if (!this.step || document.activeElement !== this.el) {\r\n            return;\r\n        }\r\n        let newValue;\r\n        // deltaY < 0 when wheel up\r\n        if (e.deltaY < 0 && this.vertical || e.deltaY > 0 && !this.vertical) {\r\n            newValue = ff_1.toDecimal(Math.min(this.value + this.step, this.max), 4);\r\n        }\r\n        else {\r\n            newValue = ff_1.toDecimal(Math.max(this.value - this.step, this.min), 4);\r\n        }\r\n        if (newValue !== this.value) {\r\n            this.emit('change', this.value = newValue);\r\n        }\r\n    }\r\n    onFocus() {\r\n        this.onBlur();\r\n        flit_1.on(document, 'keydown', this.onKeyDown, this);\r\n        flit_1.on(document, 'wheel.prevent', this.onWheel, this);\r\n    }\r\n    onKeyDown(e) {\r\n        let newValue;\r\n        if (this.vertical) {\r\n            if (e.key === 'ArrowUp') {\r\n                e.preventDefault();\r\n                newValue = Math.min(this.value + this.step, this.max);\r\n            }\r\n            else if (e.key === 'ArrowDown') {\r\n                e.preventDefault();\r\n                newValue = Math.max(this.value - this.step, this.min);\r\n            }\r\n        }\r\n        else {\r\n            if (e.key === 'ArrowLeft') {\r\n                e.preventDefault();\r\n                newValue = Math.max(this.value - this.step, this.min);\r\n            }\r\n            else if (e.key === 'ArrowRight') {\r\n                e.preventDefault();\r\n                newValue = Math.min(this.value + this.step, this.max);\r\n            }\r\n        }\r\n        if (e.key === 'Escape') {\r\n            e.preventDefault();\r\n            this.el.blur();\r\n        }\r\n        if (newValue !== undefined && newValue !== this.value) {\r\n            this.emit('change', this.value = newValue);\r\n        }\r\n    }\r\n    onBlur() {\r\n        flit_1.off(document, 'keydown', this.onKeyDown, this);\r\n        flit_1.off(document, 'wheel', this.onWheel, this);\r\n    }\r\n};\r\nSlider = __decorate([\r\n    flit_1.define('f-slider')\r\n], Slider);\r\nexports.Slider = Slider;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Switch = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst theme_1 = require(\"../style/theme\");\r\n/** `<f-switch>` work just like `<f-checkbox>` but easier to interact with. */\r\nlet Switch = class Switch extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** Whether the switch is in on state. */\r\n        this.value = false;\r\n    }\r\n    static style() {\r\n        let { mainColor, adjust, focusBlurRadius, backgroundColor } = theme_1.theme;\r\n        let h = adjust(18);\r\n        let w = h * 2 - 8;\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tdisplay: inline-block;\n\t\t\tvertical-align: top;\n\t\t\twidth: ${w}px;\n\t\t\theight: ${h}px;\n\t\t\tbackground: ${backgroundColor.toMiddle(23.3)};\n\t\t\tborder-radius: ${h / 2}px;\n\t\t\tpadding: 1px;\n\t\t\tmargin: ${(adjust(28) - h) / 2}px 0;\n\t\t\ttransition: background-color 0.2s ${flit_1.getCSSEasingValue('ease-out-cubic')};\n\t\t\tcursor: pointer;\n\n\t\t\t&:hover{\n\t\t\t\tbackground: ${backgroundColor.toMiddle(33)};\n\t\t\t}\n\t\t\t\n\t\t\t&:focus{\n\t\t\t\tbox-shadow: 0 0 ${focusBlurRadius}px ${mainColor};\n\t\t\t}\n\t\t}\n\t\n\t\t.ball{\n\t\t\twidth: ${h - 2}px;\n\t\t\theight: ${h - 2}px;\n\t\t\tbackground: ${backgroundColor};\n\t\t\tborder-radius: 50%;\n\t\t\ttransition: margin 0.2s ${flit_1.getCSSEasingValue('ease-out-cubic')};\n\t\t}\n\t\n\t\t.on{\t\t\n\t\t\tbackground: ${mainColor};\n\n\t\t\t.ball{\n\t\t\t\tborder-color: ${backgroundColor};\n\t\t\t\tmargin-left: calc(100% - ${h - 2}px);\n\t\t\t}\n\n\t\t\t&:hover{\n\t\t\t\tbackground: ${mainColor.darken(10)};\n\t\t\t}\n\t\t}\n\t\t`;\r\n    }\r\n    render() {\r\n        return flit_1.html `\n\t\t\t<template\n\t\t\t\ttabindex=\"0\"\n\t\t\t\t:class.on=${this.value}\n\t\t\t\t@click=${this.onClick}\n\t\t\t\t@focus=${this.onFocus}\n\t\t\t\t@blur=${this.onBlur}\n\t\t\t>\n\t\t\t\t<div class=\"ball\"></div>\n\t\t\t</template>\n\t\t`;\r\n    }\r\n    onClick() {\r\n        this.toggleState();\r\n    }\r\n    toggleState() {\r\n        this.value = !this.value;\r\n        this.emit('change', this.value);\r\n    }\r\n    onFocus() {\r\n        flit_1.on(document, 'keydown', this.onKeyDown, this);\r\n    }\r\n    onKeyDown(e) {\r\n        if (e.key === 'Enter') {\r\n            e.preventDefault();\r\n            this.toggleState();\r\n        }\r\n        else if (e.key === 'ArrowLeft') {\r\n            if (this.value) {\r\n                e.preventDefault();\r\n                this.toggleState();\r\n            }\r\n        }\r\n        else if (e.key === 'ArrowRight') {\r\n            if (!this.value) {\r\n                e.preventDefault();\r\n                this.toggleState();\r\n            }\r\n        }\r\n    }\r\n    onBlur() {\r\n        flit_1.off(document, 'keydown', this.onKeyDown, this);\r\n    }\r\n};\r\nSwitch = __decorate([\r\n    flit_1.define('f-switch')\r\n], Switch);\r\nexports.Switch = Switch;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Table = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst theme_1 = require(\"../style/theme\");\r\nconst ff_1 = require(\"@pucelle/ff\");\r\nconst column_width_resizer_1 = require(\"./helpers/column-width-resizer\");\r\nconst remote_store_1 = require(\"../store/remote-store\");\r\nconst table_state_1 = require(\"./helpers/table-state\");\r\n/**\r\n * `<f-table>` works just like a `<table>`, it provides data view and per row or per column operation.\r\n * `store` provides data service and also data filtering and data ordering.\r\n * `columns` can config data column mode for table view.\r\n */\r\nlet Table = class Table extends flit_1.Component {\r\n    constructor(el) {\r\n        super(el);\r\n        /**\r\n         * If `true`, will only render the rows that in viewport.\r\n         * Default value is `false`.\r\n         * Implies to be `true` when uses `RemoteStore`.\r\n         */\r\n        this.live = false;\r\n        /**\r\n         * Item count in one page that should be rendered each time.\r\n         * Works only when `live` is `true`.\r\n         * Default value is `50`, set it smaller if don't need to render so much.\r\n         * Suggested to be large enough to cover table height, but not covers more than 2x of table height.\r\n         * Otherwise it should provide more than 120px scrolling buffer height more than table height.\r\n         */\r\n        this.renderCount = 50;\r\n        /** If what you are rendering is very complex and can't complete in one animation frame, set this to `true`. */\r\n        this.preRendering = false;\r\n        /**\r\n         * Whether each column is resizeable.\r\n         * Default value is `false`.\r\n         */\r\n        this.resizable = false;\r\n        /** Minimum column width in pixels. */\r\n        this.minColumnWidth = 64;\r\n        /** Transition for each row after created or removed. */\r\n        this.transition = undefined;\r\n        /** Column name to indicate which column is in order. */\r\n        this.orderName = null;\r\n        /** Current column order direction. */\r\n        this.orderDirection = '';\r\n        /** Resize column widths when `resizable` is `true`. */\r\n        this.resizer = null;\r\n        this.stateCacher = new table_state_1.TableStateCacher(this);\r\n    }\r\n    static style() {\r\n        let { adjustFontSize, adjust, mainColor, textColor, backgroundColor } = theme_1.theme;\r\n        let scrollbarWidth = ff_1.getScrollbarWidth();\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tdisplay: flex;\n\t\t\tflex-direction: column;\n\t\t\theight: 200px;\n\t\t}\n\n\t\t.head{\n\t\t\tpadding-right: ${scrollbarWidth}px;\t// Same with defined scrollbar width.\n\t\t\tcolor: ${textColor.toMiddle(20)};\n\t\t\tfont-size: ${adjustFontSize(13)}px;\n\t\t\tfont-weight: bold;\n\t\t\tuser-select: none;\n\t\t}\n\n\t\t.columns{\n\t\t\tdisplay: flex;\n\t\t}\n\n\t\t.column{\n\t\t\tposition: relative;\n\t\t\tdisplay: flex;\n\t\t\talign-items: stretch;\n\t\t\tpadding: 0 ${adjust(8)}px;\n\t\t\tborder-bottom: 1px solid ${backgroundColor.toMiddle(20)};\n\n\t\t\t&:last-child{\n\t\t\t\tflex: 1;\n\t\t\t\tmin-width: 0;\n\t\t\t\tpadding-right: ${scrollbarWidth}px;\n\t\t\t\tmargin-right: -${scrollbarWidth}px;\n\t\t\t}\n\t\t}\n\n\t\t.column-left{\n\t\t\tdisplay: flex;\n\t\t\tflex: 1;\n\t\t\tmax-width: 100%;\n\n\t\t\t&:hover .order{\n\t\t\t\tvisibility: visible;\n\t\t\t}\n\t\t}\n\n\t\t.column-title{\n\t\t\tflex: 0 1 auto;\n\t\t\tmin-width: 0;\n\t\t\twhite-space: nowrap;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\n\t\t.column-ordered{\n\t\t\tborder-bottom-color: #888;\n\t\t}\n\n\t\t.resizable .column-title{\n\t\t\tflex: 1;\n\t\t}\n\n\t\t.order{\n\t\t\twidth: ${adjust(16)}px;\n\t\t\tdisplay: flex;\n\t\t\tflex: none;\n\t\t\tmargin-right: ${adjust(-8)}px;\t// Gives 16 - 8 = 8px as cell padding-right.\n\t\t\tvisibility: hidden;\n\n\t\t\tf-icon{\n\t\t\t\tmargin: auto;\n\t\t\t}\n\n\t\t\t&.current{\n\t\t\t\tvisibility: visible;\n\t\t\t}\n\t\t}\n\n\t\t.resizer{\n\t\t\tposition: relative;\n\t\t\tz-index: 1;\n\t\t\twidth: 17px;\n\t\t\tmargin-left: auto;\n\t\t\tmargin-right: ${adjust(-17)}px;\n\t\t\tcursor: e-resize;\n\n\t\t\t&::before{\n\t\t\t\tcontent: '';\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: 8px;\n\t\t\t\ttop: 6px;\n\t\t\t\tbottom: 6px;\n\t\t\t\twidth: 1px;\n\t\t\t\tbackground: ${backgroundColor.toMiddle(20)};\n\t\t\t}\n\t\t}\n\n\t\t.scroller{\n\t\t\tflex: 1;\n\t\t\toverflow-y: scroll;\n\t\t\toverflow-x: hidden;\n\t\t}\n\n\t\t.body{\n\t\t\tflex: 1;\n\t\t\toverflow-y: scroll;\n\t\t\toverflow-x: hidden;\n\t\t\tposition: relative;\n\t\t\tborder-bottom: 1px solid ${backgroundColor.toMiddle(13)};\n\t\t}\n\n\t\t.table{\n\t\t\ttable-layout: fixed;\n\t\t\tposition: absolute;\n\t\t\twidth: 100%;\n\t\t}\n\n\t\ttr{\n\t\t\t&:hover{\n\t\t\t\tbackground: ${mainColor.alpha(0.05)};\n\t\t\t}\n\n\t\t\t&.selected{\n\t\t\t\tbackground: ${mainColor.alpha(0.1)};\n\t\t\t}\n\n\t\t\t&:last-child td{\n\t\t\t\tborder-bottom-color: transparent;\n\t\t\t}\n\t\t}\n\n\t\ttd{\n\t\t\tvertical-align: middle;\n\t\t\tpadding: ${adjust(3)}px ${adjust(8)}px;\n\t\t\tborder-bottom: 1px solid ${backgroundColor.toMiddle(13)};\n\t\t\twhite-space: nowrap;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t\tcursor: default;\n\t\t}\n\n\t\tf-checkbox{\n\t\t\tmax-width: 100%;\n\t\t\theight: 100%;\n\n\t\t\tf-icon{\n\t\t\t\tmargin-right: ${adjust(10)}px;\n\t\t\t}\n\t\t}\n\n\t\t.resizing-mask{\n\t\t\tposition: fixed;\n\t\t\tz-index: 9999;\n\t\t\tleft: 0;\n\t\t\tright: 0;\n\t\t\ttop: 0;\n\t\t\tbottom: 0;\n\t\t\tcursor: ew-resize;\n\t\t}\n\t\t`;\r\n    }\r\n    /** If specified, it's returned result will be used to overwrite `column`. */\r\n    getColumns() {\r\n        return null;\r\n    }\r\n    onCreated() {\r\n        this.store.on('dataChange', this.onStoreDataChange, this);\r\n        this.watchImmediately(() => this.getColumns(), columns => {\r\n            if (columns) {\r\n                this.columns = columns;\r\n            }\r\n        });\r\n    }\r\n    onStoreDataChange() {\r\n        if (this.repeatDir instanceof flit_1.LiveAsyncRepeatDirective) {\r\n            this.repeatDir.reload();\r\n        }\r\n    }\r\n    render() {\r\n        return flit_1.html `\n\t\t\t<div class=\"head\" :ref=\"head\">\n\t\t\t\t<div class=\"columns\" :ref=\"columnContainer\">\n\t\t\t\t\t${this.renderColumns()}\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t\t<div class=\"body\">\n\t\t\t\t<table class=\"table\" :ref=\"table\">\n\t\t\t\t\t<colgroup :ref=\"colgroup\">\n\t\t\t\t\t\t${this.columns.map(column => flit_1.html `\n\t\t\t\t\t\t\t<col :style.text-align=${column.align || ''} />\n\t\t\t\t\t\t`)}\n\t\t\t\t\t</colgroup>\n\t\t\t\t\t${this.renderRows()}\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t`;\r\n    }\r\n    renderColumns() {\r\n        return this.columns.map((column, index) => {\r\n            let orderName = column.name;\r\n            let isOrdered = this.orderName === orderName;\r\n            let flexAlign = column.align === 'right' ? 'flex-end' : column.align === 'center' ? 'center' : '';\r\n            return flit_1.html `\n\t\t\t<div class=\"column\"\n\t\t\t\t:class.column-ordered=${isOrdered}\n\t\t\t\t@click=${(e) => this.doOrdering(e, index)}\n\t\t\t>\n\t\t\t\t<div class=\"column-left\" :style.justify-content=${flexAlign}>\n\t\t\t\t\t<div class=\"column-title\">${column.title}</div>\n\t\t\t\t\t${column.orderBy ? flit_1.html `\n\t\t\t\t\t\t<div class=\"order\" :class.current=${isOrdered && this.orderDirection !== ''}>\n\t\t\t\t\t\t\t<f-icon .type=${this.getOrderDirectionIcon(orderName)} />\n\t\t\t\t\t\t</div>`\r\n                : ''}\n\t\t\t\t</div>\n\n\t\t\t\t${this.resizable && index < this.columns.length - 1 ? flit_1.html `\n\t\t\t\t\t<div class=\"resizer\" @mousedown=${(e) => { var _a; return (_a = this.resizer) === null || _a === void 0 ? void 0 : _a.onStartResize(e, index); }} />`\r\n                : ''}\n\t\t\t</div>`;\r\n        });\r\n    }\r\n    renderRows() {\r\n        if (this.store instanceof remote_store_1.RemoteStore) {\r\n            return flit_1.refDirective(flit_1.liveAsyncRepeat(this.store.getLiveAsyncRepeatDirectiveOptions(), this.renderRow.bind(this), {\r\n                renderCount: this.renderCount,\r\n                preRendering: this.preRendering,\r\n            }, this.transition), this.refDirective.bind(this));\r\n        }\r\n        else if (this.live) {\r\n            return flit_1.refDirective(flit_1.liveRepeat(this.store.getCurrentData(), this.renderRow.bind(this), {\r\n                renderCount: this.renderCount,\r\n                preRendering: this.preRendering,\r\n            }, this.transition), this.refDirective.bind(this));\r\n        }\r\n        else {\r\n            return flit_1.refDirective(flit_1.repeat(this.store.getCurrentData(), this.renderRow.bind(this), this.transition), this.refDirective.bind(this));\r\n        }\r\n    }\r\n    /**\r\n     * How to render each row.\r\n     * You should define a new component and overwrite this method if want to do more customized rendering.\r\n     */\r\n    renderRow(item, index) {\r\n        let tds = this.columns.map((column) => {\r\n            let result = item && column.render ? column.render.call(this, item, index) : '\\xa0';\r\n            return flit_1.html `<td :style.text-align=${column.align || ''}>${result}</td>`;\r\n        });\r\n        return flit_1.html `<tr>${tds}</tr>`;\r\n    }\r\n    /** Reference repeat directive, only for once. */\r\n    refDirective(dir) {\r\n        this.repeatDir = dir;\r\n        if ((this.repeatDir instanceof flit_1.LiveRepeatDirective) || (this.repeatDir instanceof flit_1.LiveAsyncRepeatDirective)) {\r\n            this.repeatDir.on('liveDataUpdated', this.onLiveDataUpdated, this);\r\n            this.repeatDir.on('liveDataRendered', this.onLiveDataRendered, this);\r\n        }\r\n    }\r\n    /** Triggers `liveDataUpdated` event. */\r\n    onLiveDataUpdated(data, index, scrollDirection) {\r\n        this.emit('liveDataUpdated', data, index, scrollDirection);\r\n    }\r\n    /** Triggers `liveDataRendered` event. */\r\n    onLiveDataRendered(data, index, scrollDirection) {\r\n        this.emit('liveDataRendered', data, index, scrollDirection);\r\n    }\r\n    /** Get order icon to indicate order direction. */\r\n    getOrderDirectionIcon(orderName) {\r\n        if (orderName === this.orderName) {\r\n            if (this.orderDirection === 'asc') {\r\n                return 'order-asc';\r\n            }\r\n            else if (this.orderDirection === 'desc') {\r\n                return 'order-desc';\r\n            }\r\n        }\r\n        return 'order-default';\r\n    }\r\n    /** Do column ordering for column with specified index. */\r\n    doOrdering(e, index) {\r\n        // Clicked column resizer.\r\n        if (e.target.closest(this.scopeClassName('.resizer'))) {\r\n            return;\r\n        }\r\n        let columns = this.columns;\r\n        let column = columns[index];\r\n        // Column is not orderable.\r\n        let canOrder = !!column.orderBy;\r\n        if (!canOrder) {\r\n            return;\r\n        }\r\n        let direction = '';\r\n        let descFirst = column.descFirst;\r\n        let columnName = column.name;\r\n        if (columnName === this.orderName) {\r\n            if (descFirst) {\r\n                direction = this.orderDirection === '' ? 'desc' : this.orderDirection === 'desc' ? 'asc' : '';\r\n            }\r\n            else {\r\n                direction = this.orderDirection === '' ? 'asc' : this.orderDirection === 'asc' ? 'desc' : '';\r\n            }\r\n        }\r\n        else {\r\n            direction = descFirst ? 'desc' : 'asc';\r\n        }\r\n        this.setOrder(columnName, direction);\r\n    }\r\n    onReady() {\r\n        this.resizer = new column_width_resizer_1.ColumnWidthResizer(this.refs.head, this.refs.columnContainer, this.refs.colgroup, this.columns, this.minColumnWidth, this.scopeClassName('resizing-mask'));\r\n        this.watch(() => flit_1.observeGetting(this, 'columns'), async (columns) => {\r\n            var _a, _b;\r\n            (_a = this.resizer) === null || _a === void 0 ? void 0 : _a.setColumns(columns);\r\n            // Here we need it render new `<col>`s.\r\n            await flit_1.untilRenderComplete();\r\n            (_b = this.resizer) === null || _b === void 0 ? void 0 : _b.updatColumnWidthsPrecisely();\r\n        });\r\n        flit_1.onRenderComplete(() => {\r\n            var _a;\r\n            (_a = this.resizer) === null || _a === void 0 ? void 0 : _a.updatColumnWidthsPrecisely();\r\n        });\r\n    }\r\n    onConnected() {\r\n        flit_1.onRenderComplete(() => {\r\n            let unwatchSize = ff_1.watchLayout(this.el, 'size', () => { var _a; return (_a = this.resizer) === null || _a === void 0 ? void 0 : _a.updatColumnWidthsPrecisely(); });\r\n            this.once('disconnected', unwatchSize);\r\n        });\r\n    }\r\n    /** Order specified column by column name. */\r\n    setOrder(columnName, direction = '') {\r\n        var _a;\r\n        this.orderName = columnName;\r\n        this.orderDirection = direction;\r\n        let column = (_a = this.columns) === null || _a === void 0 ? void 0 : _a.find(col => col.name === columnName);\r\n        if (column) {\r\n            this.applyOrder(column, direction);\r\n        }\r\n        else {\r\n            this.watchOnce(() => this.columns, columns => {\r\n                let column = columns.find(col => col.name === columnName);\r\n                if (column) {\r\n                    this.applyOrder(column, direction);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /** Clear column order. */\r\n    clearOrder() {\r\n        this.orderName = null;\r\n        this.orderDirection = '';\r\n        this.store.setOrder(null);\r\n        this.store.sync();\r\n    }\r\n    /** Order specified column with specified direction by column name. */\r\n    applyOrder(column, direction = '') {\r\n        if (direction === '') {\r\n            this.store.setOrder(null);\r\n        }\r\n        else {\r\n            this.store.setOrder(column.orderBy, direction);\r\n        }\r\n        this.store.sync();\r\n        this.emit('orderChange', this.orderName, direction);\r\n    }\r\n    /** Column name to indicate which column is in order. */\r\n    getOrderName() {\r\n        return this.orderName;\r\n    }\r\n    /** Current column order direction. */\r\n    getOrderDirection() {\r\n        return this.orderDirection;\r\n    }\r\n    /** Get start index of live data in live mode, otherwise returns `0`. */\r\n    getStartIndex() {\r\n        var _a, _b;\r\n        if (this.repeatDir instanceof flit_1.RepeatDirective) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return (_b = (_a = this.repeatDir) === null || _a === void 0 ? void 0 : _a.getStartIndex()) !== null && _b !== void 0 ? _b : 0;\r\n        }\r\n    }\r\n    /** Get end index of live data in live mode, otherwise returns data length. */\r\n    getEndIndex() {\r\n        var _a;\r\n        if (this.repeatDir instanceof flit_1.RepeatDirective) {\r\n            return this.store.getCurrentData().length;\r\n        }\r\n        else {\r\n            return (_a = this.repeatDir.getEndIndex()) !== null && _a !== void 0 ? _a : this.store.getFullData().length;\r\n        }\r\n    }\r\n    /**\r\n     * Set start index property, and scroll to appropriate position.\r\n     * You can safely call this before any thing rendered.\r\n     * Note the final `startIndex` property may be different,\r\n     * and you can't ensure the element is this index is visible.\r\n     */\r\n    async setStartIndex(index) {\r\n        await this.untilReady();\r\n        if (this.repeatDir instanceof flit_1.LiveRepeatDirective || this.repeatDir instanceof flit_1.LiveAsyncRepeatDirective) {\r\n            this.repeatDir.setStartIndex(index);\r\n        }\r\n        else {\r\n            this.repeatDir.setFirstVisibleIndex(index);\r\n        }\r\n    }\r\n    /** Whether specifies a start index. */\r\n    isStartIndexSpecified() {\r\n        if (this.repeatDir instanceof flit_1.LiveRepeatDirective || this.repeatDir instanceof flit_1.LiveAsyncRepeatDirective) {\r\n            return this.repeatDir.isStartIndexSpecified();\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Adjust `startIndex` and scroll position to make item in the specified index becomes visible if it's not.\r\n     * Returns whether find the element in specified index.\r\n     */\r\n    async makeIndexVisible(index) {\r\n        await this.untilReady();\r\n        return this.repeatDir.makeIndexVisible(index);\r\n    }\r\n    /**\r\n     * Make item in the specified index becomes visible at the top scroll position.\r\n     * Returns whether find the element in specified index.\r\n     * You can safely call this before any thing rendered.\r\n     */\r\n    async setFirstVisibleIndex(index) {\r\n        await this.untilReady();\r\n        return this.repeatDir.setFirstVisibleIndex(index);\r\n    }\r\n    /**\r\n     * Get the index of the first visible element.\r\n     * Must after first time rendered.\r\n     */\r\n    getFirstVisibleIndex() {\r\n        if (this.repeatDir instanceof flit_1.LiveRepeatDirective || this.repeatDir instanceof flit_1.LiveAsyncRepeatDirective) {\r\n            return this.repeatDir.getFirstVisibleIndex();\r\n        }\r\n        else {\r\n            return ff_1.locateFirstVisibleIndex(this.refs.table, this.refs.table.rows);\r\n        }\r\n    }\r\n    /**\r\n     * Get currently rendered data item at specified index.\r\n     * Returns null if it's not rendered yet.\r\n     */\r\n    getRenderedItem(index) {\r\n        let isRendered = index >= this.getStartIndex() && index < this.getEndIndex();\r\n        if (isRendered) {\r\n            if (this.store instanceof remote_store_1.RemoteStore) {\r\n                return this.store.getImmediateData(index, index + 1)[0];\r\n            }\r\n            else {\r\n                return this.store.getCurrentData()[index];\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Get rendered row at specified index.\r\n     * Please makesure rendering is completed.\r\n     */\r\n    getRenderedRow(index) {\r\n        return this.refs.table.rows[index - this.getStartIndex()] || null;\r\n    }\r\n    /** Checks whether have state cached in a specified name. */\r\n    hasState(name) {\r\n        return this.stateCacher.has(name);\r\n    }\r\n    /**\r\n     * Caches a state includes order, filter, startIndex...\r\n     * Remember the `name` must be unique for each table instance.\r\n     */\r\n    cacheState(name, options = {}) {\r\n        this.stateCacher.cache(name, options);\r\n    }\r\n    /**\r\n     * Restore table state by it's cached name.\r\n     * Returns customized data with `{}` as default value if restored successfully,\r\n     * Returns `undefined` if have no cache to restore.\r\n     * Will clear the cache after restored.\r\n     */\r\n    restoreState(name) {\r\n        return this.stateCacher.restore(name);\r\n    }\r\n    /** Clear cached state with specified name. */\r\n    clearState(name) {\r\n        this.stateCacher.clear(name);\r\n    }\r\n};\r\nTable = __decorate([\r\n    flit_1.define('f-table')\r\n], Table);\r\nexports.Table = Table;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Tag = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst theme_1 = require(\"../style/theme\");\r\n/** `<f-tag>` used to give a label to an item. */\r\nlet Tag = class Tag extends flit_1.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** Unique value to identify current tag. */\r\n        this.value = null;\r\n        /**\r\n         * Whether current tag closeable.\r\n         * Not tag element were not removed automatically,\r\n         * you must capture close event and update rendered result.\r\n         */\r\n        this.closable = false;\r\n    }\r\n    static style() {\r\n        let { borderColor, borderRadius, adjust, adjustFontSize } = theme_1.theme;\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tdisplay: inline-flex;\n\t\t\tborder: 1px solid ${borderColor};\n\t\t\tborder-radius: ${borderRadius}px;\n\t\t\tfont-size: ${adjustFontSize(13)}px;\n\t\t\tline-height: ${adjust(18)}px;\n\t\t\theight: ${adjust(20)}px;\n\t\t\tpadding: 0 ${adjust(6)}px 0 ${adjust(6)}px;\n\t\t\tcursor: pointer;\n\n\t\t\t&:hover{\n\t\t\t\topacity: 0.9;\n\t\t\t}\n\n\t\t\t&:active{\n\t\t\t\topacity: 0.8;\n\t\t\t}\n\t\t}\n\t\n\t\t.icon{\n\t\t\tposition: relative;\n\t\t\ttop: -1px;\n\t\t\tmargin-left: ${adjust(4)}px;\n\t\t\tmargin-right: ${adjust(-4)}px;\n\t\t\tdisplay: inline-flex;\n\n\t\t\tf-icon{\n\t\t\t\tmargin: auto;\n\t\t\t}\n\t\t}\n\t\t`;\r\n    }\r\n    render() {\r\n        return flit_1.html `\n\t\t\t<slot />\n\t\t\t${this.closable ? flit_1.html `<div class=\"icon\" @click=${this.close}><f-icon .type=\"close\" /></div>` : ''}\n\t\t`;\r\n    }\r\n    close() {\r\n        this.emit('close', this.value);\r\n    }\r\n};\r\nTag = __decorate([\r\n    flit_1.define('f-tag')\r\n], Tag);\r\nexports.Tag = Tag;\r\n","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Tooltip = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst theme_1 = require(\"../style/theme\");\r\nconst popup_1 = require(\"../components/popup\");\r\n/** `<f-tooltip>` shows a short text message beside it's trigger element. */\r\nlet Tooltip = class Tooltip extends popup_1.Popup {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * Tooltip type:\r\n         *\r\n         * `default`: when mouse hover to trigger.\r\n         * `prompt`: shows be default and can be closed.\r\n         * `error`: always show if having error.\r\n         */\r\n        this.type = 'default';\r\n    }\r\n    static style() {\r\n        let { adjust, adjustFontSize, backgroundColor, textColor, errorColor } = theme_1.theme;\r\n        let types = [\r\n            ['default', backgroundColor.toMiddle(5)],\r\n            ['prompt', textColor.toMiddle(30)],\r\n            ['error', errorColor.toMiddle(5)]\r\n        ];\r\n        return flit_1.css `\n\t\t:host{\n\t\t\tdisplay: flex;\n\t\t\tfont-size: ${adjustFontSize(13)}px;\n\t\t\tmax-width: ${adjust(220)}px;\n\t\t\tpadding: ${adjust(4)}px ${adjust(8)}px;\n\t\t\tline-height: ${adjust(20)}px;\n\t\t\tpointer-events: none;\n\t\t}\n\n\t\t.text{\n\t\t\tflex: 1;\n\t\t\tmin-width: 0;\n\t\t}\n\n\t\t.close{\n\t\t\tdisplay: flex;\n\t\t\twidth: ${adjust(28)}px;\n\t\t\theight: ${adjust(28)}px;\n\t\t\tmargin-top: ${adjust(-4)}px;\n\t\t\tmargin-bottom: ${adjust(-4)}px;\n\t\t\tmargin-right: ${adjust(-8)}px;\n\t\t\tcursor: pointer;\n\n\t\t\t&:active{\n\t\t\t\ttransform: translateY(1px);\n\t\t\t}\n\n\t\t\tf-icon{\n\t\t\t\tmargin: auto;\n\t\t\t}\n\t\t}\n\n\t\t${types.map(([type, color]) => {\r\n            let textColor = color.getLightness() > 0.5 ? '#000' : '#fff';\r\n            return flit_1.css `\n\t\t\t.type-${type}{\n\t\t\t\tbackground: ${color};\n\t\t\t\tcolor: ${textColor};\n\n\t\t\t\t.triangle{\n\t\t\t\t\tborder-bottom-color: ${color};\n\n\t\t\t\t\t&-herizontal{\n\t\t\t\t\t\tborder-right-color: ${color};\n\t\t\t\t\t\tborder-bottom-color: transparent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t`;\r\n        })}\n\n\t\t.type-prompt{\n\t\t\tpointer-events: auto;\n\t\t}\n\n\t\t`.extends(super.style());\r\n    }\r\n    render() {\r\n        return flit_1.html `\n\t\t\t<template class=\"type-${this.type}\">\n\t\t\t\t<div class=\"text\">\n\t\t\t\t\t<slot />\n\t\t\t\t</div>\n\n\t\t\t\t${this.type === 'prompt' ? flit_1.html `\n\t\t\t\t\t<div class=\"close\" @click=${this.close}>\n\t\t\t\t\t\t<f-icon .type=\"close\" />\n\t\t\t\t\t</div>\n\t\t\t\t` : ''}\n\t\t\t</template>\n\t\t`.extends(super.render());\r\n    }\r\n};\r\nTooltip = __decorate([\r\n    flit_1.define('f-tooltip')\r\n], Tooltip);\r\nexports.Tooltip = Tooltip;\r\n","\"use strict\";\r\n///<reference types=\"@pucelle/webpack-svg-loader\" />\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.icons = void 0;\r\nconst checkbox_checked_svg_1 = require(\"./icons/checkbox-checked.svg\");\r\nconst checkbox_indeterminate_svg_1 = require(\"./icons/checkbox-indeterminate.svg\");\r\nconst checkbox_unchecked_svg_1 = require(\"./icons/checkbox-unchecked.svg\");\r\nconst checked_svg_1 = require(\"./icons/checked.svg\");\r\nconst close_svg_1 = require(\"./icons/close.svg\");\r\nconst confirm_svg_1 = require(\"./icons/confirm.svg\");\r\nconst down_svg_1 = require(\"./icons/down.svg\");\r\nconst error_svg_1 = require(\"./icons/error.svg\");\r\nconst info_svg_1 = require(\"./icons/info.svg\");\r\nconst love_svg_1 = require(\"./icons/love.svg\");\r\nconst order_asc_svg_1 = require(\"./icons/order-asc.svg\");\r\nconst order_default_svg_1 = require(\"./icons/order-default.svg\");\r\nconst order_desc_svg_1 = require(\"./icons/order-desc.svg\");\r\nconst radio_checked_svg_1 = require(\"./icons/radio-checked.svg\");\r\nconst radio_unchecked_svg_1 = require(\"./icons/radio-unchecked.svg\");\r\nconst right_svg_1 = require(\"./icons/right.svg\");\r\nconst search_svg_1 = require(\"./icons/search.svg\");\r\nconst success_svg_1 = require(\"./icons/success.svg\");\r\nconst tips_svg_1 = require(\"./icons/tips.svg\");\r\nconst triangle_down_svg_1 = require(\"./icons/triangle-down.svg\");\r\nconst triangle_right_svg_1 = require(\"./icons/triangle-right.svg\");\r\nconst warning_svg_1 = require(\"./icons/warning.svg\");\r\nconst refresh_svg_1 = require(\"./icons/refresh.svg\");\r\nclass SVGIcons {\r\n    constructor() {\r\n        /** Map of `id -> code`. */\r\n        this.map = new Map();\r\n    }\r\n    /** Get all icon ids. */\r\n    getAllIds() {\r\n        return this.map.keys();\r\n    }\r\n    /** Add imported icon items. */\r\n    add(...items) {\r\n        for (let { id, code } of items) {\r\n            this.map.set(id, code);\r\n        }\r\n    }\r\n    /** Get svg icon code by id. */\r\n    get(id) {\r\n        return this.map.get(id);\r\n    }\r\n    /** Delete svg icon by id. */\r\n    delete(id) {\r\n        return this.map.delete(id);\r\n    }\r\n}\r\n/**\r\n * Global icon cache object to provide types for `<f-icon />`.\r\n * You may append more icons from `icons.add(...)`.\r\n */\r\nexports.icons = new SVGIcons();\r\nexports.icons.add(checkbox_checked_svg_1.default, checkbox_indeterminate_svg_1.default, checkbox_unchecked_svg_1.default, checked_svg_1.default, close_svg_1.default, confirm_svg_1.default, down_svg_1.default, error_svg_1.default, info_svg_1.default, love_svg_1.default, order_asc_svg_1.default, order_default_svg_1.default, order_desc_svg_1.default, radio_checked_svg_1.default, radio_unchecked_svg_1.default, right_svg_1.default, search_svg_1.default, success_svg_1.default, tips_svg_1.default, triangle_down_svg_1.default, triangle_right_svg_1.default, warning_svg_1.default, refresh_svg_1.default);\r\n","export default {\"id\":\"checkbox-checked\",\"code\":\"<svg viewBox=\\\"0 0 17 17\\\"><path style=\\\"fill:currentColor; stroke:none;\\\" d=\\\"M3.6,0h9.8c2,0,3.6,1.6,3.6,3.6v9.8c0,2-1.6,3.6-3.6,3.6H3.6c-2,0-3.6-1.6-3.6-3.6V3.6C0,1.6,1.6,0,3.6,0z\\\"/><polyline style=\\\"fill:none;stroke:#FFFFFF;\\\" points=\\\"13.3,4.8 6.8,12.2 3.7,8.7\\\"/></svg>\"}","export default {\"id\":\"checkbox-indeterminate\",\"code\":\"<svg viewBox=\\\"0 0 17 17\\\"><path style=\\\"fill:currentColor; stroke:none;\\\" d=\\\"M3.6,0h9.8c2,0,3.6,1.6,3.6,3.6v9.8c0,2-1.6,3.6-3.6,3.6H3.6c-2,0-3.6-1.6-3.6-3.6V3.6C0,1.6,1.6,0,3.6,0z\\\"/><path style=\\\"fill:none;stroke:#FFFFFF;stroke-linecap:square;\\\" d=\\\"M4.4,8.5h8.1\\\"/></svg>\"}","export default {\"id\":\"checkbox-unchecked\",\"code\":\"<svg viewBox=\\\"0 0 17 17\\\"><path style=\\\"fill:none;stroke:currentColor;\\\" d=\\\"M4.1,0.5H13c2,0,3.6,1.6,3.6,3.6V13c0,2-1.6,3.6-3.6,3.6H4.1c-2,0-3.6-1.6-3.6-3.6V4.1C0.5,2.1,2.1,0.5,4.1,0.5z\\\"/></svg>\"}","export default {\"id\":\"checked\",\"code\":\"<svg viewBox=\\\"0 0 15 15\\\"><polyline style=\\\"fill:none;stroke:currentColor;\\\" points=\\\"12.5,3.4 5.7,11.6 2.5,7.8\\\"/></svg>\"}","export default {\"id\":\"close\",\"code\":\"<svg viewBox=\\\"0 0 15 15\\\"><path style=\\\"fill:currentColor; stroke:none;\\\" d=\\\"M28.1,12.5c-0.2,0-0.4-0.2-0.4-0.4c0-0.1,0-0.2,0.1-0.3L37,1.7c0.2-0.2,0.4-0.2,0.6,0c0.2,0.2,0.2,0.4,0,0.7l-9.2,10C28.4,12.5,28.2,12.5,28.1,12.5z\\\"/><path style=\\\"fill:currentColor; stroke:none;\\\" d=\\\"M37.3,12.5c-0.1,0-0.2,0-0.3-0.1L27.9,2.3c-0.1-0.2-0.1-0.4,0-0.6c0.2-0.2,0.4-0.2,0.6,0l9.2,10.1c0.2,0.2,0.2,0.4,0,0.7C37.5,12.4,37.5,12.5,37.3,12.5L37.3,12.5z\\\"/><line style=\\\"fill:none;stroke:currentColor;stroke-width:1.0526;\\\" x1=\\\"12.5\\\" y1=\\\"2.5\\\" x2=\\\"2.5\\\" y2=\\\"12.5\\\"/><line style=\\\"fill:none;stroke:currentColor;stroke-width:1.0526;\\\" x1=\\\"12.5\\\" y1=\\\"12.5\\\" x2=\\\"2.5\\\" y2=\\\"2.5\\\"/></svg>\"}","export default {\"id\":\"confirm\",\"code\":\"<svg viewBox=\\\"0 0 21 21\\\"><rect style=\\\"fill:currentColor; stroke:none;\\\" x=\\\"9.5\\\" y=\\\"14.5\\\" width=\\\"2\\\" height=\\\"2\\\"/><path style=\\\"fill:currentColor; stroke:none;\\\" d=\\\"M13.6,6.4c-0.1-0.4-0.3-0.7-0.6-1c-0.3-0.3-0.6-0.5-1-0.7c-0.5-0.2-1-0.3-1.5-0.3c-0.5,0-0.9,0.1-1.3,0.3C8.8,4.9,8.5,5.2,8.2,5.5C7.9,5.8,7.6,6.2,7.5,6.7C7.3,7.2,7.2,7.7,7.2,8.3h1.7c0-0.3,0.1-0.7,0.2-1C9.1,7,9.3,6.8,9.4,6.5c0.1-0.2,0.3-0.4,0.5-0.5c0.2-0.1,0.4-0.2,0.6-0.2c0.2,0,0.4,0,0.6,0.1c0.2,0.1,0.3,0.2,0.5,0.3c0.1,0.1,0.2,0.3,0.3,0.5C12,7,12,7.3,12,7.5C12,7.7,12,8,11.9,8.2c-0.1,0.2-0.3,0.4-0.5,0.6c-0.2,0.2-0.4,0.4-0.6,0.6c-0.2,0.2-0.4,0.4-0.6,0.6c-0.2,0.2-0.3,0.5-0.5,0.7c-0.1,0.3-0.2,0.6-0.2,0.9V12l0,0v1h2v-0.6l0,0v-0.7c0-0.3,0.1-0.5,0.2-0.8c0.1-0.2,0.3-0.4,0.4-0.6c0.2-0.2,0.3-0.4,0.6-0.6c0.2-0.2,0.4-0.4,0.6-0.6c0.2-0.2,0.3-0.5,0.4-0.7c0.1-0.3,0.2-0.6,0.2-0.9C13.8,7.1,13.7,6.7,13.6,6.4z\\\"/><circle style=\\\"fill:none;stroke:currentColor;\\\" cx=\\\"10.5\\\" cy=\\\"10.5\\\" r=\\\"10\\\"/></svg>\"}","export default {\"id\":\"down\",\"code\":\"<svg viewBox=\\\"0 0 15 15\\\"><polygon style=\\\"fill:currentColor; stroke:none;\\\" points=\\\"7.5,11 3.5,4.4 4.2,4 7.5,9.4 10.8,4 11.5,4.4\\\"/></svg>\"}","export default {\"id\":\"error\",\"code\":\"<svg viewBox=\\\"0 0 21 21\\\"><circle style=\\\"fill:none;stroke:currentColor;\\\" cx=\\\"10.5\\\" cy=\\\"10.5\\\" r=\\\"10\\\"/><line style=\\\"fill:none;stroke:currentColor;\\\" x1=\\\"14.4\\\" y1=\\\"6.6\\\" x2=\\\"6.6\\\" y2=\\\"14.4\\\"/><line style=\\\"fill:none;stroke:currentColor;\\\" x1=\\\"14.4\\\" y1=\\\"14.4\\\" x2=\\\"6.6\\\" y2=\\\"6.6\\\"/></svg>\"}","export default {\"id\":\"info\",\"code\":\"<svg viewBox=\\\"0 0 21 21\\\"><rect style=\\\"fill:currentColor; stroke:none;\\\" x=\\\"9.5\\\" y=\\\"4\\\" width=\\\"2\\\" height=\\\"2\\\"/><polygon style=\\\"fill:currentColor; stroke:none;\\\" points=\\\"11.5,9 11.5,8 9.5,8 8.5,8 8.5,9 9.5,9 9.5,16 8.5,16 8.5,17 9.5,17 11.5,17 12.5,17 12.5,16 11.5,16\\\"/><circle style=\\\"fill:none;stroke:currentColor;\\\" cx=\\\"10.5\\\" cy=\\\"10.5\\\" r=\\\"10\\\"/></svg>\"}","export default {\"id\":\"love\",\"code\":\"<svg viewBox=\\\"0 0 15 15\\\"><path style=\\\"fill:none;stroke:currentColor;\\\" d=\\\"M12.7,3.4c-1.1-1.1-2.8-1.1-3.8,0L7.5,4.7L6.1,3.4c-1.1-1.1-2.8-1.1-3.8,0c-1.1,1.1-1.1,2.8,0,3.8l1.4,1.4l3.8,3.8l3.8-3.8l1.4-1.4C13.8,6.2,13.8,4.4,12.7,3.4z\\\"/></svg>\"}","export default {\"id\":\"order-asc\",\"code\":\"<svg viewBox=\\\"0 0 7 14\\\"><polygon style=\\\"fill:currentColor;stroke:none;fill-opacity:0.4;\\\" points=\\\"5.7,8 3.5,11.8 1.3,8 0.2,8 0.1,8 3.5,13.8 6.9,8 6.8,8\\\"/><polygon style=\\\"fill:currentColor;stroke:none;\\\" points=\\\"3.5,0.3 0.1,6 0.2,6 1.3,6 3.5,2.2 5.7,6 6.8,6 6.9,6\\\"/></svg>\"}","export default {\"id\":\"order-default\",\"code\":\"<svg viewBox=\\\"0 0 7 14\\\"><polygon style=\\\"fill:currentColor;stroke:none;fill-opacity:0.4;\\\" points=\\\"5.7,8 3.5,11.8 1.3,8 0.2,8 0.1,8 3.5,13.8 6.9,8 6.8,8\\\"/><polygon style=\\\"fill:currentColor;stroke:none;fill-opacity:0.4;\\\" points=\\\"3.5,0.3 0.1,6 0.2,6 1.3,6 3.5,2.2 5.7,6 6.8,6 6.9,6\\\"/></svg>\"}","export default {\"id\":\"order-desc\",\"code\":\"<svg viewBox=\\\"0 0 7 14\\\"><polygon style=\\\"fill:currentColor;stroke:none;\\\" points=\\\"5.7,8 3.5,11.8 1.3,8 0.2,8 0.1,8 3.5,13.8 6.9,8 6.8,8\\\"/><polygon style=\\\"fill:currentColor;stroke:none;fill-opacity:0.4;\\\" points=\\\"3.5,0.3 0.1,6 0.2,6 1.3,6 3.5,2.2 5.7,6 6.8,6 6.9,6\\\"/></svg>\"}","export default {\"id\":\"radio-checked\",\"code\":\"<svg viewBox=\\\"0 0 17 17\\\"><circle style=\\\"fill:none;stroke:currentColor;\\\" cx=\\\"8.5\\\" cy=\\\"8.5\\\" r=\\\"8\\\"/><circle style=\\\"fill-rule:evenodd;clip-rule:evenodd;fill:currentColor; stroke:none;\\\" cx=\\\"8.5\\\" cy=\\\"8.5\\\" r=\\\"3.5\\\"/></svg>\"}","export default {\"id\":\"radio-unchecked\",\"code\":\"<svg viewBox=\\\"0 0 17 17\\\"><circle style=\\\"fill:none;stroke:currentColor;\\\" cx=\\\"8.5\\\" cy=\\\"8.5\\\" r=\\\"8\\\"/></svg>\"}","export default {\"id\":\"refresh\",\"code\":\"<svg viewBox=\\\"0 0 20 20\\\"><path style=\\\"fill:none;stroke:#333333;stroke-linejoin:round;\\\" d=\\\"M13.8,15.7c-3.2,2.7-7.9,2.3-10.6-0.9S1,6.9,4.2,4.3S12.1,2,14.7,5.2c1.1,1.3,1.8,3.1,1.8,4.8\\\"/><path style=\\\"fill:none;stroke:#333333;\\\" d=\\\"M18.5,6.5l-2,3.5l-3-2.5\\\"/></svg>\"}","export default {\"id\":\"right\",\"code\":\"<svg viewBox=\\\"0 0 15 15\\\"><polygon style=\\\"fill:currentColor; stroke:none;\\\" points=\\\"4.4,11.5 4,10.8 9.4,7.5 4,4.2 4.4,3.5 11,7.5\\\"/></svg>\"}","export default {\"id\":\"search\",\"code\":\"<svg viewBox=\\\"0 0 15 15\\\"><line style=\\\"fill:none;stroke:currentColor;stroke-linecap:round;\\\" x1=\\\"10\\\" y1=\\\"10\\\" x2=\\\"14.3\\\" y2=\\\"14.3\\\"/><ellipse style=\\\"fill:none;stroke:currentColor;stroke-width:1;stroke-miterlimit:9.9999;\\\" cx=\\\"6.5\\\" cy=\\\"6.5\\\" rx=\\\"5\\\" ry=\\\"5\\\"/></svg>\"}","export default {\"id\":\"success\",\"code\":\"<svg viewBox=\\\"0 0 21 21\\\"><circle style=\\\"fill:none;stroke:currentColor;\\\" cx=\\\"10.5\\\" cy=\\\"10.5\\\" r=\\\"10\\\"/><polyline style=\\\"fill:none;stroke:currentColor;\\\" points=\\\"16.2,6.4 9.3,14.6 6.1,10.8\\\"/></svg>\"}","export default {\"id\":\"tips\",\"code\":\"<svg viewBox=\\\"0 0 15 15\\\"><path style=\\\"fill:currentColor; stroke:none;\\\" d=\\\"M7,1c3.3,0,6,2.7,6,6s-2.7,6-6,6s-6-2.7-6-6S3.7,1,7,1 M7,0C3.1,0,0,3.1,0,7s3.1,7,7,7s7-3.1,7-7S10.9,0,7,0z\\\"/><rect style=\\\"fill:currentColor; stroke:none;\\\" x=\\\"6\\\" y=\\\"3\\\" width=\\\"2\\\" height=\\\"2\\\"/><polygon style=\\\"fill:currentColor; stroke:none;\\\" points=\\\"8,10 8,7 8,6 6,6 5,6 5,7 6,7 6,10 5,10 5,11 6,11 8,11 9,11 9,10\\\"/></svg>\"}","export default {\"id\":\"triangle-down\",\"code\":\"<svg viewBox=\\\"0 0 15 15\\\"><polygon style=\\\"fill:currentColor; stroke:none;\\\" points=\\\"7,11 11,3 3,3\\\"/></svg>\"}","export default {\"id\":\"triangle-right\",\"code\":\"<svg viewBox=\\\"0 0 15 15\\\"><polygon style=\\\"fill:currentColor; stroke:none;\\\" points=\\\"11,7 3,3 3,11\\\"/></svg>\"}","export default {\"id\":\"warning\",\"code\":\"<svg viewBox=\\\"0 0 21 21\\\"><line style=\\\"fill:none;stroke:currentColor;stroke-width:2;\\\" x1=\\\"10.5\\\" y1=\\\"7.5\\\" x2=\\\"10.5\\\" y2=\\\"12.5\\\"/><rect style=\\\"fill:currentColor; stroke:none;\\\" x=\\\"9.5\\\" y=\\\"14\\\" width=\\\"2\\\" height=\\\"2\\\"/><path style=\\\"fill:currentColor; stroke:none;\\\" d=\\\"M10.5,3l8.8,15H1.7L10.5,3 M10.5,1L0,19h21L10.5,1L10.5,1z\\\"/></svg>\"}","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__exportStar(require(\"./icons/icons\"), exports);\r\nrequire(\"./style/global-style\");\r\n__exportStar(require(\"./style/theme\"), exports);\r\n__exportStar(require(\"./style/color\"), exports);\r\n__exportStar(require(\"./store/store\"), exports);\r\n__exportStar(require(\"./store/remote-store\"), exports);\r\n__exportStar(require(\"./components/buttongroup\"), exports);\r\n__exportStar(require(\"./components/icon\"), exports);\r\n__exportStar(require(\"./components/radio\"), exports);\r\n__exportStar(require(\"./components/checkbox\"), exports);\r\n__exportStar(require(\"./components/switch\"), exports);\r\n__exportStar(require(\"./components/slider\"), exports);\r\n__exportStar(require(\"./components/form\"), exports);\r\n__exportStar(require(\"./components/input\"), exports);\r\n__exportStar(require(\"./components/tag\"), exports);\r\n__exportStar(require(\"./components/search\"), exports);\r\n__exportStar(require(\"./components/progress\"), exports);\r\n__exportStar(require(\"./components/popup\"), exports);\r\n__exportStar(require(\"./components/tooltip\"), exports);\r\n__exportStar(require(\"./components/popover\"), exports);\r\n__exportStar(require(\"./components/dropdown\"), exports);\r\n__exportStar(require(\"./components/list\"), exports);\r\n__exportStar(require(\"./components/navigation\"), exports);\r\n__exportStar(require(\"./components/select\"), exports);\r\n__exportStar(require(\"./components/menu\"), exports);\r\n__exportStar(require(\"./components/contextmenu\"), exports);\r\n__exportStar(require(\"./components/notification\"), exports);\r\n__exportStar(require(\"./components/dialog\"), exports);\r\n__exportStar(require(\"./components/modal\"), exports);\r\n__exportStar(require(\"./components/table\"), exports);\r\n__exportStar(require(\"./components/resizer\"), exports);\r\n__exportStar(require(\"./components/grid-layout\"), exports);\r\n__exportStar(require(\"./components/loader\"), exports);\r\n__exportStar(require(\"./components/router\"), exports);\r\n__exportStar(require(\"./bindings/tooltip\"), exports);\r\n__exportStar(require(\"./bindings/contextmenu\"), exports);\r\n__exportStar(require(\"./bindings/popup\"), exports);\r\n__exportStar(require(\"./bindings/loading\"), exports);\r\n__exportStar(require(\"./bindings/goto\"), exports);\r\n__exportStar(require(\"./bindings/drag-drop\"), exports);\r\n__exportStar(require(\"./translations/translations\"), exports);\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.KeyMap = void 0;\r\n/** Used to merge items with same keys for `Store`. */\r\nclass KeyMap {\r\n    constructor(key) {\r\n        if (!key) {\r\n            throw new Error('\"key\" parameter must be provided when initializing \"KeyMap\"!');\r\n        }\r\n        this.key = key;\r\n        this.map = new Map();\r\n    }\r\n    has(item) {\r\n        return this.map.has(item[this.key]);\r\n    }\r\n    get(item) {\r\n        return this.map.get(item[this.key]);\r\n    }\r\n    add(item) {\r\n        this.map.set(item[this.key], item);\r\n    }\r\n    delete(item) {\r\n        this.map.delete(item[this.key]);\r\n    }\r\n    clear() {\r\n        this.map = new Map();\r\n    }\r\n}\r\nexports.KeyMap = KeyMap;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PageDataCacher = void 0;\r\nconst ff_1 = require(\"@pucelle/ff\");\r\nclass PageDataCacher {\r\n    constructor(pageSize, dataCount, dataGetter, preloadPageCount = 0) {\r\n        this.cacheMap = new Map();\r\n        this.requests = new Map();\r\n        this.totalDataCount = null;\r\n        this.pageSize = pageSize;\r\n        this.dataCount = dataCount;\r\n        this.dataGetter = dataGetter;\r\n        this.preloadPageCount = preloadPageCount;\r\n    }\r\n    /** Get cache map. */\r\n    getCache() {\r\n        return this.cacheMap;\r\n    }\r\n    /** Restore cache map. */\r\n    setCache(cacheMap) {\r\n        this.cacheMap = cacheMap;\r\n    }\r\n    /** Get data count and also caches it. */\r\n    async getDataCount() {\r\n        if (this.totalDataCount !== null) {\r\n            return this.totalDataCount;\r\n        }\r\n        let dataCountConfig = this.dataCount;\r\n        let dataCount;\r\n        let knownDataCount = 0;\r\n        if (typeof dataCountConfig === 'function') {\r\n            dataCount = dataCountConfig();\r\n        }\r\n        else {\r\n            dataCount = dataCountConfig;\r\n        }\r\n        if (dataCount instanceof Promise) {\r\n            knownDataCount = await dataCount;\r\n        }\r\n        else {\r\n            knownDataCount = dataCount;\r\n        }\r\n        this.totalDataCount = knownDataCount;\r\n        return knownDataCount;\r\n    }\r\n    /** Get data items immediately. */\r\n    getImmediateData(startIndex, endIndex) {\r\n        let startPageIndex = Math.floor(startIndex / this.pageSize); // 49 -> 0, 50 -> 1\r\n        let endPageIndex = Math.floor((endIndex - 1) / this.pageSize); // 50 -> 0, 51 -> 1\r\n        let items = [];\r\n        for (let i = startPageIndex; i <= endPageIndex; i++) {\r\n            let cacheItems = this.cacheMap.get(i);\r\n            let pageItems = cacheItems;\r\n            if (!pageItems) {\r\n                pageItems = ff_1.repeatForTimes(null, this.pageSize);\r\n            }\r\n            if (i === startPageIndex && i === endPageIndex) {\r\n                items.push(...pageItems.slice(startIndex - startPageIndex * this.pageSize, endIndex - endPageIndex * this.pageSize));\r\n            }\r\n            else if (i === startPageIndex) {\r\n                items.push(...pageItems.slice(startIndex - startPageIndex * this.pageSize));\r\n            }\r\n            else if (i === endPageIndex) {\r\n                items.push(...pageItems.slice(0, endIndex - endPageIndex * this.pageSize));\r\n            }\r\n            else {\r\n                items.push(...pageItems);\r\n            }\r\n        }\r\n        this.preloadDataIfNeeded(endPageIndex + 1);\r\n        return items;\r\n    }\r\n    /** Get fresh data items. */\r\n    async getFreshData(startIndex, endIndex) {\r\n        let startPageIndex = Math.floor(startIndex / this.pageSize); // 49 -> 0, 50 -> 1\r\n        let endPageIndex = Math.floor((endIndex - 1) / this.pageSize); // 50 -> 0, 51 -> 1\r\n        let promises = [];\r\n        for (let i = startPageIndex; i <= endPageIndex; i++) {\r\n            promises.push(this.ensurePageData(i));\r\n        }\r\n        this.preloadDataIfNeeded(endPageIndex + 1);\r\n        await Promise.all(promises);\r\n        return this.getImmediateData(startIndex, endIndex);\r\n    }\r\n    /** Preload more pages of data. */\r\n    async preloadDataIfNeeded(startPageIndex) {\r\n        if (this.totalDataCount !== null && this.preloadPageCount > 0) {\r\n            let endPageIndex = Math.floor((this.totalDataCount - 1) / this.pageSize); // 50 -> 0, 51 -> 1\r\n            for (let i = startPageIndex; i <= endPageIndex && i < startPageIndex + this.preloadPageCount; i++) {\r\n                await this.ensurePageData(i);\r\n            }\r\n        }\r\n    }\r\n    /** Load page data if needed. */\r\n    async ensurePageData(pageIndex) {\r\n        if (!this.cacheMap.has(pageIndex)) {\r\n            await this.loadPageData(pageIndex);\r\n        }\r\n    }\r\n    /** Load  page data in specified index. */\r\n    loadPageData(pageIndex) {\r\n        // It's very often that you load one page of data, and then still load this page after scrolled.\r\n        // So we need to cache requests for pages before it returned.\r\n        if (this.requests.has(pageIndex)) {\r\n            return this.requests.get(pageIndex);\r\n        }\r\n        let startIndex = pageIndex * this.pageSize;\r\n        let endIndex = (pageIndex + 1) * this.pageSize;\r\n        if (this.totalDataCount !== null) {\r\n            endIndex = Math.min(endIndex, this.totalDataCount);\r\n        }\r\n        let requestPromise = this.dataGetter(startIndex, endIndex);\r\n        if (requestPromise instanceof Promise) {\r\n            let promise = requestPromise.then(items => {\r\n                let fresh = this.requests.has(pageIndex);\r\n                if (fresh) {\r\n                    this.cacheMap.set(pageIndex, [...items]);\r\n                    this.requests.delete(pageIndex);\r\n                }\r\n            });\r\n            this.requests.set(pageIndex, promise);\r\n            return promise;\r\n        }\r\n        else {\r\n            this.cacheMap.set(pageIndex, [...requestPromise]);\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n    /** Moves data after insert or delete at specified index. */\r\n    moveData(index, moveCount) {\r\n        if (moveCount === 0) {\r\n            return;\r\n        }\r\n        let startPageIndex = Math.floor(index / this.pageSize);\r\n        let endPageIndex = Math.floor((index + moveCount) / this.pageSize);\r\n        if (startPageIndex > endPageIndex) {\r\n            [startPageIndex, endPageIndex] = [endPageIndex, startPageIndex];\r\n        }\r\n        let maxPageIndex = Math.max(...this.cacheMap.keys());\r\n        let maxIndex = this.cacheMap.get(maxPageIndex).length + maxPageIndex * this.pageSize;\r\n        let maxNewIndex = maxIndex + moveCount;\r\n        let maxNewPageIndex = Math.ceil(maxNewIndex / this.pageSize);\r\n        // Moves right, get each from a left position.\r\n        if (moveCount > 0) {\r\n            for (let pageIndex = maxNewPageIndex; pageIndex > endPageIndex; pageIndex--) {\r\n                let startIndex = pageIndex * this.pageSize;\r\n                let endIndex = pageIndex * this.pageSize + this.pageSize;\r\n                startIndex -= moveCount;\r\n                endIndex -= moveCount;\r\n                this.makeNewCacheItem(pageIndex, startIndex, endIndex);\r\n            }\r\n        }\r\n        // Moves left, get each from a right position.\r\n        else {\r\n            for (let pageIndex = endPageIndex + 1; pageIndex <= maxNewPageIndex; pageIndex++) {\r\n                let startIndex = pageIndex * this.pageSize;\r\n                let endIndex = pageIndex * this.pageSize + this.pageSize;\r\n                startIndex -= moveCount;\r\n                endIndex -= moveCount;\r\n                this.makeNewCacheItem(pageIndex, startIndex, endIndex);\r\n            }\r\n        }\r\n        // Removes the affected pages.\r\n        for (let pageIndex = startPageIndex; pageIndex <= endPageIndex; pageIndex++) {\r\n            this.cacheMap.delete(pageIndex);\r\n        }\r\n        // Removes the rest pages.\r\n        for (let pageIndex = maxNewPageIndex + 1; pageIndex <= maxPageIndex; pageIndex++) {\r\n            this.cacheMap.delete(pageIndex);\r\n        }\r\n        // Removes the requests that affected.\r\n        for (let pageIndex of [...this.requests.keys()]) {\r\n            if (pageIndex >= startPageIndex) {\r\n                this.requests.delete(pageIndex);\r\n            }\r\n        }\r\n        if (this.totalDataCount !== null) {\r\n            this.totalDataCount += moveCount;\r\n        }\r\n    }\r\n    /** Create new cache item from start and end indices. */\r\n    makeNewCacheItem(pageIndex, startIndex, endIndex) {\r\n        let items = this.getImmediateData(startIndex, endIndex);\r\n        let hasAnyItem = items.some(item => item !== null);\r\n        if (hasAnyItem) {\r\n            this.cacheMap.set(pageIndex, items);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /** Clear all data cache. */\r\n    clear() {\r\n        this.cacheMap = new Map();\r\n        this.requests = new Map();\r\n        this.totalDataCount = null;\r\n    }\r\n}\r\nexports.PageDataCacher = PageDataCacher;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RemoteStore = void 0;\r\nconst ff_1 = require(\"@pucelle/ff\");\r\nconst page_data_cacher_1 = require(\"./helpers/page-data-cacher\");\r\n/**\r\n * Compare to `Store`, `RemoteStore` loads data for one page each time.\r\n * And every time after data changed, it refreshs to reload data from server.\r\n *\r\n * You should extends this class and overwrite abstract methods,\r\n * and should support like column ordering and filtering or searching in backend.\r\n */\r\nclass RemoteStore extends ff_1.Emitter {\r\n    constructor(options = {}) {\r\n        var _a, _b;\r\n        super();\r\n        /** Main key property. */\r\n        this.key = null;\r\n        /** Current ordered key. */\r\n        this.orderKey = null;\r\n        /** Current ordered direction. */\r\n        this.orderDirection = '';\r\n        /** Word to filter results. */\r\n        this.filterWord = null;\r\n        /** Whether will reload. */\r\n        this.willReload = false;\r\n        let pageSize = (_a = options.pageSize) !== null && _a !== void 0 ? _a : 50;\r\n        let preloadPageCount = (_b = options.preloadPageCount) !== null && _b !== void 0 ? _b : 0;\r\n        this.cacher = new page_data_cacher_1.PageDataCacher(pageSize, this.dataCount.bind(this), this.dataGetter.bind(this), preloadPageCount);\r\n    }\r\n    /** Set ordering key and apply it to backend. */\r\n    setOrder(key, direction = '') {\r\n        this.orderKey = key;\r\n        this.orderDirection = direction;\r\n        this.reloadLater();\r\n    }\r\n    /** Get order rule. */\r\n    getOrder() {\r\n        return {\r\n            order: this.orderKey,\r\n            orderDirection: this.orderDirection,\r\n        };\r\n    }\r\n    /** Set filter word to filter data items and apply it to backend. */\r\n    setFilter(filterWord) {\r\n        this.filterWord = filterWord;\r\n        this.reloadLater();\r\n    }\r\n    /** Get current filter word. */\r\n    getFilter() {\r\n        return this.filterWord;\r\n    }\r\n    /** Get cache map. */\r\n    getCache() {\r\n        return this.cacher.getCache();\r\n    }\r\n    /** Set cache map. */\r\n    setCache(cacheMap) {\r\n        this.cacher.setCache(cacheMap);\r\n    }\r\n    /** Clear cache data later. */\r\n    reloadLater() {\r\n        if (!this.willReload) {\r\n            Promise.resolve().then(() => {\r\n                this.sync();\r\n            });\r\n            this.willReload = true;\r\n        }\r\n    }\r\n    /** Clear cache data immediately. */\r\n    reloadImmediately() {\r\n        this.cacher.clear();\r\n    }\r\n    /**\r\n     * Normally when calls `reload`, setting filter or order will cause update current data in next micro task.\r\n     * If you can ensure everything is ready, you may sync to load new data immediately.\r\n     */\r\n    sync() {\r\n        if (this.willReload) {\r\n            this.reloadImmediately();\r\n            this.emit('dataChange');\r\n            this.willReload = false;\r\n        }\r\n    }\r\n    /** Reload all data. */\r\n    reload() {\r\n        this.reloadLater();\r\n    }\r\n    /** Get data items immediately. */\r\n    async getDataCount() {\r\n        return await this.cacher.getDataCount();\r\n    }\r\n    /** Get data items immediately. */\r\n    getImmediateData(startIndex, endIndex) {\r\n        return this.cacher.getImmediateData(startIndex, endIndex);\r\n    }\r\n    /** Get fresh data items. */\r\n    async getFreshData(startIndex, endIndex) {\r\n        return this.cacher.getFreshData(startIndex, endIndex);\r\n    }\r\n    /** Get options for `liveAsyncRepeatDirective`. */\r\n    getLiveAsyncRepeatDirectiveOptions() {\r\n        return {\r\n            key: this.key || undefined,\r\n            dataCount: this.getDataCount.bind(this),\r\n            immediateDataGetter: this.getImmediateData.bind(this),\r\n            asyncDataGetter: this.getFreshData.bind(this),\r\n        };\r\n    }\r\n}\r\nexports.RemoteStore = RemoteStore;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Store = void 0;\r\nconst ff_1 = require(\"@pucelle/ff\");\r\nconst key_map_1 = require(\"./helpers/key-map\");\r\n/* Used to cache object type data and support selection, ordering and filtering. */\r\nclass Store extends ff_1.Emitter {\r\n    constructor(options = {}) {\r\n        super();\r\n        /** If `key` specified, when different but same key items added, it covers the old one. */\r\n        this.key = null;\r\n        /** All data keys and mapped data items. */\r\n        this.dataMap = null;\r\n        /** All selected data keys and mapped data items. */\r\n        this.selectedMap = null;\r\n        /** Last clicked item, used to select range items start from it by clicking `shift + click`. */\r\n        this.lastTouchedItem = null;\r\n        /** A filter function to filter data items. */\r\n        this.filter = null;\r\n        /** Order instance, can include several column keys and direction. */\r\n        this.order = null;\r\n        /** Current order direction. */\r\n        this.orderDirection = '';\r\n        /** Full data before filtering or ordering. */\r\n        this.fullData = [];\r\n        /** Current data after been filtered and sorted. */\r\n        this.currentData = [];\r\n        /** All selected data items. */\r\n        this.selected = [];\r\n        /** Whether will update current data. */\r\n        this.willUpdateCurrentData = false;\r\n        if (options.key) {\r\n            this.key = options.key;\r\n            this.dataMap = new key_map_1.KeyMap(options.key);\r\n            this.selectedMap = new key_map_1.KeyMap(options.key);\r\n        }\r\n        this.filter = options.filter || null;\r\n        this.order = options.order || null;\r\n        if (options.data) {\r\n            this.addItems(options.data);\r\n        }\r\n    }\r\n    addItems(items, toStart = false) {\r\n        if (items.length > 0) {\r\n            if (this.dataMap) {\r\n                for (let item of items) {\r\n                    this.dataMap.add(item);\r\n                }\r\n            }\r\n            if (toStart) {\r\n                this.fullData.unshift(...items);\r\n            }\r\n            else {\r\n                this.fullData.push(...items);\r\n            }\r\n            let filteredItems = this.filter ? items.filter(this.filter) : items;\r\n            this.addItemsToCurrentData(filteredItems, toStart);\r\n        }\r\n    }\r\n    addItemsToCurrentData(items, toStart = false) {\r\n        if (this.order) {\r\n            if (items.length > 1) {\r\n                let newData = [...this.currentData, ...items];\r\n                this.order.sortArray(newData);\r\n                this.currentData = newData;\r\n            }\r\n            else {\r\n                for (let item of items) {\r\n                    this.order.binaryInsert(this.currentData, item);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (toStart) {\r\n                this.currentData.unshift(...items);\r\n            }\r\n            else {\r\n                this.currentData.push(...items);\r\n            }\r\n        }\r\n    }\r\n    /** Get all the data. */\r\n    getFullData() {\r\n        return this.fullData;\r\n    }\r\n    /**\r\n     * Set all the data.\r\n     * will update `currentData` later, except you call `syncCurrentData`.\r\n     */\r\n    setFullData(data) {\r\n        this.fullData = data;\r\n        if (this.dataMap) {\r\n            this.dataMap.clear();\r\n            for (let item of data) {\r\n                this.dataMap.add(item);\r\n            }\r\n        }\r\n        this.updateCurrentDataLater();\r\n    }\r\n    /** Get current data. */\r\n    getCurrentData() {\r\n        return this.currentData;\r\n    }\r\n    /**\r\n     * Set ordering rule.\r\n     * will update `currentData` later, except you call `syncCurrentData`.\r\n     */\r\n    setOrder(by, direction = '') {\r\n        this.order = by instanceof ff_1.Order ? by : by === null ? null : new ff_1.Order(by);\r\n        this.orderDirection = direction;\r\n        this.updateCurrentDataLater();\r\n    }\r\n    /** Get current ordering rule. */\r\n    getOrder() {\r\n        return {\r\n            order: this.order,\r\n            orderDirection: this.orderDirection,\r\n        };\r\n    }\r\n    /**\r\n     * Set filter to filter data items.\r\n     * will update `currentData` later, except you call `syncCurrentData`.\r\n     */\r\n    setFilter(filter) {\r\n        this.filter = filter;\r\n        this.deselectAll();\r\n        this.updateCurrentDataLater();\r\n    }\r\n    /** Get current filter. */\r\n    getFilter() {\r\n        return this.filter;\r\n    }\r\n    /** Update current data later after filter or order changed. */\r\n    updateCurrentDataLater() {\r\n        if (!this.willUpdateCurrentData) {\r\n            this.willUpdateCurrentData = true;\r\n            Promise.resolve().then(() => {\r\n                this.sync();\r\n            });\r\n        }\r\n    }\r\n    /** Update current data immediately after filter or order changed. */\r\n    updateCurrentDataImmediately() {\r\n        let currentData = this.filter ? this.fullData.filter(this.filter) : [...this.fullData];\r\n        if (this.order && this.orderDirection) {\r\n            this.order.sortArray(currentData, this.orderDirection);\r\n        }\r\n        this.currentData = currentData;\r\n    }\r\n    /**\r\n     * Normally when update `fullData`, setting filter or order will cause update current data in next micro task.\r\n     * If you can ensure everything is ready, you may sync to update current data immediately.\r\n     */\r\n    sync() {\r\n        if (this.willUpdateCurrentData) {\r\n            this.updateCurrentDataImmediately();\r\n            this.emit('dataChange');\r\n            this.willUpdateCurrentData = false;\r\n        }\r\n    }\r\n    /** Add data items to the end position, removes repeative items firstly. */\r\n    add(...items) {\r\n        this.remove(...items);\r\n        this.addItems(items);\r\n        this.emit('dataChange');\r\n    }\r\n    /** Add data items to the start position, removes repeative items firstly. */\r\n    addToStart(...items) {\r\n        this.remove(...items);\r\n        this.addItems(items, true);\r\n        this.emit('dataChange');\r\n    }\r\n    /** Push data items to the end position. */\r\n    push(...items) {\r\n        this.addItems(items);\r\n        this.emit('dataChange');\r\n    }\r\n    /** Unshift data items to the start position. */\r\n    unshift(...items) {\r\n        this.addItems(items, true);\r\n        this.emit('dataChange');\r\n    }\r\n    /** Insert data items to specified position. */\r\n    insert(index, ...items) {\r\n        if (items.length > 0) {\r\n            this.fullData.splice(index, 0, ...items);\r\n            if (this.dataMap) {\r\n                for (let item of items) {\r\n                    this.dataMap.add(item);\r\n                }\r\n            }\r\n            if (this.order) {\r\n                this.addItemsToCurrentData(this.filter ? items.filter(this.filter) : items);\r\n            }\r\n            else {\r\n                this.updateCurrentDataImmediately();\r\n            }\r\n        }\r\n        this.emit('dataChange');\r\n    }\r\n    /** Chech whether having specified item in full data. */\r\n    has(item) {\r\n        if (this.dataMap) {\r\n            return this.dataMap.has(item);\r\n        }\r\n        else {\r\n            return this.fullData.includes(item);\r\n        }\r\n    }\r\n    /** Chech whether having specified item in current data. */\r\n    hasCurrent(item) {\r\n        if (!this.has(item)) {\r\n            return false;\r\n        }\r\n        if (this.filter && !this.filter(item)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /** Get a cached item from the not pricise item that having same key. */\r\n    get(item) {\r\n        if (this.dataMap) {\r\n            return this.dataMap.get(item);\r\n        }\r\n        else {\r\n            return item;\r\n        }\r\n    }\r\n    /** Removes items. */\r\n    remove(...items) {\r\n        let toRemove = new Set();\r\n        if (this.dataMap) {\r\n            for (let item of items) {\r\n                if (this.dataMap.has(item)) {\r\n                    toRemove.add(this.dataMap.get(item));\r\n                    this.dataMap.delete(item);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (let item of items) {\r\n                if (this.fullData.includes(item)) {\r\n                    toRemove.add(item);\r\n                }\r\n            }\r\n        }\r\n        if (toRemove.size > 0) {\r\n            this.fullData = this.fullData.filter(item => !toRemove.has(item));\r\n            if (this.dataMap) {\r\n                this.currentData = this.currentData.filter(item => this.dataMap.has(item));\r\n            }\r\n            else {\r\n                this.currentData = this.currentData.filter(item => !toRemove.has(item));\r\n            }\r\n            this.deselect(...toRemove);\r\n            this.emit('dataChange');\r\n        }\r\n        return [...toRemove];\r\n    }\r\n    /** Get selected data. */\r\n    getSelected() {\r\n        return this.selected;\r\n    }\r\n    /** Get selected data. */\r\n    setSelected(items) {\r\n        this.selected = items;\r\n    }\r\n    /** Returns whether an item is selected. */\r\n    isSelected(item) {\r\n        if (this.selectedMap) {\r\n            return this.selectedMap.has(item);\r\n        }\r\n        else {\r\n            return this.selected.includes(item);\r\n        }\r\n    }\r\n    /** Whether selected at least one, but not all. */\r\n    isPartlySelected() {\r\n        let selectedCount = this.selected.length;\r\n        return selectedCount > 0 && selectedCount < this.currentData.length;\r\n    }\r\n    /** Whether selected all items. */\r\n    isSelectedAll() {\r\n        let selectedCount = this.selected.length;\r\n        return selectedCount > 0 && selectedCount === this.currentData.length;\r\n    }\r\n    /** Get selected count. */\r\n    getSelectedCount() {\r\n        return this.selected.length;\r\n    }\r\n    /** Selected items. */\r\n    select(...items) {\r\n        if (this.selectedMap) {\r\n            for (let item of items) {\r\n                if (!this.selectedMap.has(item)) {\r\n                    this.selected.push(item);\r\n                    this.selectedMap.add(item);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (let item of items) {\r\n                if (!this.selected.includes(item)) {\r\n                    this.selected.push(item);\r\n                }\r\n            }\r\n        }\r\n        this.lastTouchedItem = items[0];\r\n    }\r\n    /** Deselect items. */\r\n    deselect(...items) {\r\n        if (items === this.selected) {\r\n            this.deselectAll();\r\n        }\r\n        else {\r\n            let toRemove = new Set();\r\n            if (this.selectedMap) {\r\n                for (let item of items) {\r\n                    if (this.selectedMap.has(item)) {\r\n                        toRemove.add(this.selectedMap.get(item));\r\n                        this.selectedMap.delete(item);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                for (let item of items) {\r\n                    if (this.selected.includes(item)) {\r\n                        toRemove.add(item);\r\n                    }\r\n                }\r\n            }\r\n            if (toRemove.size > 0) {\r\n                this.selected = this.selected.filter(item => !toRemove.has(item));\r\n            }\r\n        }\r\n        this.lastTouchedItem = items[0];\r\n    }\r\n    /** Toggle select state of item. */\r\n    toggleSelect(item) {\r\n        if (this.isSelected(item)) {\r\n            this.deselect(item);\r\n        }\r\n        else {\r\n            this.select(item);\r\n        }\r\n        this.lastTouchedItem = item;\r\n    }\r\n    /** Select or deselect a range if pressed shify key, otherwise select or deselect one. */\r\n    selectByKeyEvent(item, event) {\r\n        if (event.shiftKey) {\r\n            this.shiftSelect(item);\r\n        }\r\n        else {\r\n            this.toggleSelect(item);\r\n        }\r\n    }\r\n    /** Select or deselect a range, from last touched item to current item. */\r\n    shiftSelect(item) {\r\n        let startIndex = Math.max(this.lastTouchedItem ? this.getFullIndexOf(this.lastTouchedItem) : 0, 0);\r\n        let endIndex = this.getFullIndexOf(item);\r\n        if (endIndex >= 0) {\r\n            if (startIndex > endIndex) {\r\n                [startIndex, endIndex] = [endIndex, startIndex];\r\n            }\r\n            endIndex += 1;\r\n            if (this.isSelected(item)) {\r\n                this.deselect(...this.currentData.slice(startIndex, endIndex));\r\n            }\r\n            else {\r\n                this.select(...this.currentData.slice(startIndex, endIndex));\r\n            }\r\n        }\r\n    }\r\n    /** Get item index in full data. */\r\n    getFullIndexOf(item) {\r\n        if (this.dataMap && !this.dataMap.has(item)) {\r\n            return -1;\r\n        }\r\n        if (this.key) {\r\n            let valueAtKey = item[this.key];\r\n            return this.fullData.findIndex(i => i[this.key] === valueAtKey);\r\n        }\r\n        else {\r\n            return this.fullData.indexOf(this.get(item));\r\n        }\r\n    }\r\n    /** Get item index in current data. */\r\n    getCurrentIndexOf(item) {\r\n        if (this.dataMap && !this.dataMap.has(item)) {\r\n            return -1;\r\n        }\r\n        if (this.key) {\r\n            let valueAtKey = item[this.key];\r\n            return this.currentData.findIndex(i => i[this.key] === valueAtKey);\r\n        }\r\n        else {\r\n            return this.currentData.indexOf(this.get(item));\r\n        }\r\n    }\r\n    /** Select all items. */\r\n    selectAll() {\r\n        this.select(...this.currentData);\r\n    }\r\n    /** Deselect all items. */\r\n    deselectAll() {\r\n        this.selected = [];\r\n        if (this.selectedMap) {\r\n            this.selectedMap.clear();\r\n        }\r\n    }\r\n    /** Select all items if not, otherwise deselect all. */\r\n    toggleSelectAll() {\r\n        if (this.isSelectedAll()) {\r\n            this.deselectAll();\r\n        }\r\n        else {\r\n            this.selectAll();\r\n        }\r\n    }\r\n    /** Clears all data. */\r\n    clear() {\r\n        this.fullData = [];\r\n        this.currentData = [];\r\n        this.deselectAll();\r\n        if (this.dataMap) {\r\n            this.dataMap.clear();\r\n        }\r\n        this.emit('dataChange');\r\n    }\r\n}\r\nexports.Store = Store;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Color = void 0;\r\nconst ff_1 = require(\"@pucelle/ff\");\r\n/** Class to process colors. */\r\nclass Color {\r\n    /** `value` is a css color values. */\r\n    constructor(value) {\r\n        this.value = value.trim();\r\n    }\r\n    /** Color from rgba values. */\r\n    static fromRGBA(r, g, b, a) {\r\n        r = Math.max(Math.min(r, 1), 0);\r\n        g = Math.max(Math.min(g, 1), 0);\r\n        b = Math.max(Math.min(b, 1), 0);\r\n        a = Math.max(Math.min(a, 1), 0);\r\n        if (a === 1) {\r\n            return new Color('#'\r\n                + (Math.round(255 * r)).toString(16).padStart(2, '0')\r\n                + (Math.round(255 * g)).toString(16).padStart(2, '0')\r\n                + (Math.round(255 * b)).toString(16).padStart(2, '0'));\r\n        }\r\n        else {\r\n            return new Color('rgba('\r\n                + (Math.round(255 * r)).toString() + ', '\r\n                + (Math.round(255 * g)).toString() + ', '\r\n                + (Math.round(255 * b)).toString() + ', '\r\n                + ff_1.toPower(a, -2) + ')');\r\n        }\r\n    }\r\n    /** Color from rgb values. */\r\n    static fromRGB(r, g, b) {\r\n        return Color.fromRGBA(r, g, b, 1);\r\n    }\r\n    toString() {\r\n        return this.value;\r\n    }\r\n    /** Get [r, g, b, a] values, all betweens 0 ~ 1. */\r\n    getRGBA() {\r\n        if (/^#[0-9a-fA-F]{3,6}$/.test(this.value)) {\r\n            return [...this.parseNormalColor(this.value), 1];\r\n        }\r\n        let match = this.value.match(/^rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/);\r\n        if (match) {\r\n            return [\r\n                Number(match[1]) / 255,\r\n                Number(match[2]) / 255,\r\n                Number(match[3]) / 255,\r\n                1\r\n            ];\r\n        }\r\n        match = this.value.match(/^rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*([\\d.]+)\\s*\\)$/);\r\n        if (match) {\r\n            return [\r\n                Number(match[1]) / 255,\r\n                Number(match[2]) / 255,\r\n                Number(match[3]) / 255,\r\n                Number(match[4]),\r\n            ];\r\n        }\r\n        match = this.value.match(/^rgba\\(\\s*(#[0-9a-fA-F]{3,6})\\s*,\\s*([\\d.]+)\\s*\\)$/);\r\n        if (match) {\r\n            return [...this.parseNormalColor(match[1]), Number(match[2])];\r\n        }\r\n        throw new Error(`\"${this.value}\" is not a valid RGB color`);\r\n    }\r\n    /** Get [r, g, b] values, all betweens 0 ~ 1. */\r\n    getRGB() {\r\n        return this.getRGBA().slice(0, 3);\r\n    }\r\n    parseNormalColor(color) {\r\n        if (color.length === 4) {\r\n            return [\r\n                parseInt(color[1], 16) * 17 / 255,\r\n                parseInt(color[2], 16) * 17 / 255,\r\n                parseInt(color[3], 16) * 17 / 255\r\n            ];\r\n        }\r\n        else {\r\n            return [\r\n                parseInt(color.slice(1, 3), 16) / 255,\r\n                parseInt(color.slice(3, 5), 16) / 255,\r\n                parseInt(color.slice(5, 7), 16) / 255\r\n            ];\r\n        }\r\n    }\r\n    /** Darken current color with percentage value betweens 0-100. */\r\n    darken(percentage) {\r\n        return this.lighten(-percentage);\r\n    }\r\n    /** Lighten current color with percentage value betweens 0-100. */\r\n    lighten(percentage) {\r\n        let [r, g, b, a] = this.getRGBA();\r\n        let p = percentage / 100;\r\n        r += p;\r\n        g += p;\r\n        b += p;\r\n        return Color.fromRGBA(r, g, b, a);\r\n    }\r\n    /** Move color to middle color, darken if is a light color, otherwise lighten. */\r\n    toMiddle(percentage) {\r\n        if (this.getLightness() < 0.5) {\r\n            return this.lighten(percentage);\r\n        }\r\n        else {\r\n            return this.darken(percentage);\r\n        }\r\n    }\r\n    /** Returns lightness value of current color, betweens 0 ~ 1. */\r\n    getLightness() {\r\n        let [r, g, b] = this.getRGBA();\r\n        return r * 0.299 + g * 0.587 + b * 0.114;\r\n    }\r\n    /** Returns average rgb value of current color, betweens 0 ~ 1. */\r\n    getAverage() {\r\n        let [r, g, b] = this.getRGBA();\r\n        return (r + g + b) / 3;\r\n    }\r\n    /**\r\n     * Change alpha channel of current color and returns a new color.\r\n     * alpha value `a` is betweens 0-1.\r\n     */\r\n    alpha(a) {\r\n        let [r, g, b] = this.getRGBA();\r\n        return Color.fromRGBA(r, g, b, a);\r\n    }\r\n    /** Mix with another color in percentage value betweens 0-100. */\r\n    mix(color, percentage) {\r\n        let [r, g, b, a] = this.getRGBA();\r\n        if (typeof color === 'string') {\r\n            color = new Color(color);\r\n        }\r\n        let [r2, g2, b2, a2] = color.getRGBA();\r\n        let p = percentage / 100;\r\n        r = r * (1 - p) + r2 * p;\r\n        g = g * (1 - p) + g2 * p;\r\n        b = b * (1 - p) + b2 * p;\r\n        a = a * (1 - p) + a2 * p;\r\n        return Color.fromRGBA(r, g, b, a);\r\n    }\r\n}\r\nexports.Color = Color;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst theme_1 = require(\"./theme\");\r\nflit_1.addGlobalStyle(() => {\r\n    let { mainColor, textColor, borderColor, errorColor, fontSize, borderRadius, focusBlurRadius, adjust, adjustFontSize, backgroundColor } = theme_1.theme;\r\n    return flit_1.css `\n\thtml{\n\t\tcolor: ${textColor};\n\t\tfont-size: ${fontSize}px;\n\t\tline-height: ${adjust(28)}px;\n\t\tbackground-color: ${backgroundColor};\n\t}\n\n\th1{\n\t\tfont-size: ${adjustFontSize(68)}px;\n\t\tline-height: 1.2;\n\t\tfont-weight: 700;\n\t}\n\n\th2{\n\t\tfont-size: ${adjustFontSize(36)}px;\n\t\tline-height: 1.2;\n\t\tfont-weight: 100;\n\t}\n\n\th3{\n\t\tfont-size: ${adjustFontSize(26)}px;\n\t\tline-height: 1.2;\n\t\tfont-weight: 400;\n\t}\n\n\th4{\n\t\tfont-size: ${adjustFontSize(22)}px;\n\t\tline-height: 1.2;\n\t\tfont-weight: 400;\n\t}\n\n\th5{\n\t\tfont-size: ${adjustFontSize(18)}px;\n\t\tline-height: 1.2;\n\t}\n\n\th6{\n\t\tfont-size: ${adjustFontSize(14)}px;\n\t\tline-height: 1.2;\n\t}\n\n\tbutton{\n\t\tdisplay: inline-flex;\n\t\tjustify-content: center;\n\t\theight: ${adjust(28)}px;\n\t\tline-height: ${adjust(28) - 2}px;\n\t\tborder: 1px solid ${borderColor};\n\t\tcolor: ${textColor};\n\t\tborder-radius: ${borderRadius}px;\n\t\tpadding: 0 ${adjust(12)}px;\n\t\tbackground: ${backgroundColor};\n\t\ttext-align: center;\n\t\tcursor: pointer;\n\t\tvertical-align: top;\n\t\twhite-space: nowrap;\n\t\toverflow: hidden;\n\t\ttext-overflow: ellipsis;\n\t\t\n\t\t&:hover, &:focus{\n\t\t\tborder-color: #666;\n\t\t\tbackground-color: #666;\n\t\t\tcolor: #fff;\n\t\t}\n\n\t\t&:active{\n\t\t\tbackground: ${textColor};\n\t\t\tborder-color: ${textColor};\n\t\t\tcolor: ${backgroundColor};\n\t\t}\n\n\t\t&:focus{\n\t\t\tbox-shadow: 0 0 ${focusBlurRadius}px ${mainColor};\n\t\t}\n\n\t\tf-icon, f-icon-loading{\n\t\t\tposition: relative;\n\t\t\ttop: -1px;\n\n\t\t\t&:first-child{\n\t\t\t\tmargin-right: ${adjust(6)}px;\n\t\t\t}\n\n\t\t\t&:last-child{\n\t\t\t\tmargin-left: ${adjust(6)}px;\n\t\t\t}\n\n\t\t\t&:only-child{\n\t\t\t\tmargin-left: 0;\n\t\t\t\tmargin-right: 0;\n\t\t\t}\n\t\t}\n\n\t\t&[primary]{\n\t\t\tbackground: ${mainColor};\n\t\t\tborder-color: ${mainColor};\n\t\t\tcolor: #fff;\n\n\t\t\t&:hover, &:focus{\n\t\t\t\tbackground: ${mainColor.darken(15)};\n\t\t\t\tborder-color: ${mainColor.darken(15)};\n\t\t\t}\n\t\t\n\t\t\t&:active{\n\t\t\t\tbackground: ${mainColor.darken(30)};\n\t\t\t\tborder-color: ${mainColor.darken(30)};\n\t\t\t}\n\t\t}\n\n\t\t&[flat]{\n\t\t\tborder: none;\n\t\t\tpadding-left: 0;\n\t\t\tpadding-right: 0;\n\t\t\tline-height: ${adjust(28)}px;\n\n\t\t\t&:hover, &:focus{\n\t\t\t\tbackground: none;\n\t\t\t\tcolor: ${textColor};\n\t\t\t}\n\n\t\t\t&:active{\n\t\t\t\tbackground: none;\n\t\t\t}\n\n\t\t\t&:focus{\n\t\t\t\tbox-shadow: none;\n\t\t\t}\n\t\t}\n\t}\n\n\ta[primary]{\n\t\tcolor: ${mainColor};\n\t}\n\n\tlabel{\n\t\tfont-weight: bold;\n\t\tfont-size: ${adjustFontSize(13)}px;\n\n\t\t&[required]{\n\t\t\t&::after{\n\t\t\t\tposition: relative;\n\t\t\t\tcontent: '*';\n\t\t\t\tcolor: ${errorColor};\n\t\t\t\tmargin-left: 2px;\n\t\t\t\ttop: ${adjust(-5)}px;\n\t\t\t}\n\t\t}\n\n\t\tf-icon{\n\t\t\tmargin-left: 4px;\n\t\t\tcolor: ${textColor.toMiddle(20)};\n\t\t}\n\t}\n\n\n\t.fade-enter, .fade-leave{\n\t\ttransition: opacity 0.2s ease-out;\n\t}\n\t\n\t.fade-enter-from, .fade-leave-to{\n\t\topacity: 0;\n\t}\n\t\n\t.fade-enter-to, .fade-leave-from{\n\t\topacity: 1;\n\t}\n\n\n\t::-webkit-scrollbar{\n\t\theight: 10px;\n\t\twidth: 10px;\n\t\tbackground: ${backgroundColor.toMiddle(10)};\n\t}\n\n\t::-webkit-scrollbar-thumb{\n\t\tbackground: ${backgroundColor.toMiddle(30)};\n\n\t\t&:hover{\n\t\t\tbackground: ${backgroundColor.toMiddle(40)};\n\t\t}\n\n\t\t&:active{\n\t\t\tbackground: ${backgroundColor.toMiddle(50)};\n\t\t}\n\t}\n`;\r\n});\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.theme = exports.Theme = void 0;\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nconst ff_1 = require(\"@pucelle/ff\");\r\nconst color_1 = require(\"./color\");\r\nclass Theme {\r\n    constructor() {\r\n        this.themeMap = new Map();\r\n        this.willUpdate = false;\r\n        this.mode = 'light';\r\n        this.options = { ...defaultLightThemeOptions, ...defaultMediumThemeOptions };\r\n    }\r\n    /** Define a new theme from overwritten options. */\r\n    defineTheme(name, options) {\r\n        this.themeMap.set(name, options);\r\n    }\r\n    getThemeDrakOrLightMode(options) {\r\n        if (options.backgroundColor) {\r\n            let [r, g, b] = new color_1.Color(options.backgroundColor).getRGBA();\r\n            if (ff_1.avg([r, g, b]) < 0.5) {\r\n                return 'dark';\r\n            }\r\n        }\r\n        else if (options.textColor) {\r\n            let [r, g, b] = new color_1.Color(options.textColor).getRGBA();\r\n            if (ff_1.avg([r, g, b]) > 0.5) {\r\n                return 'dark';\r\n            }\r\n        }\r\n        return 'light';\r\n    }\r\n    /**\r\n     * Assigns more theme options to current options, so it may keep options of last theme.\r\n     * Default themes includes: dark, light, small, medium, large, touch.\r\n     */\r\n    assignTheme(...names) {\r\n        for (let name of names) {\r\n            if (!this.themeMap.has(name)) {\r\n                throw new Error(`\"${name}\" is not a defined theme`);\r\n            }\r\n            Object.assign(this.options, this.themeMap.get(name));\r\n        }\r\n        this.mode = this.getThemeDrakOrLightMode(this.options);\r\n        this.update();\r\n    }\r\n    /** Set single options. */\r\n    set(key, value) {\r\n        this.options[key] = value;\r\n        this.update();\r\n    }\r\n    async update() {\r\n        if (!this.willUpdate) {\r\n            this.willUpdate = true;\r\n            await Promise.resolve();\r\n            flit_1.updateAllComponents();\r\n            flit_1.updateAllStyles();\r\n            this.willUpdate = false;\r\n        }\r\n    }\r\n    getOption(property) {\r\n        return this.options[property];\r\n    }\r\n    /**\r\n     * Convert `font-size` on default theme settings, to the size in current theme settings.\r\n     * Returns value will be at least 11.\r\n     */\r\n    get adjustFontSize() {\r\n        return (size) => {\r\n            return Math.max(Math.round(size * this.fontSize / defaultMediumThemeOptions.fontSize), 11);\r\n        };\r\n    }\r\n    /** Convert `line-height` on default theme settings, to the line height in current theme settings. */\r\n    get adjust() {\r\n        return (size) => {\r\n            return Math.round(size * this.lineHeight / defaultMediumThemeOptions.lineHeight);\r\n        };\r\n    }\r\n    /** Main hightlight color. */\r\n    get mainColor() {\r\n        return new color_1.Color(this.getOption('mainColor'));\r\n    }\r\n    /** Background color. */\r\n    get backgroundColor() {\r\n        return new color_1.Color(this.getOption('backgroundColor'));\r\n    }\r\n    /** Text color. */\r\n    get textColor() {\r\n        return new color_1.Color(this.getOption('textColor'));\r\n    }\r\n    /** Color for success message. */\r\n    get successColor() {\r\n        return new color_1.Color(this.getOption('successColor'));\r\n    }\r\n    /** Color for error message. */\r\n    get errorColor() {\r\n        return new color_1.Color(this.getOption('errorColor'));\r\n    }\r\n    /** Color for warning message. */\r\n    get warningColor() {\r\n        return new color_1.Color(this.getOption('warningColor'));\r\n    }\r\n    /** Color for info message. */\r\n    get infoColor() {\r\n        return new color_1.Color(this.getOption('infoColor'));\r\n    }\r\n    /** Border color. */\r\n    get borderColor() {\r\n        return new color_1.Color(this.getOption('borderColor'));\r\n    }\r\n    /** Border radius in pixels. */\r\n    get borderRadius() {\r\n        return this.getOption('borderRadius');\r\n    }\r\n    /** Color of popup backgound. */\r\n    get popupBackgroundColor() {\r\n        return new color_1.Color(this.getOption('popupBackgroundColor'));\r\n    }\r\n    /** Popup border radius in pixels. */\r\n    get popupBorderRadius() {\r\n        return this.getOption('popupBorderRadius');\r\n    }\r\n    /** Popup shadow blur radius in pixels. */\r\n    get popupShadowBlurRadius() {\r\n        return this.getOption('popupShadowBlurRadius');\r\n    }\r\n    /** Color of popup shadow. */\r\n    get popupShadowColor() {\r\n        return new color_1.Color(this.getOption('popupShadowColor'));\r\n    }\r\n    /** Blur radius in pixels for focus elements. */\r\n    get focusBlurRadius() {\r\n        return this.getOption('focusBlurRadius');\r\n    }\r\n    /** Font size. */\r\n    get fontSize() {\r\n        return this.getOption('fontSize');\r\n    }\r\n    /** Height of normal one line components, not the `lineHeight` of multiple lines. */\r\n    get lineHeight() {\r\n        return this.getOption('lineHeight');\r\n    }\r\n}\r\nexports.Theme = Theme;\r\nconst defaultLightThemeOptions = {\r\n    mainColor: '#3a6cf6',\r\n    backgroundColor: '#fff',\r\n    textColor: '#000',\r\n    infoColor: '#3369fa',\r\n    successColor: '#29bc04',\r\n    errorColor: '#e10000',\r\n    warningColor: '#f3b907',\r\n    borderColor: '#9b9b9b',\r\n    popupBackgroundColor: '#fff',\r\n    popupShadowColor: 'rgba(0, 0, 0, 0.4)',\r\n};\r\nconst defaultMediumThemeOptions = {\r\n    borderRadius: 4,\r\n    popupBorderRadius: 4,\r\n    popupShadowBlurRadius: 6,\r\n    focusBlurRadius: 6,\r\n    fontSize: 14,\r\n    lineHeight: 28,\r\n};\r\nexports.theme = new Theme();\r\nexports.theme.defineTheme('light', defaultLightThemeOptions);\r\nexports.theme.defineTheme('dark', {\r\n    mainColor: '#3a6cf6',\r\n    backgroundColor: '#333',\r\n    textColor: '#eee',\r\n    borderColor: '#888',\r\n    popupBackgroundColor: '#333',\r\n    popupShadowColor: 'rgba(0, 0, 0, 0.6)',\r\n});\r\nexports.theme.defineTheme('small', {\r\n    fontSize: 13,\r\n    lineHeight: 24,\r\n});\r\nexports.theme.defineTheme('medium', defaultMediumThemeOptions);\r\nexports.theme.defineTheme('large', {\r\n    fontSize: 16,\r\n    lineHeight: 32,\r\n});\r\nexports.theme.defineTheme('touch', {\r\n    fontSize: 18,\r\n    lineHeight: 46,\r\n});\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.translations = exports.Translations = void 0;\r\nconst ff_1 = require(\"@pucelle/ff\");\r\nconst flit_1 = require(\"@pucelle/flit\");\r\nclass Translations {\r\n    constructor() {\r\n        this.language = 'en-us';\r\n        this.data = new Map([['en-us', {}]]);\r\n    }\r\n    /** Get current language. */\r\n    getLanguage() {\r\n        return this.language;\r\n    }\r\n    /**\r\n     * Set current language and update all components.\r\n     * @language Language to set, like `en-us`, `zh-cn`.\r\n     */\r\n    setLanguage(language) {\r\n        this.language = language;\r\n        flit_1.updateAllComponents();\r\n    }\r\n    /**\r\n     * Add a translation pieces in `{key: value}` format.\r\n     * @language Language to add translation pieces to.\r\n     * @pieces Translation pieces, in `{key: translation, ...}` format.\r\n     */\r\n    add(language, pieces) {\r\n        let data = this.data.get(language);\r\n        if (!data) {\r\n            this.data.set(language, data = {});\r\n        }\r\n        Object.assign(data, pieces);\r\n    }\r\n    /**\r\n     * Get translation value from key and may format with arguments.\r\n     * @param key Translation key.\r\n     * @param args Parameters format translation value.\r\n     */\r\n    get(key, ...args) {\r\n        let data = this.data.get(this.language);\r\n        if (!data) {\r\n            data = this.data.get('en-us');\r\n        }\r\n        let value = data[key];\r\n        if (args.length) {\r\n            value = ff_1.format(value, args);\r\n        }\r\n        return value;\r\n    }\r\n    /**\r\n     * Translate string like `DefaultValue@@key`.\r\n     * @param key Translation key.\r\n     * @param args Parameters format translation value.\r\n     */\r\n    translate(key, ...args) {\r\n        let [defaultValue, id] = key.split('@@');\r\n        let data = this.data.get(this.language);\r\n        let value = '';\r\n        if (!data) {\r\n            data = this.data.get('en-us');\r\n        }\r\n        if (id) {\r\n            value = data[id] || defaultValue;\r\n        }\r\n        if (args.length) {\r\n            value = ff_1.format(value, args);\r\n        }\r\n        return value;\r\n    }\r\n    /**\r\n     * Translate `\"xxx\"` to `<b>xxx</b>`.\r\n     * @param key Translation key.\r\n     * @param args Parameters format translation value.\r\n     */\r\n    translateQuoteToBold(key, ...args) {\r\n        let value = this.translate(key, ...args.map(arg => ff_1.encodeHTML(String(arg))));\r\n        return value.replace(/\"(.+?)\"/g, '<b>$1</b>');\r\n    }\r\n}\r\nexports.Translations = Translations;\r\n/** Global transition API. */\r\nexports.translations = new Translations();\r\n/** Transitions for `<f-dialog>`. */\r\nexports.translations.add('en-us', {\r\n    ok: 'OK',\r\n    cancel: 'Cancel',\r\n    yes: 'Yes',\r\n    no: 'No',\r\n});\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.appendTo = void 0;\r\n/**\r\n * Append a fragment or element into target element or selector.\r\n * Returns the first element in the fragment.\r\n * It's a helper function to use like `appendTo(render(...), document.body)`.\r\n * @param el The fragment to append.\r\n * @param target The target element to append to.\r\n */\r\nfunction appendTo(el, target) {\r\n    let firstElement = el.firstElementChild;\r\n    if (typeof target === 'string') {\r\n        let targetEl = document.querySelector(target);\r\n        if (targetEl && targetEl.lastElementChild !== el) {\r\n            targetEl.append(el);\r\n        }\r\n    }\r\n    else if (target && target.lastElementChild !== el) {\r\n        target.append(el);\r\n    }\r\n    return firstElement;\r\n}\r\nexports.appendTo = appendTo;\r\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7hBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACv7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3iBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxDA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}